/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "../../node_modules/@inrealtime/react/dist/index.js":
/*!**********************************************************!*\
  !*** ../../node_modules/@inrealtime/react/dist/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _array_with_holes(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _array_without_holes(arr) {\n    if (Array.isArray(arr)) return _array_like_to_array(arr);\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _class_call_check(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n        throw new TypeError(\"Cannot call a class as a function\");\n    }\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n}\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _iterable_to_array(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _iterable_to_array_limit(arr, i) {\n    var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (_i == null) return;\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){\n            _arr.push(_s.value);\n            if (i && _arr.length === i) break;\n        }\n    } catch (err) {\n        _d = true;\n        _e = err;\n    } finally{\n        try {\n            if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n        } finally{\n            if (_d) throw _e;\n        }\n    }\n    return _arr;\n}\nfunction _non_iterable_rest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _non_iterable_spread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _object_destructuring_empty(o) {\n    if (o === null || o === void 0) throw new TypeError(\"Cannot destructure \" + o);\n    return o;\n}\nfunction _object_spread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        var ownKeys = Object.keys(source);\n        if (typeof Object.getOwnPropertySymbols === \"function\") {\n            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n            }));\n        }\n        ownKeys.forEach(function(key) {\n            _define_property(target, key, source[key]);\n        });\n    }\n    return target;\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _object_spread_props(target, source) {\n    source = source != null ? source : {};\n    if (Object.getOwnPropertyDescriptors) {\n        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n        ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _sliced_to_array(arr, i) {\n    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();\n}\nfunction _to_consumable_array(arr) {\n    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return(g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g);\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = function(target, all) {\n    for(var name in all)__defProp(target, name, {\n        get: all[name],\n        enumerable: true\n    });\n};\nvar __copyProps = function(to, from, except, desc) {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            var _loop = function() {\n                var key = _step.value;\n                if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n                    get: function() {\n                        return from[key];\n                    },\n                    enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n                });\n            };\n            for(var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return to;\n};\nvar __toESM = function(mod, isNodeMode, target) {\n    return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod);\n};\nvar __toCommonJS = function(mod) {\n    return __copyProps(__defProp({}, \"__esModule\", {\n        value: true\n    }), mod);\n};\n// src/index.ts\nvar src_exports = {};\n__export(src_exports, {\n    RealtimeConnectionStatus: function() {\n        return RealtimeConnectionStatus;\n    },\n    RealtimeDocumentStatus: function() {\n        return RealtimeDocumentStatus;\n    },\n    RealtimePresenceStatus: function() {\n        return RealtimePresenceStatus;\n    },\n    createRealtimeContext: function() {\n        return createRealtimeContext;\n    },\n    createRealtimeDocumentContext: function() {\n        return createRealtimeDocumentContext;\n    },\n    createRealtimeGroupContext: function() {\n        return createRealtimeGroupContext;\n    },\n    useAutosave: function() {\n        return useAutosave;\n    },\n    useRealtime: function() {\n        return useRealtime;\n    }\n});\nmodule.exports = __toCommonJS(src_exports);\n// src/channels/presence/usePresence.ts\nvar import_react4 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/auth/useAuth.ts\nvar import_react = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar AuthenticationErrorExponentialTimerStart = 1e3;\nvar AuthenticationErrorExponentialTimerMax = 8e3;\nvar ReAuthenticationTimeBeforeTokenExpiry = 2.5 * 60 * 1e3;\nvar getJwtPayload = function(token) {\n    var base64Url = token.split(\".\")[1];\n    var base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    var jsonPayload = decodeURIComponent(atob(base64).split(\"\").map(function(c) {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n    }).join(\"\"));\n    return JSON.parse(jsonPayload);\n};\nvar authenticateFn = function() {\n    var _ref = _async_to_generator(function(param) {\n        var realtimeAuth, documentId, groupId, _ref, socketUrl, token, projectId, tokenPayload, tokenExpiryTime;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    realtimeAuth = param.realtimeAuth, documentId = param.documentId, groupId = param.groupId;\n                    return [\n                        4,\n                        realtimeAuth.auth({\n                            documentId: documentId,\n                            groupId: groupId\n                        })\n                    ];\n                case 1:\n                    _ref = _state.sent(), socketUrl = _ref.socketUrl, token = _ref.token, projectId = _ref.projectId;\n                    tokenPayload = getJwtPayload(token);\n                    tokenExpiryTime = tokenPayload.exp;\n                    return [\n                        2,\n                        {\n                            socketUrl: socketUrl,\n                            token: token,\n                            tokenExpiryTime: tokenExpiryTime,\n                            projectId: projectId\n                        }\n                    ];\n            }\n        });\n    });\n    return function authenticateFn(_) {\n        return _ref.apply(this, arguments);\n    };\n}();\nvar useAuth = function(param) {\n    var config = param.config, documentId = param.documentId, groupId = param.groupId, getAuthToken = param.getAuthToken, publicAuthKey = param.publicAuthKey;\n    var _ref = _sliced_to_array((0, import_react.useState)({}), 2), authData = _ref[0], setAuthData = _ref[1];\n    var _ref1 = _sliced_to_array((0, import_react.useState)(\"Authenticating\" /* Authenticating */ ), 2), status = _ref1[0], setStatus = _ref1[1];\n    var _ref2 = _sliced_to_array((0, import_react.useState)(0), 2), exponentialTimer = _ref2[0], setExponentialTimer = _ref2[1];\n    var realtimeAuth = (0, import_react.useMemo)(function() {\n        return new RealtimeAuth({\n            config: config,\n            getAuthToken: getAuthToken,\n            publicAuthKey: publicAuthKey\n        });\n    }, [\n        getAuthToken,\n        publicAuthKey\n    ]);\n    var authenticate = (0, import_react.useCallback)(function() {\n        return authenticateFn({\n            realtimeAuth: realtimeAuth,\n            documentId: documentId,\n            groupId: groupId\n        });\n    }, [\n        realtimeAuth,\n        documentId,\n        groupId\n    ]);\n    (0, import_react.useEffect)(function() {\n        if (status !== \"Error\" /* Error */ ) {\n            return;\n        }\n        var timer = setInterval(function() {\n            setStatus(\"Authenticating\" /* Authenticating */ );\n        }, exponentialTimer);\n        return function() {\n            clearInterval(timer);\n        };\n    }, [\n        status,\n        exponentialTimer,\n        setStatus\n    ]);\n    (0, import_react.useEffect)(function() {\n        if (status !== \"Authenticated\" /* Authenticated */  || authData.tokenExpiryTime === void 0) {\n            return;\n        }\n        var timer = setInterval(function() {\n            var diff = authData.tokenExpiryTime - Date.now() / 1e3 - ReAuthenticationTimeBeforeTokenExpiry / 1e3;\n            if (diff < 0) {\n                setStatus(\"Authenticating\" /* Authenticating */ );\n                if (config.logging.socketStatus) console.log(\"Auth status -> Authenticating\");\n            }\n        }, 5e3);\n        return function() {\n            clearInterval(timer);\n        };\n    }, [\n        status,\n        authData,\n        setStatus\n    ]);\n    (0, import_react.useEffect)(function() {\n        if (status !== \"Authenticated\" /* Authenticated */ ) {\n            return;\n        }\n        if (documentId === void 0 && groupId === void 0) {\n            return;\n        }\n        if (documentId !== void 0 && authData.documentId === documentId || groupId !== void 0 && authData.groupId === groupId) {\n            return;\n        }\n        setAuthData({});\n        setStatus(\"Authenticating\" /* Authenticating */ );\n        setExponentialTimer(0);\n    }, [\n        status,\n        documentId,\n        groupId\n    ]);\n    (0, import_react.useEffect)(function() {\n        if (documentId === void 0 && groupId === void 0) {\n            setAuthData({});\n            setStatus(\"Authenticating\" /* Authenticating */ );\n            setExponentialTimer(0);\n            return;\n        }\n        if (status !== \"Authenticating\" /* Authenticating */ ) {\n            return;\n        }\n        authenticate().then(function(param) {\n            var socketUrl = param.socketUrl, token = param.token, tokenExpiryTime = param.tokenExpiryTime, projectId = param.projectId;\n            setAuthData({\n                socketUrl: socketUrl,\n                token: token,\n                tokenExpiryTime: tokenExpiryTime,\n                projectId: projectId,\n                documentId: documentId,\n                groupId: groupId\n            });\n            setStatus(\"Authenticated\" /* Authenticated */ );\n            if (config.logging.socketStatus) console.log(\"Auth status -> Authenticated\");\n        }).catch(function(e) {\n            console.error(e);\n            setStatus(\"Error\" /* Error */ );\n            if (config.logging.socketStatus) console.log(\"Auth status' -> Error\");\n            var newExponentialTimer = Math.min(AuthenticationErrorExponentialTimerMax, exponentialTimer < AuthenticationErrorExponentialTimerStart ? AuthenticationErrorExponentialTimerStart : exponentialTimer * 2);\n            setExponentialTimer(newExponentialTimer);\n        });\n    }, [\n        status,\n        authenticate,\n        documentId,\n        groupId\n    ]);\n    return {\n        status: status,\n        socketUrl: authData.socketUrl,\n        token: authData.token,\n        projectId: authData.projectId\n    };\n};\n// src/core/auth/realtimeAuth.ts\nvar RealtimeAuth = /*#__PURE__*/ function() {\n    function RealtimeAuth(param) {\n        var config = param.config, getAuthToken = param.getAuthToken, publicAuthKey = param.publicAuthKey;\n        _class_call_check(this, RealtimeAuth);\n        this._config = config;\n        this._getAuthToken = getAuthToken;\n        this._publicAuthKey = publicAuthKey;\n    }\n    _create_class(RealtimeAuth, [\n        {\n            key: \"auth\",\n            value: function auth(param) {\n                var documentId = param.documentId, groupId = param.groupId;\n                var _this = this;\n                return _async_to_generator(function() {\n                    var token, response, tokenPayload, projectId, socketUrl;\n                    return _ts_generator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!_this._getAuthToken) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._getAuthToken({\n                                        documentId: documentId,\n                                        groupId: groupId\n                                    })\n                                ];\n                            case 1:\n                                token = _state.sent();\n                                if (_this._publicAuthKey) {\n                                    console.warn(\"Both 'getAuthToken' and 'publicAuthKey' were provided. 'getAuthToken' will be used.\");\n                                }\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 2:\n                                if (!_this._publicAuthKey) return [\n                                    3,\n                                    5\n                                ];\n                                if (!_this._publicAuthKey.startsWith(\"public_\")) {\n                                    throw new Error(\"Invalid 'publicAuthKey'. It should start with 'public_'.\");\n                                }\n                                return [\n                                    4,\n                                    fetch(_this._config.authUrl, {\n                                        method: \"POST\",\n                                        headers: {\n                                            \"Content-Type\": \"application/json\"\n                                        },\n                                        body: JSON.stringify({\n                                            authKey: _this._publicAuthKey\n                                        }),\n                                        credentials: \"include\"\n                                    })\n                                ];\n                            case 3:\n                                response = _state.sent();\n                                if (response.status === 401 || response.status === 403) {\n                                    throw new Error(\"Either a wrong 'publicAuthKey' was provided or 'publicAuthKey' is not enabled.\");\n                                }\n                                return [\n                                    4,\n                                    response.json()\n                                ];\n                            case 4:\n                                token = _state.sent().token;\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                throw new Error(\"Either 'getAuthToken' or 'publicAuthKey' must be provided.\");\n                            case 6:\n                                tokenPayload = getJwtPayload(token);\n                                projectId = tokenPayload.projectId;\n                                socketUrl = groupId !== void 0 ? \"\".concat(_this._config.webSocketUrl, \"/projects/\").concat(projectId, \"/groups/\").concat(groupId) : \"\".concat(_this._config.webSocketUrl, \"/projects/\").concat(projectId, \"/documents/\").concat(documentId);\n                                return [\n                                    2,\n                                    {\n                                        socketUrl: socketUrl,\n                                        projectId: projectId,\n                                        authExpiryTime: tokenPayload.exp,\n                                        token: token\n                                    }\n                                ];\n                        }\n                    });\n                })();\n            }\n        }\n    ]);\n    return RealtimeAuth;\n}();\n// src/core/socket/realtimeWebsocket.ts\nvar socketTimeout = 15e3;\nvar RealtimeWebSocket = /*#__PURE__*/ function() {\n    function RealtimeWebSocket(param) {\n        var onOpen = param.onOpen, onConnecting = param.onConnecting, onClose = param.onClose, onMessage = param.onMessage, config = param.config;\n        _class_call_check(this, RealtimeWebSocket);\n        this._onOpen = onOpen;\n        this._onConnecting = onConnecting;\n        this._onClose = onClose;\n        this._onMessage = onMessage;\n        this._config = config;\n    }\n    _create_class(RealtimeWebSocket, [\n        {\n            key: \"setSocketUrl\",\n            value: function setSocketUrl(param) {\n                var socketUrl = param.socketUrl;\n                this._socketUrl = socketUrl;\n            }\n        },\n        {\n            key: \"_jsonStringifyReplacer\",\n            value: function _jsonStringifyReplacer(k, v) {\n                return v === void 0 ? null : v;\n            }\n        },\n        {\n            key: \"sendMessage\",\n            value: function sendMessage(channel, message) {\n                var _this__webSocket, _this__webSocket1;\n                if (((_this__webSocket = this._webSocket) === null || _this__webSocket === void 0 ? void 0 : _this__webSocket.readyState) !== WebSocket.OPEN) {\n                    return;\n                }\n                (_this__webSocket1 = this._webSocket) === null || _this__webSocket1 === void 0 ? void 0 : _this__webSocket1.send(\"\".concat(channel, \":\").concat(JSON.stringify(message, this._jsonStringifyReplacer)));\n            }\n        },\n        {\n            key: \"close\",\n            value: function close() {\n                this._close(this._webSocket);\n            }\n        },\n        {\n            key: \"_close\",\n            value: function _close(webSocket) {\n                if (this._timeoutTimer !== void 0) {\n                    clearInterval(this._timeoutTimer);\n                }\n                if (!webSocket) {\n                    return;\n                }\n                if (this._onClose) {\n                    this._onClose();\n                }\n                try {\n                    webSocket.close(1e3, \"Closing socket manually\");\n                } catch (e) {\n                    console.error(e);\n                }\n            }\n        },\n        {\n            key: \"connect\",\n            value: function connect() {\n                var _this = this;\n                if (!this._socketUrl) {\n                    throw new Error(\"Missing socket url.\");\n                }\n                var webSocket = new WebSocket(this._socketUrl);\n                this._webSocket = webSocket;\n                this._lastReceivedMessage = /* @__PURE__ */ new Date();\n                this._timeoutTimer = setInterval(function() {\n                    var now = /* @__PURE__ */ new Date();\n                    if (now.getTime() - _this._lastReceivedMessage.getTime() > socketTimeout) {\n                        var _this__config;\n                        if ((_this__config = _this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.socketStatus) console.log(\"Closing socket in timeout timer\");\n                        _this._close(webSocket);\n                    }\n                }, socketTimeout / 2);\n                webSocket.onopen = function() {\n                    if (_this._onOpen) {\n                        _this._onOpen();\n                    }\n                };\n                webSocket.onclose = function(e) {\n                    var _this__config;\n                    if (_this._onClose) {\n                        _this._onClose();\n                    }\n                    if (e && e.code === 3e3) {\n                        console.warn(\"Socket closed with code '\".concat(e.code, \"', type '\").concat(e.type, \"' and reason '\").concat(e.reason, \"'.\"));\n                    } else if ((_this__config = _this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.socketStatus) {\n                        console.log(\"Socket closed with code '\".concat(e.code, \"', type '\").concat(e.type, \"' and reason '\").concat(e.reason, \"'.\"));\n                    }\n                };\n                webSocket.onerror = function() {\n                    var _this__config;\n                    if ((_this__config = _this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.socketStatus) console.log(\"Closing socket in onError\");\n                    _this._close(webSocket);\n                };\n                webSocket.onmessage = function(e) {\n                    if (!_this._onMessage) {\n                        console.log(\"Ignored message '\".concat(e.data, \"' as no onMessage hook was found.\"));\n                        return;\n                    }\n                    _this._lastReceivedMessage = /* @__PURE__ */ new Date();\n                    var unparsedMessage = e === null || e === void 0 ? void 0 : e.data;\n                    if (!unparsedMessage) {\n                        return;\n                    }\n                    var indexOfColon = unparsedMessage.indexOf(\":\");\n                    if (indexOfColon < 0) {\n                        console.error(\"Invalid formatted message from server.\");\n                        return;\n                    }\n                    var channel = unparsedMessage.substring(0, indexOfColon);\n                    var messageStr = unparsedMessage.substring(indexOfColon + 1);\n                    var message;\n                    try {\n                        message = JSON.parse(messageStr);\n                    } catch (e2) {\n                        console.error(\"Invalid JSON in message from server.\");\n                        return;\n                    }\n                    _this._onMessage(channel, message);\n                };\n                if (this._onConnecting) {\n                    this._onConnecting();\n                }\n            }\n        }\n    ]);\n    return RealtimeWebSocket;\n}();\n// src/core/types/documentOperation.ts\nvar DocumentOperationRoot = \"root\";\nvar DocumentOperationInsert = \"insert\";\nvar DocumentOperationReplace = \"replace\";\nvar DocumentOperationMove = \"move\";\n// src/core/utils/typeUtils.ts\nvar clone = function(obj) {\n    if (obj && typeof obj === \"object\") {\n        if (Array.isArray(obj)) {\n            return obj.map(function(a) {\n                return clone(a);\n            });\n        } else if (obj.constructor === Object) {\n            return Object.entries(obj).reduce(function(prev, param) {\n                var _param = _sliced_to_array(param, 2), k = _param[0], v = _param[1];\n                return _object_spread_props(_object_spread({}, prev), _define_property({}, k, clone(v)));\n            }, {});\n        }\n        return obj;\n    }\n    return obj;\n};\nvar isMap = function(value) {\n    return typeof value === \"object\" && value !== null && !_instanceof(value, Array) && !_instanceof(value, Date);\n};\nvar isList = function(value) {\n    return Array.isArray(value);\n};\nvar isNumber = function(value) {\n    return Number(value) === value;\n};\nvar isString = function(value) {\n    return typeof value === \"string\" || _instanceof(value, String);\n};\nvar isBoolean = function(value) {\n    return typeof value === \"boolean\";\n};\nvar listsShallowEqual = function(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n    for(var i = 0; i < a.length; ++i){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\nvar listsShallowStartsWith = function(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length > b.length) return false;\n    for(var i = 0; i < a.length; ++i){\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n};\n// src/core/utils/uniqueId.ts\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar uniqueId = function() {\n    var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;\n    var id = \"\";\n    var i = size;\n    while(i--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\n// src/socket/types.ts\nvar RealtimeConnectionStatus = /* @__PURE__ */ function(RealtimeConnectionStatus2) {\n    RealtimeConnectionStatus2[\"Closed\"] = \"Closed\";\n    RealtimeConnectionStatus2[\"Connecting\"] = \"Connecting\";\n    RealtimeConnectionStatus2[\"Authenticating\"] = \"Authenticating\";\n    RealtimeConnectionStatus2[\"Open\"] = \"Open\";\n    return RealtimeConnectionStatus2;\n}(RealtimeConnectionStatus || {});\n// src/channels/presence/useCollaboratorStore.ts\nvar import_react2 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar import_zustand = __webpack_require__(/*! zustand */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js\");\nvar import_middleware = __webpack_require__(/*! zustand/middleware */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js\");\nvar useCollaboratorStore = function() {\n    var useStoreWithPatchRef = (0, import_react2.useRef)((0, import_zustand.create)()((0, import_middleware.subscribeWithSelector)(function(set, get) {\n        return {\n            initial: true,\n            data: [],\n            patch: function(fn) {\n                set({\n                    initial: false,\n                    data: _to_consumable_array(fn({\n                        presences: get().data\n                    }))\n                });\n            },\n            reset: function() {\n                if (get().initial) {\n                    return;\n                }\n                set({\n                    initial: true,\n                    data: []\n                });\n            }\n        };\n    })));\n    var patch = (0, import_react2.useMemo)(function() {\n        return function(fn) {\n            return useStoreWithPatchRef.current.getState().patch(fn);\n        };\n    }, []);\n    var reset = (0, import_react2.useMemo)(function() {\n        return function() {\n            return useStoreWithPatchRef.current.getState().reset();\n        };\n    }, []);\n    var useStore = (0, import_react2.useMemo)(function() {\n        return function(selector, equalityFn) {\n            return useStoreWithPatchRef.current(function(root) {\n                return root.data === void 0 ? void 0 : selector ? selector(root.data) : root.data;\n            }, equalityFn);\n        };\n    }, []);\n    var subscribe = (0, import_react2.useMemo)(function() {\n        return function(selector, listener, options) {\n            return useStoreWithPatchRef.current.subscribe(function(root) {\n                return root.data === void 0 ? void 0 : selector ? selector(root.data) : root.data;\n            }, listener, options);\n        };\n    }, []);\n    return {\n        useStore: useStore,\n        patch: patch,\n        subscribe: subscribe,\n        reset: reset\n    };\n};\n// src/channels/presence/usePresenceStore.ts\nvar import_react3 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar import_zustand2 = __webpack_require__(/*! zustand */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js\");\nvar import_middleware2 = __webpack_require__(/*! zustand/middleware */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js\");\nvar usePresenceStore = function() {\n    var useStoreWithPatchRef = (0, import_react3.useRef)((0, import_zustand2.create)()((0, import_middleware2.subscribeWithSelector)(function(set, get) {\n        return {\n            initial: true,\n            data: {\n                data: {}\n            },\n            patch: function(fn) {\n                set({\n                    initial: false,\n                    data: fn({\n                        presence: get().data\n                    })\n                });\n            },\n            reset: function() {\n                if (get().initial) {\n                    return;\n                }\n                set({\n                    initial: true,\n                    data: {\n                        data: {}\n                    }\n                });\n            }\n        };\n    })));\n    var patch = (0, import_react3.useMemo)(function() {\n        return function(fn) {\n            return useStoreWithPatchRef.current.getState().patch(fn);\n        };\n    }, []);\n    var reset = (0, import_react3.useMemo)(function() {\n        return function() {\n            return useStoreWithPatchRef.current.getState().reset();\n        };\n    }, []);\n    var useStore = (0, import_react3.useMemo)(function() {\n        return function(selector, equalityFn) {\n            return useStoreWithPatchRef.current(function(root) {\n                return root.data === void 0 ? void 0 : selector ? selector(root.data) : root.data;\n            }, equalityFn);\n        };\n    }, []);\n    var subscribe = (0, import_react3.useMemo)(function() {\n        return function(selector, listener, options) {\n            return useStoreWithPatchRef.current.subscribe(function(root) {\n                return root.data === void 0 ? void 0 : selector ? selector(root.data) : root.data;\n            }, listener, options);\n        };\n    }, []);\n    return {\n        useStore: useStore,\n        patch: patch,\n        subscribe: subscribe,\n        reset: reset\n    };\n};\n// src/channels/presence/utils.ts\nvar mergeData = function(oldData, newData) {\n    if (oldData === void 0 || newData == void 0 || !isMap(oldData) || !isMap(newData)) {\n        return newData;\n    } else {\n        return _object_spread({}, oldData, newData);\n    }\n};\n// src/channels/presence/usePresence.ts\nvar RealtimePresenceStatus = /* @__PURE__ */ function(RealtimePresenceStatus2) {\n    RealtimePresenceStatus2[\"Unready\"] = \"Unready\";\n    RealtimePresenceStatus2[\"Syncing\"] = \"Syncing\";\n    RealtimePresenceStatus2[\"Ready\"] = \"Ready\";\n    return RealtimePresenceStatus2;\n}(RealtimePresenceStatus || {});\nvar ReplaceMessageType = \"replace\";\nvar UpdateMessageType = \"update\";\nvar usePresenceChannel = function(param) {\n    var connectionStatus = param.connectionStatus, connectionStatusRef = param.connectionStatusRef, useChannel = param.useChannel, throttle = param.throttle;\n    var _ref = _sliced_to_array((0, import_react4.useState)(\"Unready\" /* Unready */ ), 2), status = _ref[0], setStatus = _ref[1];\n    var statusRef = (0, import_react4.useRef)(\"Unready\" /* Unready */ );\n    var presenceClientIdRef = (0, import_react4.useRef)();\n    var presenceLoadedRef = (0, import_react4.useRef)(false);\n    var preSyncMessagesRef = (0, import_react4.useRef)([]);\n    var collaboratorStore = useCollaboratorStore();\n    var presenceStore = usePresenceStore();\n    var applyPresenceClientResponse = (0, import_react4.useCallback)(function(response) {\n        switch(response.type){\n            case \"client_add\":\n                if (response.client.clientId === presenceClientIdRef.current) {\n                    presenceStore.patch(function(param) {\n                        var presence = param.presence;\n                        response.client.data = presence.data;\n                        if (presence.data && isMap(presence.data) && Object.keys(presence.data).length === 0) {\n                            return response.client;\n                        }\n                        sendMessage({\n                            messageId: uniqueId(),\n                            type: ReplaceMessageType,\n                            data: clone(presence.data)\n                        });\n                        return response.client;\n                    });\n                    setStatus(\"Ready\" /* Ready */ );\n                    statusRef.current = \"Ready\" /* Ready */ ;\n                    presenceLoadedRef.current = true;\n                    break;\n                }\n                collaboratorStore.patch(function(param) {\n                    var presences = param.presences;\n                    presences = presences.filter(function(p) {\n                        return p.clientId !== response.client.clientId;\n                    });\n                    presences.push(response.client);\n                    return presences;\n                });\n                break;\n            case \"client_remove\":\n                collaboratorStore.patch(function(param) {\n                    var presences = param.presences;\n                    presences = presences.filter(function(p) {\n                        return p.clientId !== response.clientId;\n                    });\n                    return presences;\n                });\n                break;\n            case \"client_replace_metadata\":\n                if (response.clientId === presenceClientIdRef.current) {\n                    presenceStore.patch(function(param) {\n                        var presence = param.presence;\n                        return _object_spread_props(_object_spread({}, presence), {\n                            metadata: response.metadata\n                        });\n                    });\n                    break;\n                }\n                collaboratorStore.patch(function(param) {\n                    var presences = param.presences;\n                    var index = presences.findIndex(function(p) {\n                        return p.clientId === response.clientId;\n                    });\n                    if (index < 0) {\n                        return presences;\n                    }\n                    presences[index] = _object_spread_props(_object_spread({}, presences[index]), {\n                        metadata: response.metadata\n                    });\n                    return presences;\n                });\n                break;\n            case \"client_replace_data\":\n            case \"client_update_data\":\n                if (response.clientId === presenceClientIdRef.current) {\n                    break;\n                }\n                collaboratorStore.patch(function(param) {\n                    var presences = param.presences;\n                    var index = presences.findIndex(function(p) {\n                        return p.clientId === response.clientId;\n                    });\n                    if (index < 0) {\n                        return presences;\n                    }\n                    presences[index] = _object_spread_props(_object_spread({}, presences[index]), {\n                        data: response.type === \"client_replace_data\" ? response.data : mergeData(presences[index].data, response.data),\n                        dataUpdatedAt: response.dataUpdatedAt\n                    });\n                    return presences;\n                });\n                break;\n        }\n    }, []);\n    (0, import_react4.useEffect)(function() {\n        if (status !== \"Ready\" /* Ready */ ) {\n            return;\n        }\n        preSyncMessagesRef.current.forEach(function(msg) {\n            return applyPresenceClientResponse(msg);\n        });\n        preSyncMessagesRef.current = [];\n    }, [\n        status\n    ]);\n    var onPresenceMessage = (0, import_react4.useCallback)(function(message) {\n        if ((statusRef.current === \"Syncing\" /* Syncing */  && !presenceClientIdRef.current || preSyncMessagesRef.current.length > 0) && message.type.startsWith(\"client_\")) {\n            preSyncMessagesRef.current.push(message);\n            return;\n        }\n        switch(message.type){\n            case \"sync\":\n                {\n                    var syncResponse = message;\n                    collaboratorStore.patch(function(param) {\n                        var ref = _object_destructuring_empty(param);\n                        return syncResponse.clients;\n                    });\n                    presenceClientIdRef.current = syncResponse.me.clientId;\n                }\n                break;\n            case \"client_add\":\n            case \"client_remove\":\n            case \"client_replace_metadata\":\n            case \"client_update_data\":\n            case \"client_replace_data\":\n                applyPresenceClientResponse(message);\n                break;\n            default:\n                console.warn(\"Presence message with type '\".concat(message.type, \"' unhandled.\"));\n                break;\n        }\n    }, [\n        applyPresenceClientResponse\n    ]);\n    var groupMessagesOnSend = (0, import_react4.useCallback)(function(messages) {\n        if (!messages) {\n            return [];\n        }\n        var newMessage = messages[0];\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = messages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var message = _step.value;\n                if (message.type === ReplaceMessageType) {\n                    newMessage.type = ReplaceMessageType;\n                    newMessage.data = message.data;\n                    continue;\n                }\n                newMessage.data = mergeData(newMessage.data, message.data);\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        return [\n            newMessage\n        ];\n    }, []);\n    var sendMessage = useChannel({\n        channel: \"presence\",\n        onMessage: onPresenceMessage,\n        throttle: throttle,\n        groupMessagesOnSend: groupMessagesOnSend\n    }).sendMessage;\n    var patchMe = (0, import_react4.useMemo)(function() {\n        return function(data, options) {\n            if (connectionStatusRef.current !== \"Open\" /* Open */ ) {\n                console.warn(\"Cannot patch presence data before connection is open.\");\n                return;\n            }\n            if (!presenceLoadedRef.current) {\n                console.warn(\"Cannot patch presence data before presence is ready.\");\n                return;\n            }\n            presenceStore.patch(function(param) {\n                var presence = param.presence;\n                var clonedData = clone(data);\n                return _object_spread_props(_object_spread({}, presence), {\n                    data: (options === null || options === void 0 ? void 0 : options.replace) ? clonedData : mergeData(presence.data, clonedData),\n                    dataUpdatedAt: /* @__PURE__ */ new Date().toISOString()\n                });\n            });\n            sendMessage({\n                messageId: uniqueId(),\n                type: (options === null || options === void 0 ? void 0 : options.replace) ? ReplaceMessageType : UpdateMessageType,\n                data: clone(data)\n            });\n        };\n    }, [\n        sendMessage\n    ]);\n    var reset = (0, import_react4.useCallback)(function() {\n        collaboratorStore.reset();\n        presenceStore.reset();\n        presenceClientIdRef.current = void 0;\n        preSyncMessagesRef.current = [];\n    }, []);\n    (0, import_react4.useEffect)(function() {\n        if (connectionStatus === \"Open\" /* Open */  && statusRef.current !== \"Unready\" /* Unready */ ) {\n            return;\n        }\n        if (connectionStatus !== \"Open\" /* Open */  && connectionStatus !== \"Authenticating\" /* Authenticating */ ) {\n            setStatus(\"Unready\" /* Unready */ );\n            statusRef.current = \"Unready\" /* Unready */ ;\n            reset();\n            return;\n        }\n        setStatus(\"Syncing\" /* Syncing */ );\n        statusRef.current = \"Syncing\" /* Syncing */ ;\n    }, [\n        connectionStatus\n    ]);\n    return {\n        status: status,\n        useCollaborators: collaboratorStore.useStore,\n        subscribeCollaborators: collaboratorStore.subscribe,\n        useMe: presenceStore.useStore,\n        patchMe: patchMe,\n        subscribeMe: presenceStore.subscribe\n    };\n};\n// src/createRealtimeContext.tsx\nvar import_react14 = __toESM(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\n// src/useRealtimeConnection.ts\nvar import_react9 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/channels/broadcast/useBroadcast.ts\nvar import_react5 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/channels/broadcast/createBroadcastStore.ts\nvar createBroadcastStore = function() {\n    var listeners = /* @__PURE__ */ new Set();\n    var registerEvent = function(event) {\n        listeners === null || listeners === void 0 ? void 0 : listeners.forEach(function(l) {\n            return l(event);\n        });\n    };\n    var subscribeToEvents = function(listener) {\n        listeners.add(listener);\n        return function() {\n            listeners === null || listeners === void 0 ? void 0 : listeners.delete(listener);\n        };\n    };\n    return {\n        registerEvent: registerEvent,\n        subscribeToEvents: subscribeToEvents\n    };\n};\n// src/channels/broadcast/useBroadcast.ts\nvar useBroadcastChannel = function(param) {\n    var connectionStatusRef = param.connectionStatusRef, useChannel = param.useChannel, throttle = param.throttle;\n    var broadcastStoreRef = (0, import_react5.useRef)(createBroadcastStore());\n    var sendMessage = useChannel({\n        channel: \"broadcast\",\n        onMessage: (0, import_react5.useCallback)(function(message) {\n            if (message.type === \"broadcast\") {\n                broadcastStoreRef.current.registerEvent(message.event);\n            }\n        }, []),\n        throttle: throttle\n    }).sendMessage;\n    var broadcast = (0, import_react5.useMemo)(function() {\n        return function(type, options) {\n            if (connectionStatusRef.current !== \"Open\" /* Open */ ) {\n                console.warn(\"Cannot send broadcast event when connection status is not open.\");\n                return;\n            }\n            var event = {\n                type: type\n            };\n            if ((options === null || options === void 0 ? void 0 : options.data) !== void 0) {\n                event.data = options.data;\n            }\n            if (options === null || options === void 0 ? void 0 : options.recipientClientIds) {\n                event.recipientClientIds = options.recipientClientIds;\n            }\n            sendMessage({\n                messageId: uniqueId(),\n                type: \"broadcast\",\n                event: event\n            });\n        };\n    }, [\n        sendMessage\n    ]);\n    var useBroadcastListener = (0, import_react5.useMemo)(function() {\n        return function(onEvent) {\n            var callback = (0, import_react5.useCallback)(function(event) {\n                return onEvent(event);\n            }, [\n                onEvent\n            ]);\n            (0, import_react5.useEffect)(function() {\n                return broadcastStoreRef.current.subscribeToEvents(callback);\n            }, [\n                callback\n            ]);\n        };\n    }, []);\n    return {\n        broadcast: broadcast,\n        useBroadcastListener: useBroadcastListener\n    };\n};\n// src/channels/system/useSystem.ts\nvar import_react6 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar useSystemChannel = function(param) {\n    var useChannel = param.useChannel;\n    var sendMessage = useChannel({\n        channel: \"system\",\n        onMessage: (0, import_react6.useCallback)(function(message) {\n            if (message.type === \"ping\") {\n                sendMessage({\n                    messageId: uniqueId(),\n                    type: \"pong\",\n                    ackMessageId: message.messageId\n                });\n            }\n        }, []),\n        throttle: 100\n    }).sendMessage;\n};\n// src/channels/document/autosave/indexeddb_autosave.ts\nvar dbNamePrefix = \"realtime_database\";\nvar fragmentsObjectStoreName = \"fragments\";\nvar documentsMetadataObjectStoreName = \"documents_metadata\";\nvar operationsObjectStoreName = \"operations\";\nvar documentIdInOperationsObjectStore = \"documentIdIndex\";\nvar dbVersion = 1;\nvar IndexedAutosave = /*#__PURE__*/ function() {\n    function IndexedAutosave(param) {\n        var storeNamePostfix = param.storeNamePostfix, disableWarning = param.disableWarning;\n        _class_call_check(this, IndexedAutosave);\n        this._connections = 0;\n        this._storeNamePostfix = storeNamePostfix;\n        this._disableWarning = disableWarning;\n    }\n    _create_class(IndexedAutosave, [\n        {\n            key: \"connect\",\n            value: function connect() {\n                var _this = this;\n                if (!window || !window.indexedDB) {\n                    console.warn(\"We're sorry to inform you that your current runtime environment does not support the Autosave feature, which is built upon IndexedDB.\", \"As a result, we have disabled the Autosave feature for your current runtime.\", \"However, we're more than happy to help and consider adding support for it if you could kindly send us a message with your use case and runtime environment at support@inrealtime.app.\");\n                    return Promise.resolve(false);\n                }\n                if (this._database) {\n                    this._connections++;\n                    return Promise.resolve(true);\n                }\n                if (!this._initPromise) {\n                    if (!this._disableWarning) {\n                        console.warn(\"Please note that the Realtime autosave feature is still in beta and not yet stable for production use. It currently relies on IndexedDB and is only supported by environments that support it. We're constantly working on improving this feature to ensure seamless and reliable functionality.\", \"We're exploring new ways to enhance the Realtime package interface, which would allow for selective syncing of messages, seeing the number of changes, applying changes, and more. Our current strategy is to store all changes and sync when connections are made.\", \"If you have any feedback or suggestions on how we can improve this feature or support more environments, please contact us at support@inrealtime.app. Our team is dedicated to providing you with the best possible experience using our software package.\");\n                    }\n                    this._initPromise = new Promise(function(resolve, reject) {\n                        var request = window.indexedDB.open(\"\".concat(dbNamePrefix, \"_\").concat(_this._storeNamePostfix), dbVersion);\n                        request.onerror = function(event) {\n                            console.error(\"Database error:\", event.target.error);\n                            resolve(false);\n                        };\n                        request.onsuccess = function(event) {\n                            var db = event.target.result;\n                            _this._database = db;\n                            resolve(true);\n                        };\n                        request.onupgradeneeded = function(event) {\n                            var db = event.target.result;\n                            db.createObjectStore(fragmentsObjectStoreName, {\n                                keyPath: \"id\"\n                            });\n                            db.createObjectStore(documentsMetadataObjectStoreName, {\n                                keyPath: \"id\"\n                            });\n                            var operationsObjectStore = db.createObjectStore(operationsObjectStoreName, {\n                                keyPath: \"id\",\n                                autoIncrement: true\n                            });\n                            operationsObjectStore.createIndex(documentIdInOperationsObjectStore, \"documentId\", {\n                                unique: false\n                            });\n                        };\n                    });\n                }\n                this._connections++;\n                return this._initPromise;\n            }\n        },\n        {\n            key: \"disconnect\",\n            value: function disconnect() {\n                if (!this._database) {\n                    return Promise.resolve(void 0);\n                }\n                this._connections--;\n                if (this._connections > 0) {\n                    return Promise.resolve(void 0);\n                }\n                this._database.close();\n                this._database = void 0;\n                this._connections = 0;\n                this._initPromise = void 0;\n                return Promise.resolve(void 0);\n            }\n        },\n        {\n            key: \"getDocumentMetadata\",\n            value: function getDocumentMetadata(param) {\n                var documentId = param.documentId;\n                var _this = this;\n                return _async_to_generator(function() {\n                    var transaction, objectStore, promise;\n                    return _ts_generator(this, function(_state) {\n                        if (!_this._database) {\n                            throw new Error(\"Database not initialized\");\n                        }\n                        transaction = _this._database.transaction(documentsMetadataObjectStoreName, \"readonly\");\n                        objectStore = transaction.objectStore(documentsMetadataObjectStoreName);\n                        promise = new Promise(function(resolve, reject) {\n                            var request = objectStore.get(documentId);\n                            request.onsuccess = function() {\n                                var _request_result;\n                                resolve((_request_result = request.result) === null || _request_result === void 0 ? void 0 : _request_result.data);\n                            };\n                            request.onerror = function() {\n                                reject(request.error);\n                            };\n                        });\n                        return [\n                            2,\n                            promise\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"saveDocumentMetadata\",\n            value: function saveDocumentMetadata(data) {\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(documentsMetadataObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(documentsMetadataObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var putRequest = objectStore.put({\n                        id: data.documentId,\n                        data: data.documentMetadata\n                    });\n                    putRequest.onsuccess = function() {\n                        resolve(void 0);\n                    };\n                    putRequest.onerror = function() {\n                        reject(putRequest.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"deleteDocumentMetadata\",\n            value: function deleteDocumentMetadata(param) {\n                var documentId = param.documentId;\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(documentsMetadataObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(documentsMetadataObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var deleteRequest = objectStore.delete(documentId);\n                    deleteRequest.onsuccess = function() {\n                        resolve(void 0);\n                    };\n                    deleteRequest.onerror = function() {\n                        reject(deleteRequest.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"getFragment\",\n            value: function getFragment(param) {\n                var documentId = param.documentId;\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(fragmentsObjectStoreName, \"readonly\");\n                var objectStore = transaction.objectStore(fragmentsObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var request = objectStore.get(documentId);\n                    request.onsuccess = function() {\n                        var _request_result;\n                        resolve((_request_result = request.result) === null || _request_result === void 0 ? void 0 : _request_result.data);\n                    };\n                    request.onerror = function() {\n                        reject(request.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"saveFragment\",\n            value: function saveFragment(data) {\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(fragmentsObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(fragmentsObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var putRequest = objectStore.put({\n                        id: data.documentId,\n                        data: data.fragment\n                    });\n                    putRequest.onsuccess = function() {\n                        resolve(void 0);\n                    };\n                    putRequest.onerror = function() {\n                        reject(putRequest.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"deleteFragment\",\n            value: function deleteFragment(param) {\n                var documentId = param.documentId;\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(fragmentsObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(fragmentsObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var deleteRequest = objectStore.delete(documentId);\n                    deleteRequest.onsuccess = function() {\n                        resolve(void 0);\n                    };\n                    deleteRequest.onerror = function() {\n                        reject(deleteRequest.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"getOperations\",\n            value: function getOperations(param) {\n                var documentId = param.documentId;\n                var _this = this;\n                return _async_to_generator(function() {\n                    var transaction, objectStore, index, request, operations;\n                    return _ts_generator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!_this._database) {\n                                    throw new Error(\"Database not initialized\");\n                                }\n                                transaction = _this._database.transaction(operationsObjectStoreName, \"readonly\");\n                                objectStore = transaction.objectStore(operationsObjectStoreName);\n                                index = objectStore.index(documentIdInOperationsObjectStore);\n                                request = index.getAll(documentId);\n                                return [\n                                    4,\n                                    new Promise(function(resolve, reject) {\n                                        request.onsuccess = function() {\n                                            resolve(request.result);\n                                        };\n                                        request.onerror = function() {\n                                            reject(request.error);\n                                        };\n                                    })\n                                ];\n                            case 1:\n                                operations = _state.sent();\n                                if (!operations) {\n                                    return [\n                                        2,\n                                        void 0\n                                    ];\n                                }\n                                operations.sort(function(a, b) {\n                                    return a.id - b.id;\n                                });\n                                return [\n                                    2,\n                                    operations.map(function(operation) {\n                                        var messageWithId = operation.message;\n                                        messageWithId.id = operation.id;\n                                        return messageWithId;\n                                    })\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"saveOperation\",\n            value: function saveOperation(data) {\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(operationsObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(operationsObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var putRequest = objectStore.put(data);\n                    putRequest.onsuccess = function() {\n                        ;\n                        data.message.id = putRequest.result;\n                        resolve(data.message);\n                    };\n                    putRequest.onerror = function() {\n                        reject(putRequest.error);\n                    };\n                });\n                return promise;\n            }\n        },\n        {\n            key: \"removeOperation\",\n            value: function removeOperation(id) {\n                if (!this._database) {\n                    throw new Error(\"Database not initialized\");\n                }\n                var transaction = this._database.transaction(operationsObjectStoreName, \"readwrite\");\n                var objectStore = transaction.objectStore(operationsObjectStoreName);\n                var promise = new Promise(function(resolve, reject) {\n                    var deleteRequest = objectStore.delete(id);\n                    deleteRequest.onsuccess = function() {\n                        resolve(void 0);\n                    };\n                    deleteRequest.onerror = function() {\n                        reject(deleteRequest.error);\n                    };\n                });\n                return promise;\n            }\n        }\n    ]);\n    return IndexedAutosave;\n}();\n// src/config.ts\nvar allowedEnvironments = [\n    \"local\",\n    \"development\",\n    \"production\"\n];\nvar webSocketUrls = {\n    local: \"ws://127.0.0.1:8787\",\n    development: \"wss://worker.inrealtime.love\",\n    production: \"wss://worker.inrealtime.app\"\n};\nvar authUrls = {\n    local: \"http://127.0.0.1:8787/auth\",\n    development: \"https://worker.inrealtime.love/auth\",\n    production: \"https://worker.inrealtime.app/auth\"\n};\nvar getRealtimeConfig = function(param) {\n    var environment = param.environment, logging = param.logging, autosave = param.autosave;\n    if (!environment || !allowedEnvironments.includes(environment)) {\n        environment = \"production\";\n    }\n    var authUrl = authUrls[environment];\n    var webSocketUrl = webSocketUrls[environment];\n    var _logging_conflicts, _logging_socketStatus, _logging_listFragmentIndexes, _logging_localOperations, _logging_remoteOperations;\n    return {\n        environment: environment,\n        authUrl: authUrl,\n        webSocketUrl: webSocketUrl,\n        logging: {\n            conflicts: (_logging_conflicts = logging === null || logging === void 0 ? void 0 : logging.conflicts) !== null && _logging_conflicts !== void 0 ? _logging_conflicts : false,\n            socketStatus: (_logging_socketStatus = logging === null || logging === void 0 ? void 0 : logging.socketStatus) !== null && _logging_socketStatus !== void 0 ? _logging_socketStatus : false,\n            listFragmentIndexes: (_logging_listFragmentIndexes = logging === null || logging === void 0 ? void 0 : logging.listFragmentIndexes) !== null && _logging_listFragmentIndexes !== void 0 ? _logging_listFragmentIndexes : false,\n            localOperations: (_logging_localOperations = logging === null || logging === void 0 ? void 0 : logging.localOperations) !== null && _logging_localOperations !== void 0 ? _logging_localOperations : false,\n            remoteOperations: (_logging_remoteOperations = logging === null || logging === void 0 ? void 0 : logging.remoteOperations) !== null && _logging_remoteOperations !== void 0 ? _logging_remoteOperations : false\n        },\n        autosave: getAutosaveConfig(autosave)\n    };\n};\nvar getAutosaveConfig = function(autosave) {\n    var autosaveObj = {\n        enabled: false,\n        storeNamePostfix: \"default\",\n        disableWarning: false\n    };\n    if (autosave && isMap(autosave)) {\n        var verboseAutosave = autosave;\n        var _verboseAutosave_storeNamePostfix;\n        autosaveObj = {\n            enabled: verboseAutosave.enabled === void 0 || verboseAutosave.enabled,\n            // Default if autosave={} then it is enabled\n            storeNamePostfix: (_verboseAutosave_storeNamePostfix = verboseAutosave.storeNamePostfix) !== null && _verboseAutosave_storeNamePostfix !== void 0 ? _verboseAutosave_storeNamePostfix : autosaveObj.storeNamePostfix,\n            disableWarning: !!(verboseAutosave === null || verboseAutosave === void 0 ? void 0 : verboseAutosave.disableWarning)\n        };\n    } else if (autosave) {\n        autosaveObj.enabled = true;\n    }\n    return autosaveObj;\n};\nvar indexedAutosaveMap = {};\nvar getIndexedAutosaveInstance = function(param) {\n    var storeNamePostfix = param.storeNamePostfix, disableWarning = param.disableWarning;\n    if (!indexedAutosaveMap[storeNamePostfix]) {\n        indexedAutosaveMap[storeNamePostfix] = new IndexedAutosave({\n            storeNamePostfix: storeNamePostfix,\n            disableWarning: disableWarning\n        });\n    }\n    return indexedAutosaveMap[storeNamePostfix];\n};\n// src/socket/useWebSocket.ts\nvar import_react8 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/socket/createMessageStore.ts\nvar createMessageStore = function() {\n    var listenersToChannel = {};\n    var registerMessage = function(channel, message) {\n        var listeners = listenersToChannel[channel];\n        listeners === null || listeners === void 0 ? void 0 : listeners.forEach(function(l) {\n            return l(message);\n        });\n    };\n    var subscribeToChannel = function(channel, listener) {\n        var listeners = listenersToChannel[channel];\n        if (!listeners) {\n            listeners = /* @__PURE__ */ new Set();\n            listenersToChannel[channel] = listeners;\n        }\n        listeners.add(listener);\n        return function() {\n            listeners === null || listeners === void 0 ? void 0 : listeners.delete(listener);\n        };\n    };\n    return {\n        registerMessage: registerMessage,\n        subscribeToChannel: subscribeToChannel\n    };\n};\n// src/socket/useMessages.ts\nvar import_react7 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar useMessages = function(store, channel, onMessage) {\n    var callback = (0, import_react7.useCallback)(function(message) {\n        return onMessage(message);\n    }, [\n        onMessage\n    ]);\n    (0, import_react7.useEffect)(function() {\n        return store.subscribeToChannel(channel, callback);\n    }, [\n        store,\n        channel,\n        callback\n    ]);\n    return {};\n};\n// src/socket/useWebSocket.ts\nvar useWebSocket = function(param) {\n    var socketUrl = param.socketUrl, token = param.token, config = param.config;\n    var _ref = _sliced_to_array((0, import_react8.useState)(\"Closed\" /* Closed */ ), 2), socketStatus = _ref[0], setSocketStatus = _ref[1];\n    var socketStatusRef = (0, import_react8.useRef)(socketStatus);\n    var _ref1 = _sliced_to_array((0, import_react8.useState)(), 2), lastToken = _ref1[0], setLastToken = _ref1[1];\n    var messageStoreRef = (0, import_react8.useRef)(createMessageStore());\n    var authChannelPrefix = \"auth\";\n    var realtimeWebSocketRef = (0, import_react8.useRef)();\n    var _ref2 = _sliced_to_array((0, import_react8.useState)(0), 2), reconnectCounter = _ref2[0], setReconnectCounter = _ref2[1];\n    var useChannel = (0, import_react8.useMemo)(function() {\n        return function(param) {\n            var channel = param.channel, onMessage = param.onMessage, throttle = param.throttle, groupMessagesOnSend = param.groupMessagesOnSend;\n            return useRawChannel({\n                realtimeWebSocketRef: realtimeWebSocketRef,\n                messageStoreRef: messageStoreRef,\n                channel: channel,\n                onMessage: onMessage,\n                throttle: throttle,\n                groupMessagesOnSend: groupMessagesOnSend\n            });\n        };\n    }, []);\n    var newRealtimeWebSocket = (0, import_react8.useCallback)(function() {\n        var realtimeWebSocket = new RealtimeWebSocket({\n            onOpen: function() {\n                if (realtimeWebSocketRef.current !== realtimeWebSocket) {\n                    return;\n                }\n                if (config.logging.socketStatus) console.log(\"Socket status -> Authenticating\");\n                setSocketStatus(\"Authenticating\" /* Authenticating */ );\n                socketStatusRef.current = \"Authenticating\" /* Authenticating */ ;\n            },\n            onConnecting: function() {\n                if (realtimeWebSocketRef.current !== realtimeWebSocket) {\n                    return;\n                }\n                if (config.logging.socketStatus) console.log(\"Socket status -> Connecting\");\n                setSocketStatus(\"Connecting\" /* Connecting */ );\n                socketStatusRef.current = \"Connecting\" /* Connecting */ ;\n            },\n            onClose: function() {\n                if (realtimeWebSocketRef.current !== realtimeWebSocket) {\n                    return;\n                }\n                if (config.logging.socketStatus) console.log(\"Socket status -> Closed\");\n                setSocketStatus(\"Closed\" /* Closed */ );\n                socketStatusRef.current = \"Closed\" /* Closed */ ;\n                setLastToken(void 0);\n            },\n            onMessage: function(channel, message) {\n                if (realtimeWebSocketRef.current !== realtimeWebSocket) {\n                    return;\n                }\n                messageStoreRef.current.registerMessage(channel, message);\n            },\n            config: config\n        });\n        return realtimeWebSocket;\n    }, []);\n    (0, import_react8.useEffect)(function() {\n        if (socketStatus !== \"Closed\" /* Closed */ ) {\n            return;\n        }\n        var interval = setInterval(function() {\n            setReconnectCounter(reconnectCounter + 1);\n        }, 500);\n        return function() {\n            return clearInterval(interval);\n        };\n    }, [\n        socketStatus,\n        reconnectCounter\n    ]);\n    (0, import_react8.useEffect)(function() {\n        if (!socketUrl) {\n            return;\n        }\n        var realtimeWebSocket = newRealtimeWebSocket();\n        realtimeWebSocketRef.current = realtimeWebSocket;\n        realtimeWebSocket.setSocketUrl({\n            socketUrl: socketUrl\n        });\n        realtimeWebSocket.connect();\n        return function() {\n            if (config.logging.socketStatus) console.log(\"Closing due to change in socketUrl, reconnect or hot-reload\");\n            realtimeWebSocket.close();\n        };\n    }, [\n        socketUrl,\n        reconnectCounter\n    ]);\n    var _useChannel = useChannel({\n        channel: authChannelPrefix,\n        onMessage: (0, import_react8.useCallback)(function(message) {\n            if (message.type !== \"token\" || socketStatus !== \"Authenticating\" /* Authenticating */ ) {\n                return;\n            }\n            if (config.logging.socketStatus) console.log(\"Socket status -> Open\");\n            setSocketStatus(\"Open\" /* Open */ );\n            socketStatusRef.current = \"Open\" /* Open */ ;\n        }, [\n            socketStatus,\n            token\n        ]),\n        throttle: 0\n    }), sendAuthMessage = _useChannel.sendMessage;\n    (0, import_react8.useEffect)(function() {\n        if (socketStatus !== \"Authenticating\" /* Authenticating */ ) {\n            return;\n        }\n        setLastToken(token);\n        sendAuthMessage({\n            type: \"token\",\n            messageId: uniqueId(),\n            token: token\n        });\n    }, [\n        sendAuthMessage,\n        socketStatus,\n        token\n    ]);\n    (0, import_react8.useEffect)(function() {\n        if (socketStatus !== \"Open\" /* Open */  || lastToken === token || !token) {\n            return;\n        }\n        setLastToken(token);\n        sendAuthMessage({\n            type: \"token\",\n            messageId: uniqueId(),\n            token: token\n        });\n    }, [\n        sendAuthMessage,\n        socketStatus,\n        token,\n        lastToken\n    ]);\n    return {\n        status: socketStatus,\n        statusRef: socketStatusRef,\n        useChannel: useChannel\n    };\n};\nvar useRawChannel = function(param) {\n    var realtimeWebSocketRef = param.realtimeWebSocketRef, messageStoreRef = param.messageStoreRef, channel = param.channel, onMessage = param.onMessage, throttle = param.throttle, groupMessagesOnSend = param.groupMessagesOnSend;\n    var messageQueueRef = (0, import_react8.useRef)([]);\n    var sendMessagesInterval = (0, import_react8.useRef)();\n    useMessages(messageStoreRef.current, channel, (0, import_react8.useCallback)(function(message) {\n        onMessage(message);\n    }, [\n        onMessage\n    ]));\n    (0, import_react8.useEffect)(function() {\n        sendMessagesInterval.current = setInterval(function() {\n            if (messageQueueRef.current.length === 0) {\n                return;\n            }\n            var messages = groupMessagesOnSend ? groupMessagesOnSend(messageQueueRef.current) : messageQueueRef.current;\n            if (!messages) {\n                return;\n            }\n            messageQueueRef.current = [];\n            messages.forEach(function(message) {\n                var _realtimeWebSocketRef_current;\n                return (_realtimeWebSocketRef_current = realtimeWebSocketRef.current) === null || _realtimeWebSocketRef_current === void 0 ? void 0 : _realtimeWebSocketRef_current.sendMessage(channel, message);\n            });\n        }, throttle);\n        return function() {\n            return clearInterval(sendMessagesInterval.current);\n        };\n    }, [\n        throttle,\n        channel,\n        groupMessagesOnSend\n    ]);\n    var sendMessageCallback = (0, import_react8.useCallback)(function(message) {\n        messageQueueRef.current.push(message);\n    }, []);\n    return {\n        sendMessage: sendMessageCallback\n    };\n};\n// src/throttle.ts\nvar DefaultThrottle = 50;\nvar MinThrottle = 15;\nvar MaxThrottle = 2e3;\nvar getThrottle = function(throttle) {\n    if (throttle === void 0) {\n        return DefaultThrottle;\n    }\n    if (throttle < MinThrottle || throttle > MaxThrottle) {\n        console.warn(\"Throttle must be between '\".concat(MinThrottle, \"' and '\").concat(MaxThrottle, \"'. Defaulted to '\").concat(DefaultThrottle, \"'\"));\n        return DefaultThrottle;\n    }\n    return throttle;\n};\n// src/useRealtimeConnection.ts\nvar useRealtimeConnection = function(param) {\n    var documentId = param.documentId, groupId = param.groupId, getAuthToken = param.getAuthToken, publicAuthKey = param.publicAuthKey, throttleOption = param.throttle, autosave = param.autosave, _package = param._package;\n    var config = (0, import_react9.useMemo)(function() {\n        return getRealtimeConfig({\n            environment: _package === null || _package === void 0 ? void 0 : _package.environment,\n            logging: _package === null || _package === void 0 ? void 0 : _package.logging,\n            autosave: autosave\n        });\n    }, []);\n    var throttle = (0, import_react9.useMemo)(function() {\n        return getThrottle(throttleOption);\n    }, [\n        throttleOption\n    ]);\n    var _useAuth = useAuth({\n        config: config,\n        documentId: documentId,\n        groupId: groupId,\n        getAuthToken: getAuthToken,\n        publicAuthKey: publicAuthKey\n    }), token = _useAuth.token, socketUrl = _useAuth.socketUrl;\n    var _useWebSocket = useWebSocket({\n        socketUrl: socketUrl,\n        token: token,\n        config: config\n    }), connectionStatus = _useWebSocket.status, connectionStatusRef = _useWebSocket.statusRef, useChannel = _useWebSocket.useChannel;\n    useSystemChannel({\n        useChannel: useChannel\n    });\n    var _usePresenceChannel = usePresenceChannel({\n        connectionStatus: connectionStatus,\n        connectionStatusRef: connectionStatusRef,\n        useChannel: useChannel,\n        throttle: throttle\n    }), presenceStatus = _usePresenceChannel.status, useCollaborators = _usePresenceChannel.useCollaborators, subscribeCollaborators = _usePresenceChannel.subscribeCollaborators, useMe = _usePresenceChannel.useMe, patchMe = _usePresenceChannel.patchMe, subscribeMe = _usePresenceChannel.subscribeMe;\n    var _useBroadcastChannel = useBroadcastChannel({\n        connectionStatusRef: connectionStatusRef,\n        useChannel: useChannel,\n        throttle: throttle\n    }), broadcast = _useBroadcastChannel.broadcast, useBroadcastListener = _useBroadcastChannel.useBroadcastListener;\n    return {\n        connectionStatus: connectionStatus,\n        connectionStatusRef: connectionStatusRef,\n        presenceStatus: presenceStatus,\n        useCollaborators: useCollaborators,\n        subscribeCollaborators: subscribeCollaborators,\n        useMe: useMe,\n        patchMe: patchMe,\n        subscribeMe: subscribeMe,\n        broadcast: broadcast,\n        useBroadcastListener: useBroadcastListener,\n        config: config,\n        useChannel: useChannel\n    };\n};\n// src/useRealtimeDocument.ts\nvar import_react13 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/channels/document/useDocument.ts\nvar import_react12 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n// src/channels/document/autosave/useDocumentAutosave.ts\nvar import_react10 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar useDocumentAutosave = function(param) {\n    var config = param.config, documentId = param.documentId, subscriptionIdRef = param.subscriptionIdRef, localStore = param.localStore, onLocalData = param.onLocalData, onNoLocalData = param.onNoLocalData;\n    var autosaveDatabaseRef = (0, import_react10.useRef)();\n    var unsavedChangesRef = (0, import_react10.useRef)(false);\n    var localChangesRef = (0, import_react10.useRef)([]);\n    var unremovedLocalChangesRef = (0, import_react10.useRef)([]);\n    var unsavedLocalChangesRef = (0, import_react10.useRef)([]);\n    var documentMetadataRef = (0, import_react10.useRef)();\n    var markForLocalSaving = (0, import_react10.useCallback)(function() {\n        unsavedChangesRef.current = true;\n    }, []);\n    var saveLocalChanges = (0, import_react10.useCallback)(function(request) {\n        if (!autosaveDatabaseRef.current) {\n            return;\n        }\n        if (documentMetadataRef.current.localOnly) {\n            markForLocalSaving();\n            return;\n        }\n        unsavedLocalChangesRef.current.push(request);\n        markForLocalSaving();\n    }, []);\n    (0, import_react10.useEffect)(function() {\n        if (!documentId || !config.autosave.enabled) {\n            localChangesRef.current = [];\n            return;\n        }\n        var autosaveDatabase = getIndexedAutosaveInstance({\n            storeNamePostfix: config.autosave.storeNamePostfix,\n            disableWarning: config.autosave.disableWarning\n        });\n        var loadDocument = function() {\n            var _ref = _async_to_generator(function() {\n                var enabled, documentMetadataPromise, fragmentPromise, localChangesPromise, documentMetadata, fragment, localChanges;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                autosaveDatabase.connect()\n                            ];\n                        case 1:\n                            enabled = _state.sent();\n                            if (!enabled) {\n                                return [\n                                    2\n                                ];\n                            }\n                            autosaveDatabaseRef.current = autosaveDatabase;\n                            documentMetadataPromise = autosaveDatabase.getDocumentMetadata({\n                                documentId: documentId\n                            });\n                            fragmentPromise = autosaveDatabase.getFragment({\n                                documentId: documentId\n                            });\n                            localChangesPromise = autosaveDatabase.getOperations({\n                                documentId: documentId\n                            });\n                            return [\n                                4,\n                                documentMetadataPromise\n                            ];\n                        case 2:\n                            documentMetadata = _state.sent();\n                            return [\n                                4,\n                                fragmentPromise\n                            ];\n                        case 3:\n                            fragment = _state.sent();\n                            return [\n                                4,\n                                localChangesPromise\n                            ];\n                        case 4:\n                            localChanges = _state.sent();\n                            if (documentMetadata && fragment && localChanges) {\n                                onLocalData(fragment);\n                                documentMetadataRef.current = documentMetadata;\n                                localChangesRef.current = localChanges;\n                            } else {\n                                onNoLocalData();\n                                documentMetadataRef.current = {\n                                    localOnly: false,\n                                    unsavedChanges: false\n                                };\n                                localChangesRef.current = [];\n                            }\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function loadDocument() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        loadDocument().catch(function(error) {\n            console.error(error);\n        });\n        return function() {\n            autosaveDatabase.disconnect().catch(function(error) {\n                console.error(error);\n            });\n        };\n    }, [\n        documentId\n    ]);\n    (0, import_react10.useEffect)(function() {\n        if (!config.autosave.enabled || !documentId) {\n            return;\n        }\n        var timer = setInterval(/*#__PURE__*/ _async_to_generator(function() {\n            var autosaveDatabase, changesToSave, changesToRemove, documentMetadataToSave, fragmentToSave, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, request, _, _1, error, err, promises, _iteratorNormalCompletion1, _didIteratorError1, _iteratorError1, _iterator1, _step1, request1, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, promise, error1, err;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        if (!unsavedChangesRef.current) {\n                            return [\n                                2\n                            ];\n                        }\n                        autosaveDatabase = autosaveDatabaseRef.current;\n                        if (!autosaveDatabase) {\n                            return [\n                                2\n                            ];\n                        }\n                        changesToSave = unsavedLocalChangesRef.current;\n                        changesToRemove = unremovedLocalChangesRef.current;\n                        documentMetadataToSave = documentMetadataRef.current;\n                        fragmentToSave = localStore.getRoot().fragment;\n                        unremovedLocalChangesRef.current = [];\n                        unsavedLocalChangesRef.current = [];\n                        localChangesRef.current = localChangesRef.current.filter(function(request) {\n                            return !changesToRemove.includes(request);\n                        });\n                        unsavedChangesRef.current = false;\n                        return [\n                            4,\n                            autosaveDatabase.saveDocumentMetadata({\n                                documentId: documentId,\n                                documentMetadata: documentMetadataToSave\n                            })\n                        ];\n                    case 1:\n                        _state.sent();\n                        return [\n                            4,\n                            autosaveDatabase.saveFragment({\n                                documentId: documentId,\n                                fragment: fragmentToSave\n                            })\n                        ];\n                    case 2:\n                        _state.sent();\n                        _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                        _state.label = 3;\n                    case 3:\n                        _state.trys.push([\n                            3,\n                            10,\n                            11,\n                            12\n                        ]);\n                        _iterator = changesToSave[Symbol.iterator]();\n                        _state.label = 4;\n                    case 4:\n                        if (!!(_iteratorNormalCompletion = (_step = _iterator.next()).done)) return [\n                            3,\n                            9\n                        ];\n                        request = _step.value;\n                        _state.label = 5;\n                    case 5:\n                        _state.trys.push([\n                            5,\n                            7,\n                            ,\n                            8\n                        ]);\n                        _1 = (_ = localChangesRef.current).push;\n                        return [\n                            4,\n                            autosaveDatabase.saveOperation({\n                                documentId: documentId,\n                                message: request\n                            })\n                        ];\n                    case 6:\n                        _1.apply(_, [\n                            _state.sent()\n                        ]);\n                        return [\n                            3,\n                            8\n                        ];\n                    case 7:\n                        error = _state.sent();\n                        console.error(error);\n                        return [\n                            3,\n                            8\n                        ];\n                    case 8:\n                        _iteratorNormalCompletion = true;\n                        return [\n                            3,\n                            4\n                        ];\n                    case 9:\n                        return [\n                            3,\n                            12\n                        ];\n                    case 10:\n                        err = _state.sent();\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                        return [\n                            7\n                        ];\n                    case 12:\n                        promises = [];\n                        _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n                        try {\n                            for(_iterator1 = changesToRemove[Symbol.iterator](); !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                                request1 = _step1.value;\n                                promises.push(autosaveDatabase.removeOperation(request1.id));\n                            }\n                        } catch (err) {\n                            _didIteratorError1 = true;\n                            _iteratorError1 = err;\n                        } finally{\n                            try {\n                                if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                                    _iterator1.return();\n                                }\n                            } finally{\n                                if (_didIteratorError1) {\n                                    throw _iteratorError1;\n                                }\n                            }\n                        }\n                        _iteratorNormalCompletion2 = true, _didIteratorError2 = false, _iteratorError2 = undefined;\n                        _state.label = 13;\n                    case 13:\n                        _state.trys.push([\n                            13,\n                            20,\n                            21,\n                            22\n                        ]);\n                        _iterator2 = promises[Symbol.iterator]();\n                        _state.label = 14;\n                    case 14:\n                        if (!!(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done)) return [\n                            3,\n                            19\n                        ];\n                        promise = _step2.value;\n                        _state.label = 15;\n                    case 15:\n                        _state.trys.push([\n                            15,\n                            17,\n                            ,\n                            18\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 16:\n                        _state.sent();\n                        return [\n                            3,\n                            18\n                        ];\n                    case 17:\n                        error1 = _state.sent();\n                        console.error(error1);\n                        return [\n                            3,\n                            18\n                        ];\n                    case 18:\n                        _iteratorNormalCompletion2 = true;\n                        return [\n                            3,\n                            14\n                        ];\n                    case 19:\n                        return [\n                            3,\n                            22\n                        ];\n                    case 20:\n                        err = _state.sent();\n                        _didIteratorError2 = true;\n                        _iteratorError2 = err;\n                        return [\n                            3,\n                            22\n                        ];\n                    case 21:\n                        try {\n                            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                                _iterator2.return();\n                            }\n                        } finally{\n                            if (_didIteratorError2) {\n                                throw _iteratorError2;\n                            }\n                        }\n                        return [\n                            7\n                        ];\n                    case 22:\n                        return [\n                            2\n                        ];\n                }\n            });\n        }), 500);\n        return function() {\n            clearInterval(timer);\n        };\n    }, [\n        documentId\n    ]);\n    var getLocalChangesToSync = (0, import_react10.useCallback)(function() {\n        if (!autosaveDatabaseRef.current) {\n            return [];\n        }\n        if (documentMetadataRef.current.localOnly) {\n            var setRootRequest = {\n                messageId: uniqueId(),\n                type: OpsMessageType,\n                subId: subscriptionIdRef.current,\n                operations: [\n                    {\n                        op: DocumentOperationRoot,\n                        value: localStore.getRoot().fragment\n                    }\n                ]\n            };\n            unsavedLocalChangesRef.current = [\n                setRootRequest\n            ];\n            documentMetadataRef.current = {\n                localOnly: false,\n                unsavedChanges: true\n            };\n            markForLocalSaving();\n            return [\n                setRootRequest\n            ];\n        }\n        var localChanges = _to_consumable_array(localChangesRef.current).concat(_to_consumable_array(unsavedLocalChangesRef.current));\n        localChanges = localChanges.filter(function(request) {\n            return !unremovedLocalChangesRef.current.find(function(r) {\n                return r.messageId === request.messageId;\n            });\n        });\n        return localChanges;\n    }, []);\n    var updateLocalChanges = (0, import_react10.useCallback)(function(param) {\n        var removedChanges = param.removedChanges, addedChanges = param.addedChanges;\n        var _unremovedLocalChangesRef_current, _unsavedLocalChangesRef_current;\n        if (!autosaveDatabaseRef.current) {\n            return;\n        }\n        unsavedLocalChangesRef.current = unsavedLocalChangesRef.current.filter(function(opMessage) {\n            return !removedChanges.includes(opMessage);\n        });\n        var localChangesToRemove = localChangesRef.current.filter(function(opMessage) {\n            return removedChanges.includes(opMessage);\n        });\n        (_unremovedLocalChangesRef_current = unremovedLocalChangesRef.current).push.apply(_unremovedLocalChangesRef_current, _to_consumable_array(localChangesToRemove));\n        (_unsavedLocalChangesRef_current = unsavedLocalChangesRef.current).push.apply(_unsavedLocalChangesRef_current, _to_consumable_array(addedChanges));\n        markForLocalSaving();\n    }, []);\n    var acknowledgeLocalChange = (0, import_react10.useCallback)(function(ackMessageId) {\n        if (!autosaveDatabaseRef.current) {\n            return;\n        }\n        var unsavedLocalChangeIndex = unsavedLocalChangesRef.current.findIndex(function(r) {\n            return r.messageId === ackMessageId;\n        });\n        if (unsavedLocalChangeIndex >= 0) {\n            unsavedLocalChangesRef.current.splice(unsavedLocalChangeIndex, 1);\n        } else {\n            var localChange = localChangesRef.current.find(function(r) {\n                return r.messageId === ackMessageId;\n            });\n            if (localChange) {\n                unremovedLocalChangesRef.current.push(localChange);\n            } else {\n                console.warn(\"Couldn't find local change for acked operation\");\n            }\n        }\n        markForLocalSaving();\n    }, []);\n    return {\n        saveLocalChanges: saveLocalChanges,\n        markForLocalSaving: markForLocalSaving,\n        getLocalChangesToSync: getLocalChangesToSync,\n        updateLocalChanges: updateLocalChanges,\n        acknowledgeLocalChange: acknowledgeLocalChange\n    };\n};\n// src/channels/document/store/tests/storeEqual.ts\nvar getFormattedObj = function(d) {\n    if (isList(d)) {\n        return d.map(function(d1) {\n            return getFormattedObj(d1);\n        });\n    }\n    var newObject = {};\n    Object.keys(d).sort().forEach(function(key, i) {\n        if (d[key] === void 0 || d[key] === null) {\n            return;\n        }\n        if (isList(d[key]) || isMap(d[key])) {\n            newObject[key] = getFormattedObj(d[key]);\n            return;\n        }\n        newObject[key] = d[key];\n    });\n    return newObject;\n};\nvar areStoresEqual = function(d1, d2) {\n    return {\n        documentsEqual: JSON.stringify(getFormattedObj(d1.document)) === JSON.stringify(getFormattedObj(d2.document)),\n        fragmentsEqual: JSON.stringify(getFormattedObj(d1.fragment)) === JSON.stringify(getFormattedObj(d2.fragment)),\n        fragmentIdToPathsEqual: JSON.stringify(getFormattedObj(d1.fragmentIdToPath)) === JSON.stringify(getFormattedObj(d2.fragmentIdToPath))\n    };\n};\n// src/channels/document/store/useRealtimeStore.ts\nvar import_immer3 = __webpack_require__(/*! immer */ \"../../node_modules/immer/dist/cjs/index.js\");\nvar import_react11 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar import_zustand3 = __webpack_require__(/*! zustand */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js\");\nvar import_middleware3 = __webpack_require__(/*! zustand/middleware */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js\");\n// src/channels/document/store/utils/conflictOperationUtils.ts\nvar import_immer = __webpack_require__(/*! immer */ \"../../node_modules/immer/dist/cjs/index.js\");\n// src/channels/document/store/utils/pathUtils.ts\nvar createFragmentIdToPath = function(param) {\n    var fragment = param.fragment;\n    return addFragmentIdToPath({\n        fragment: fragment,\n        fragmentIdToPath: {}\n    });\n};\nvar addFragmentIdToPath = function(param) {\n    var fragment = param.fragment, fragmentIdToPath = param.fragmentIdToPath, path = param.path;\n    var queue = [\n        {\n            fragment: fragment,\n            path: path !== null && path !== void 0 ? path : []\n        }\n    ];\n    while(queue.length > 0){\n        var item = queue.shift();\n        fragmentIdToPath[item.fragment.id] = item.path;\n        if (item.fragment.type == 2 /* Map */  || item.fragment.type == 1 /* List */ ) {\n            var map = item.fragment.value;\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = Object.keys(map)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var subKey = _step.value;\n                    var subPath = _to_consumable_array(item.path).concat([\n                        subKey\n                    ]);\n                    var mapItem = map[subKey];\n                    queue.push({\n                        fragment: mapItem,\n                        path: subPath\n                    });\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }\n    return fragmentIdToPath;\n};\nvar removeFragmentIdToPath = function(param) {\n    var fragment = param.fragment, fragmentIdToPath = param.fragmentIdToPath;\n    var queue = [\n        fragment\n    ];\n    while(queue.length > 0){\n        var item = queue.shift();\n        delete fragmentIdToPath[item.id];\n        if (item.type == 2 /* Map */  || item.type == 1 /* List */ ) {\n            var map = item.value;\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = Object.keys(map)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var subKey = _step.value;\n                    var mapItem = map[subKey];\n                    queue.push(mapItem);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n    }\n    return fragmentIdToPath;\n};\n// src/channels/document/store/utils/immutableFragment.ts\nvar createImmutableFragment = function(fragment, fragmentIdToPath, config) {\n    return new ImmutableFragment(fragment, fragmentIdToPath, config);\n};\nvar ImmutableFragment = /*#__PURE__*/ function() {\n    function ImmutableFragment(fragment, fragmentIdToPath, config) {\n        var _this = this;\n        _class_call_check(this, ImmutableFragment);\n        /**\n     * Get an immutable sub fragments list based on an immer path\n     * Only make items which are within index [itemImmutabilityFromIndex, itemImmutabilityToIndex]\n     */ this._getListFragments = function(param) {\n            var listFragment = param.listFragment, listImmutablePath = param.listImmutablePath, itemImmutabilityFromIndex = param.itemImmutabilityFromIndex, itemImmutabilityToIndex = param.itemImmutabilityToIndex;\n            return Object.values(listFragment.value).map(function(f) {\n                var subImmutablePath = _this._combineImmutablePaths(listImmutablePath, f.id);\n                if (!_this._isPathImmutable(subImmutablePath) && f.parentListIndex >= itemImmutabilityFromIndex && f.parentListIndex <= itemImmutabilityToIndex) {\n                    _this._addImmutablePath(subImmutablePath);\n                    f = _object_spread({}, f);\n                    if (f.value) {\n                        ;\n                        f.value = _object_spread({}, f.value);\n                    }\n                    listFragment.value[f.id] = f;\n                }\n                return f;\n            });\n        };\n        this._fragment = fragment;\n        this._fragmentIdToPath = fragmentIdToPath;\n        this._immutablePaths = {};\n        this._config = config;\n    }\n    _create_class(ImmutableFragment, [\n        {\n            key: \"getFragment\",\n            value: function getFragment() {\n                return this._fragment;\n            }\n        },\n        {\n            key: \"getFragmentIdToPath\",\n            value: function getFragmentIdToPath() {\n                return this._fragmentIdToPath;\n            }\n        },\n        {\n            /**\n   * Generate a string from a path\n   */ key: \"_createImmutablePath\",\n            value: function _createImmutablePath(path) {\n                return path.map(function(p) {\n                    return \"\".concat(p).replace(/\\./g, \"\\\\.\");\n                }).join(\".\");\n            }\n        },\n        {\n            /**\n   * Combine two immutable paths\n   */ key: \"_combineImmutablePaths\",\n            value: function _combineImmutablePaths(path1, path2) {\n                return \"\".concat(path1, \".\").concat(path2);\n            }\n        },\n        {\n            /**\n   * Check if path has been made immutable\n   */ key: \"_isPathImmutable\",\n            value: function _isPathImmutable(path) {\n                return !!this._immutablePaths[path];\n            }\n        },\n        {\n            /**\n   * Add immutable path\n   */ key: \"_addImmutablePath\",\n            value: function _addImmutablePath(path) {\n                this._immutablePaths[path] = true;\n            }\n        },\n        {\n            /**\n   * Remove immutable path\n   */ key: \"_removeImmutablePath\",\n            value: function _removeImmutablePath(path) {\n                delete this._immutablePaths[path];\n            }\n        },\n        {\n            /**\n   * Get fragment path from immer path\n   */ key: \"_getFragmentPathFromImmerPath\",\n            value: function _getFragmentPathFromImmerPath(immerPath) {\n                var _this = this, _loop = function(i) {\n                    var subPath = void 0;\n                    if (subFragment.type === 1 /* List */ ) {\n                        var _this__config;\n                        var listIndex = immerPath[i];\n                        var subSubFragment = Object.values(subFragment.value).find(function(f) {\n                            return f.parentListIndex === listIndex;\n                        });\n                        if ((_this__config = _this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.listFragmentIndexes) {\n                            if (!subSubFragment) {\n                                console.warn(\"Could not find sub fragment with list index '\".concat(listIndex, \"'\"), immerPath, listIndex, clone(subFragment.value));\n                            }\n                            debugListFragmentIndexes(subFragment, \"_getFragmentPathFromImmerPath\");\n                        }\n                        subPath = subSubFragment.id;\n                    } else {\n                        subPath = immerPath[i];\n                    }\n                    subFragment = subFragment.value[subPath];\n                    fragmentPath.push(subPath);\n                };\n                var fragmentPath = [];\n                var subFragment = this._fragment;\n                for(var i = 0; i < immerPath.length; ++i)_loop(i);\n                return fragmentPath;\n            }\n        },\n        {\n            /**\n   * Get an immutable sub fragment based on a fragment path\n   */ key: \"_getFragmentFromFragmentPath\",\n            value: function _getFragmentFromFragmentPath(param) {\n                var path = param.path;\n                var fragment = this._fragment;\n                var immutablePath = \"\";\n                if (!this._isPathImmutable(immutablePath)) {\n                    this._addImmutablePath(immutablePath);\n                    fragment = _object_spread({}, fragment);\n                    if (fragment.value) {\n                        ;\n                        fragment.value = _object_spread({}, fragment.value);\n                    }\n                }\n                var subFragment = fragment;\n                for(var i = 0; i < path.length; ++i){\n                    if (subFragment === void 0) {\n                        break;\n                    }\n                    var index = path[i];\n                    var immutableSubPath = this._createImmutablePath([\n                        index\n                    ]);\n                    immutablePath = immutablePath ? this._combineImmutablePaths(immutablePath, immutableSubPath) : immutableSubPath;\n                    var listOrMap = subFragment;\n                    var nextSubFragment = listOrMap.value[index];\n                    if (!this._isPathImmutable(immutablePath)) {\n                        this._addImmutablePath(immutablePath);\n                        nextSubFragment = _object_spread({}, nextSubFragment);\n                        if (nextSubFragment.value) {\n                            ;\n                            nextSubFragment.value = _object_spread({}, nextSubFragment.value);\n                        }\n                        listOrMap.value[index] = nextSubFragment;\n                    }\n                    subFragment = nextSubFragment;\n                }\n                this._fragment = fragment;\n                return {\n                    fragment: subFragment,\n                    immutablePath: immutablePath\n                };\n            }\n        },\n        {\n            /**\n   * Get a fragment and a parent fragment from fragment id\n   */ key: \"_getFragmentAndParentFragment\",\n            value: function _getFragmentAndParentFragment(param) {\n                var fragmentPath = param.fragmentPath;\n                var _this__getFragmentFromFragmentPath = this._getFragmentFromFragmentPath({\n                    path: fragmentPath\n                }), fragment = _this__getFragmentFromFragmentPath.fragment, fragmentImmutablePath = _this__getFragmentFromFragmentPath.immutablePath;\n                var parentFragmentPath = this._fragmentIdToPath[fragment.parentId];\n                var _this__getFragmentFromFragmentPath1 = this._getFragmentFromFragmentPath({\n                    path: parentFragmentPath\n                }), parentFragment = _this__getFragmentFromFragmentPath1.fragment, parentFragmentImmutablePath = _this__getFragmentFromFragmentPath1.immutablePath;\n                return {\n                    fragment: fragment,\n                    fragmentImmutablePath: fragmentImmutablePath,\n                    parentFragment: parentFragment,\n                    parentFragmentPath: parentFragmentPath,\n                    parentFragmentImmutablePath: parentFragmentImmutablePath\n                };\n            }\n        },\n        {\n            /**\n   * Insert a fragment with an immer path\n   */ key: \"insertAtImmerPath\",\n            value: function insertAtImmerPath(param) {\n                var insertedFragment = param.insertedFragment, parentImmerPath = param.parentImmerPath, index = param.index;\n                var parentFragmentPath = this._getFragmentPathFromImmerPath(parentImmerPath);\n                return this._insertFragment({\n                    insertedFragment: insertedFragment,\n                    parentFragmentPath: parentFragmentPath,\n                    index: index\n                });\n            }\n        },\n        {\n            /**\n   * Insert a fragment inside a specific parent fragment id\n   */ key: \"insertWithFragmentId\",\n            value: function insertWithFragmentId(param) {\n                var insertedFragment = param.insertedFragment, parentFragmentId = param.parentFragmentId;\n                var parentFragmentPath = this._fragmentIdToPath[parentFragmentId];\n                if (!parentFragmentPath) {\n                    return void 0;\n                }\n                return this._insertFragment({\n                    insertedFragment: insertedFragment,\n                    parentFragmentPath: parentFragmentPath\n                });\n            }\n        },\n        {\n            /**\n   * Insert a fragment at a fragment path\n   */ key: \"_insertFragment\",\n            value: function _insertFragment(param) {\n                var insertedFragment = param.insertedFragment, parentFragmentPath = param.parentFragmentPath, index = param.index;\n                var _this__config;\n                var _this__getFragmentFromFragmentPath = this._getFragmentFromFragmentPath({\n                    path: parentFragmentPath\n                }), parentFragment = _this__getFragmentFromFragmentPath.fragment, parentFragmentImmutablePath = _this__getFragmentFromFragmentPath.immutablePath;\n                var fragmentIndex = parentFragment.type === 1 /* List */  ? insertedFragment.id : index ? index : insertedFragment.parentMapKey;\n                var oldFragment = parentFragment.value[fragmentIndex];\n                var insertedIndex;\n                if (parentFragment.type === 1 /* List */ ) {\n                    var _this__config1;\n                    if (index !== void 0) {\n                        insertedFragment.parentListIndex = index;\n                    }\n                    if (oldFragment) {\n                        insertedFragment.parentListIndex = oldFragment.parentListIndex;\n                    }\n                    var listFragments = this._getListFragments({\n                        listFragment: parentFragment,\n                        listImmutablePath: parentFragmentImmutablePath,\n                        itemImmutabilityFromIndex: insertedFragment.parentListIndex,\n                        itemImmutabilityToIndex: Number.MAX_SAFE_INTEGER\n                    });\n                    var toIndex = insertedFragment.parentListIndex;\n                    var addedIndex = toIndex >= listFragments.length ? listFragments.length : toIndex;\n                    insertedFragment.parentListIndex = addedIndex;\n                    if ((_this__config1 = this._config) === null || _this__config1 === void 0 ? void 0 : _this__config1.logging.listFragmentIndexes) {\n                        debugListFragmentIndexes(parentFragment, \"About to insert at \".concat(addedIndex, \".\"));\n                    }\n                    if (!oldFragment) {\n                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                        try {\n                            for(var _iterator = listFragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                var fragment = _step.value;\n                                if (fragment.parentListIndex >= addedIndex) {\n                                    fragment.parentListIndex++;\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally{\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                    _iterator.return();\n                                }\n                            } finally{\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n                    }\n                    insertedIndex = addedIndex;\n                } else {\n                    if (index !== void 0) {\n                        insertedFragment.parentMapKey = index;\n                    }\n                    insertedIndex = insertedFragment.parentMapKey;\n                }\n                if (oldFragment) {\n                    removeFragmentIdToPath({\n                        fragment: oldFragment,\n                        fragmentIdToPath: this._fragmentIdToPath\n                    });\n                }\n                var fragmentPath = _to_consumable_array(parentFragmentPath).concat([\n                    fragmentIndex\n                ]);\n                addFragmentIdToPath({\n                    fragment: insertedFragment,\n                    fragmentIdToPath: this._fragmentIdToPath,\n                    path: fragmentPath\n                });\n                this._addImmutablePath(this._combineImmutablePaths(parentFragmentImmutablePath, fragmentIndex));\n                insertedFragment.parentId = parentFragment.id;\n                parentFragment.value[fragmentIndex] = insertedFragment;\n                if (((_this__config = this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.listFragmentIndexes) && parentFragment.type === 1 /* List */ ) {\n                    debugListFragmentIndexes(parentFragment, \"Inserted at \".concat(insertedFragment.parentListIndex, \". \").concat(oldFragment ? \"Replaced old fragment, its index was \".concat(oldFragment.parentListIndex) : \"Did not replace old fragment\"));\n                }\n                return {\n                    insertedFragment: insertedFragment,\n                    insertedIndex: insertedIndex,\n                    parentFragment: parentFragment,\n                    parentFragmentPath: parentFragmentPath\n                };\n            }\n        },\n        {\n            /**\n   * Delete a fragment with an immer path\n   */ key: \"deleteAtImmerPath\",\n            value: function deleteAtImmerPath(param) {\n                var immerPath = param.immerPath;\n                var fragmentPath = this._getFragmentPathFromImmerPath(immerPath);\n                return this._deleteFragment({\n                    fragmentPath: fragmentPath\n                });\n            }\n        },\n        {\n            /**\n   * Delete a fragment with a specific fragment id\n   */ key: \"deleteWithFragmentId\",\n            value: function deleteWithFragmentId(param) {\n                var fragmentId = param.fragmentId;\n                var fragmentPath = this._fragmentIdToPath[fragmentId];\n                if (!fragmentPath) {\n                    return void 0;\n                }\n                return this._deleteFragment({\n                    fragmentPath: fragmentPath\n                });\n            }\n        },\n        {\n            /**\n   * Delete a fragment at a fragment path\n   */ key: \"_deleteFragment\",\n            value: function _deleteFragment(param) {\n                var fragmentPath = param.fragmentPath;\n                var fragmentParentResult = this._getFragmentAndParentFragment({\n                    fragmentPath: fragmentPath\n                });\n                var removedFragment = fragmentParentResult.fragment, fragmentImmutablePath = fragmentParentResult.fragmentImmutablePath, parentFragment = fragmentParentResult.parentFragment, parentFragmentPath = fragmentParentResult.parentFragmentPath, parentFragmentImmutablePath = fragmentParentResult.parentFragmentImmutablePath;\n                removeFragmentIdToPath({\n                    fragment: removedFragment,\n                    fragmentIdToPath: this._fragmentIdToPath\n                });\n                this._removeImmutablePath(fragmentImmutablePath);\n                var removedIndex;\n                if (parentFragment.type === 1 /* List */ ) {\n                    var _this__config, _this__config1;\n                    if ((_this__config = this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.listFragmentIndexes) {\n                        debugListFragmentIndexes(parentFragment, \"About to delete fragment at index '\".concat(removedFragment.parentListIndex, \"'\"));\n                    }\n                    delete parentFragment.value[removedFragment.id];\n                    var listFragments = this._getListFragments({\n                        listFragment: parentFragment,\n                        listImmutablePath: parentFragmentImmutablePath,\n                        itemImmutabilityFromIndex: removedFragment.parentListIndex + 1,\n                        itemImmutabilityToIndex: Number.MAX_SAFE_INTEGER\n                    });\n                    removedIndex = removedFragment.parentListIndex;\n                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                    try {\n                        for(var _iterator = listFragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                            var fragment = _step.value;\n                            if (fragment.parentListIndex > removedIndex) {\n                                fragment.parentListIndex--;\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                    if ((_this__config1 = this._config) === null || _this__config1 === void 0 ? void 0 : _this__config1.logging.listFragmentIndexes) {\n                        debugListFragmentIndexes(parentFragment, \"Deleted fragment at index '\".concat(removedIndex, \"'\"));\n                    }\n                } else {\n                    removedIndex = removedFragment.parentMapKey;\n                    delete parentFragment.value[removedFragment.parentMapKey];\n                }\n                return {\n                    removedFragment: removedFragment,\n                    removedIndex: removedIndex,\n                    parentFragment: parentFragment,\n                    parentFragmentPath: parentFragmentPath\n                };\n            }\n        },\n        {\n            /**\n   * Move an index of an item in a list fragment from an immer path\n   */ key: \"moveIndexAtImmerPath\",\n            value: function moveIndexAtImmerPath(param) {\n                var listImmerPath = param.listImmerPath, fromIndex = param.fromIndex, toIndex = param.toIndex;\n                var fragmentPath = this._getFragmentPathFromImmerPath(_to_consumable_array(listImmerPath).concat([\n                    fromIndex\n                ]));\n                return this._moveFragment({\n                    movedFragmentPath: fragmentPath,\n                    toIndex: toIndex\n                });\n            }\n        },\n        {\n            /**\n   * Move an index in a list from fragment id\n   */ key: \"moveIndexWithFragmentId\",\n            value: function moveIndexWithFragmentId(param) {\n                var fragmentId = param.fragmentId, toIndex = param.toIndex;\n                var fragmentPath = this._fragmentIdToPath[fragmentId];\n                if (!fragmentPath) {\n                    return void 0;\n                }\n                return this._moveFragment({\n                    movedFragmentPath: fragmentPath,\n                    toIndex: toIndex\n                });\n            }\n        },\n        {\n            /**\n   * Move an index of an item with a fragment path\n   */ key: \"_moveFragment\",\n            value: function _moveFragment(param) {\n                var movedFragmentPath = param.movedFragmentPath, toIndex = param.toIndex;\n                var _this__config, _this__config1;\n                var fragmentParentResult = this._getFragmentAndParentFragment({\n                    fragmentPath: movedFragmentPath\n                });\n                var movedFragment = fragmentParentResult.fragment, listFragment = fragmentParentResult.parentFragment, listFragmentPath = fragmentParentResult.parentFragmentPath, listImmutablePath = fragmentParentResult.parentFragmentImmutablePath;\n                if (listFragment.type !== 1 /* List */ ) {\n                    throw new Error(\"Parent of a moved item must be a \".concat(1 /* List */ , \", was \").concat(listFragment.type, \".\"));\n                }\n                var fromIndex = movedFragment.parentListIndex;\n                var listFragments = this._getListFragments({\n                    listFragment: listFragment,\n                    listImmutablePath: listImmutablePath,\n                    itemImmutabilityFromIndex: toIndex > fromIndex ? fromIndex : toIndex,\n                    itemImmutabilityToIndex: toIndex > fromIndex ? toIndex : fromIndex\n                });\n                toIndex = toIndex >= listFragments.length ? listFragments.length - 1 : toIndex;\n                if ((_this__config = this._config) === null || _this__config === void 0 ? void 0 : _this__config.logging.listFragmentIndexes) {\n                    debugListFragmentIndexes(listFragment, \"About to move fragment from '\".concat(fromIndex, \"' to '\").concat(toIndex, \"'\"));\n                }\n                if (fromIndex < toIndex) {\n                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                    try {\n                        for(var _iterator = listFragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                            var item = _step.value;\n                            var listIndex = item.parentListIndex;\n                            if (listIndex > fromIndex && listIndex <= toIndex) {\n                                item.parentListIndex--;\n                            } else if (listIndex === fromIndex) {\n                                item.parentListIndex = toIndex;\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                _iterator.return();\n                            }\n                        } finally{\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                }\n                if (fromIndex > toIndex) {\n                    var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n                    try {\n                        for(var _iterator1 = listFragments[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                            var item1 = _step1.value;\n                            var listIndex1 = item1.parentListIndex;\n                            if (listIndex1 >= toIndex && listIndex1 < fromIndex) {\n                                item1.parentListIndex++;\n                            } else if (listIndex1 === fromIndex) {\n                                item1.parentListIndex = toIndex;\n                            }\n                        }\n                    } catch (err) {\n                        _didIteratorError1 = true;\n                        _iteratorError1 = err;\n                    } finally{\n                        try {\n                            if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                                _iterator1.return();\n                            }\n                        } finally{\n                            if (_didIteratorError1) {\n                                throw _iteratorError1;\n                            }\n                        }\n                    }\n                }\n                if ((_this__config1 = this._config) === null || _this__config1 === void 0 ? void 0 : _this__config1.logging.listFragmentIndexes) {\n                    debugListFragmentIndexes(listFragment, \"Moved fragment from '\".concat(fromIndex, \"' to '\").concat(toIndex, \"'\"));\n                }\n                return {\n                    movedFragment: movedFragment,\n                    listFragmentPath: listFragmentPath,\n                    fromIndex: fromIndex,\n                    toIndex: toIndex\n                };\n            }\n        },\n        {\n            /**\n   * Replace a fragment with another\n   */ key: \"replaceFragment\",\n            value: function replaceFragment(param) {\n                var oldFragment = param.oldFragment, newFragment = param.newFragment, newFragmentPath = param.newFragmentPath, parentId = param.parentId;\n                var parentFragmentPath = this._fragmentIdToPath[parentId];\n                var _this__getFragmentFromFragmentPath = this._getFragmentFromFragmentPath({\n                    path: parentFragmentPath\n                }), parentFragment = _this__getFragmentFromFragmentPath.fragment;\n                var fragmentIndex = parentFragment.type === 1 /* List */  ? oldFragment.id : oldFragment.parentMapKey;\n                removeFragmentIdToPath({\n                    fragment: oldFragment,\n                    fragmentIdToPath: this._fragmentIdToPath\n                });\n                addFragmentIdToPath({\n                    fragment: newFragment,\n                    fragmentIdToPath: this._fragmentIdToPath,\n                    path: newFragmentPath\n                });\n                parentFragment.value[fragmentIndex] = newFragment;\n                return {\n                    parentFragment: parentFragment\n                };\n            }\n        },\n        {\n            /**\n   * Get a sub document based on a fragment path\n   */ key: \"getSubDocumentFromFragmentPath\",\n            value: function getSubDocumentFromFragmentPath(document, path) {\n                var subDocument = document;\n                var subFragment = this._fragment;\n                for(var i = 0; i < path.length; ++i){\n                    if (subFragment === void 0) {\n                        break;\n                    }\n                    subFragment = subFragment.value[path[i]];\n                    subDocument = subDocument[subFragment.parentListIndex !== void 0 ? subFragment.parentListIndex : subFragment.parentMapKey];\n                }\n                return subDocument;\n            }\n        }\n    ]);\n    return ImmutableFragment;\n}();\nvar debugListFragmentIndexes = function(listFragment, extraInfo) {\n    var allListItems = Object.values(listFragment.value);\n    var allListItemsIndexes = allListItems.map(function(item) {\n        return item.parentListIndex;\n    });\n    if (allListItemsIndexes.length !== new Set(allListItemsIndexes).size) {\n        console.warn(\"List fragment indexes are not unique. \".concat(allListItemsIndexes), extraInfo);\n    }\n    var expectedIndexes = Array.from({\n        length: allListItems.length\n    }, function(_, i) {\n        return i;\n    });\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = expectedIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var expectedIndex = _step.value;\n            if (!allListItemsIndexes.includes(expectedIndex)) {\n                console.warn(\"List fragment indexes are not correct. Missing index: \".concat(expectedIndex, \".\"), extraInfo);\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n};\n// src/channels/document/store/utils/conflictOperationUtils.ts\nvar _getFromFragmentPath = function(document, fragment, path) {\n    var subDocument = document;\n    var subFragment = fragment;\n    for(var i = 0; i < path.length; ++i){\n        if (subFragment === void 0) {\n            break;\n        }\n        subFragment = subFragment.value[path[i]];\n        subDocument = subDocument[subFragment.parentListIndex !== void 0 ? subFragment.parentListIndex : subFragment.parentMapKey];\n    }\n    return {\n        subDocument: subDocument,\n        subFragment: subFragment\n    };\n};\nvar _replaceConflictWithTruth = function(param) {\n    var conflictFragment = param.conflictFragment, draftDocument = param.draftDocument, immutableFragment = param.immutableFragment, truthDocument = param.truthDocument, truthFragment = param.truthFragment, truthFragmentPath = param.truthFragmentPath;\n    var parentFragmentPath = immutableFragment.getFragmentIdToPath()[conflictFragment.parentId];\n    var parentDocument = immutableFragment.getSubDocumentFromFragmentPath(draftDocument, parentFragmentPath);\n    var parentFragment = immutableFragment.replaceFragment({\n        oldFragment: conflictFragment,\n        newFragment: truthFragment,\n        newFragmentPath: truthFragmentPath,\n        parentId: conflictFragment.parentId\n    }).parentFragment;\n    if (parentFragment.type === 1 /* List */ ) {\n        ;\n        parentDocument.splice(conflictFragment.parentListIndex, 1, truthDocument);\n        return;\n    }\n    if (parentFragment.type === 2 /* Map */ ) {\n        parentDocument[conflictFragment.parentMapKey] = truthDocument;\n    }\n};\nvar resolveConflictsInStore = function(param) {\n    var conflictFragmentIds = param.conflictFragmentIds, conflictStore = param.conflictStore, truthStore = param.truthStore, config = param.config;\n    conflictFragmentIds = conflictFragmentIds.filter(function(v, i, a) {\n        return a.indexOf(v) === i;\n    });\n    var immutableFragment = createImmutableFragment(conflictStore.fragment, conflictStore.fragmentIdToPath, config);\n    var newDocument = (0, import_immer.produce)(conflictStore.document, function(draftDocument) {\n        var replacedPaths = [];\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            var _loop = function() {\n                var id = _step.value;\n                var truthFragmentPath = truthStore.fragmentIdToPath[id];\n                var conflictFragmentPath = immutableFragment.getFragmentIdToPath()[id];\n                if (!truthFragmentPath || !conflictFragmentPath) {\n                    return \"continue\";\n                }\n                if (!listsShallowEqual(truthFragmentPath, conflictFragmentPath)) {\n                    return \"continue\";\n                }\n                if (replacedPaths.find(function(path) {\n                    return listsShallowStartsWith(path, conflictFragmentPath);\n                })) {\n                    return \"continue\";\n                }\n                var _getFromFragmentPath1 = _getFromFragmentPath(truthStore.document, truthStore.fragment, truthFragmentPath), truthDocument = _getFromFragmentPath1.subDocument, truthFragment = _getFromFragmentPath1.subFragment;\n                var _getFromFragmentPath2 = _getFromFragmentPath(conflictStore.document, conflictStore.fragment, conflictFragmentPath), conflictDocument = _getFromFragmentPath2.subDocument, conflictFragment = _getFromFragmentPath2.subFragment;\n                if (!truthFragment || !conflictFragment) {\n                    return \"continue\";\n                }\n                if (conflictFragment.type !== truthFragment.type) {\n                    _replaceConflictWithTruth({\n                        conflictFragment: conflictFragment,\n                        draftDocument: draftDocument,\n                        immutableFragment: immutableFragment,\n                        truthDocument: truthDocument,\n                        truthFragment: truthFragment,\n                        truthFragmentPath: truthFragmentPath\n                    });\n                    replacedPaths.push(conflictFragmentPath);\n                    return \"continue\";\n                }\n                if (truthFragment.type === 2 /* Map */  && conflictFragment.type === 2 /* Map */ ) {\n                    var fragmentKeys = Object.keys(conflictFragment.value);\n                    var truthFragmentKeys = Object.keys(truthFragment.value);\n                    var replaceMap = false;\n                    if (fragmentKeys.length !== truthFragmentKeys.length) {\n                        replaceMap = true;\n                    }\n                    if (!replaceMap) {\n                        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n                        try {\n                            for(var _iterator = truthFragmentKeys[Symbol.iterator](), _step1; !(_iteratorNormalCompletion = (_step1 = _iterator.next()).done); _iteratorNormalCompletion = true){\n                                var key = _step1.value;\n                                var truthSubFragment = truthFragment.value[key];\n                                var subFragment = conflictFragment.value[key];\n                                if (truthSubFragment.id !== subFragment.id) {\n                                    replaceMap = true;\n                                    break;\n                                }\n                            }\n                        } catch (err) {\n                            _didIteratorError = true;\n                            _iteratorError = err;\n                        } finally{\n                            try {\n                                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                                    _iterator.return();\n                                }\n                            } finally{\n                                if (_didIteratorError) {\n                                    throw _iteratorError;\n                                }\n                            }\n                        }\n                    }\n                    if (!replaceMap) {\n                        return \"continue\";\n                    }\n                    _replaceConflictWithTruth({\n                        conflictFragment: conflictFragment,\n                        draftDocument: draftDocument,\n                        immutableFragment: immutableFragment,\n                        truthDocument: truthDocument,\n                        truthFragment: truthFragment,\n                        truthFragmentPath: truthFragmentPath\n                    });\n                    replacedPaths.push(conflictFragmentPath);\n                    return \"continue\";\n                }\n                if (truthFragment.type !== 1 /* List */  || conflictFragment.type !== 1 /* List */ ) {\n                    if (truthDocument === conflictDocument) {\n                        return \"continue\";\n                    }\n                    _replaceConflictWithTruth({\n                        conflictFragment: conflictFragment,\n                        draftDocument: draftDocument,\n                        immutableFragment: immutableFragment,\n                        truthDocument: truthDocument,\n                        truthFragment: truthFragment,\n                        truthFragmentPath: truthFragmentPath\n                    });\n                    replacedPaths.push(conflictFragmentPath);\n                    return \"continue\";\n                }\n                var truthSubFragmentIds = Object.keys(truthFragment.value);\n                var subFragmentIds = Object.keys(conflictFragment.value);\n                var replaceList = false;\n                if (subFragmentIds.length !== truthSubFragmentIds.length) {\n                    replaceList = true;\n                }\n                if (!replaceList) {\n                    replaceList = !!truthSubFragmentIds.find(function(id2) {\n                        return !conflictFragment.value[id2];\n                    });\n                }\n                if (replaceList) {\n                    _replaceConflictWithTruth({\n                        conflictFragment: conflictFragment,\n                        draftDocument: draftDocument,\n                        immutableFragment: immutableFragment,\n                        truthDocument: truthDocument,\n                        truthFragment: truthFragment,\n                        truthFragmentPath: truthFragmentPath\n                    });\n                    replacedPaths.push(conflictFragmentPath);\n                    return \"continue\";\n                }\n                var reorganizeList = false;\n                var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n                try {\n                    for(var _iterator1 = truthSubFragmentIds[Symbol.iterator](), _step2; !(_iteratorNormalCompletion1 = (_step2 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                        var subFragmentId = _step2.value;\n                        var truthSubFragment1 = truthFragment.value[subFragmentId];\n                        var subFragment1 = conflictFragment.value[subFragmentId];\n                        if (truthSubFragment1.parentListIndex === subFragment1.parentListIndex) {\n                            continue;\n                        }\n                        reorganizeList = true;\n                        subFragment1.parentListIndex = truthSubFragment1.parentListIndex;\n                    }\n                } catch (err) {\n                    _didIteratorError1 = true;\n                    _iteratorError1 = err;\n                } finally{\n                    try {\n                        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                            _iterator1.return();\n                        }\n                    } finally{\n                        if (_didIteratorError1) {\n                            throw _iteratorError1;\n                        }\n                    }\n                }\n                if (!reorganizeList) {\n                    return \"continue\";\n                }\n                _replaceConflictWithTruth({\n                    conflictFragment: conflictFragment,\n                    draftDocument: draftDocument,\n                    immutableFragment: immutableFragment,\n                    truthDocument: truthDocument,\n                    truthFragment: truthFragment,\n                    truthFragmentPath: truthFragmentPath\n                });\n                replacedPaths.push(conflictFragmentPath);\n            };\n            for(var _iterator = conflictFragmentIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    });\n    return {\n        newDocument: newDocument,\n        newFragment: immutableFragment.getFragment(),\n        newFragmentIdToPath: immutableFragment.getFragmentIdToPath()\n    };\n};\n// src/channels/document/store/utils/fragmentUtils.ts\nvar getFragmentType = function(fragment) {\n    switch(true){\n        case fragment == null:\n            return 0 /* Null */ ;\n        case isList(fragment):\n            return 1 /* List */ ;\n        case isMap(fragment):\n            return 2 /* Map */ ;\n        case isNumber(fragment):\n            return 3 /* Number */ ;\n        case isBoolean(fragment):\n            return 4 /* Boolean */ ;\n        case isString(fragment):\n            return 5 /* String */ ;\n    }\n    throw new Error(\"Error evaluating fragment type for value '\".concat(fragment, \"'.\"));\n};\nvar fragmentToDocument = function(param) {\n    var _loop = function() {\n        var _queue_shift = queue.shift(), documentFragment = _queue_shift.documentFragment, document = _queue_shift.document;\n        if (documentFragment.type == 1 /* List */ ) {\n            var list = Object.values(documentFragment.value).sort(function(a, b) {\n                return a.parentListIndex - b.parentListIndex;\n            });\n            var listDocument = document;\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var listItem = _step.value;\n                    var listItemDocument = listItem.type == 2 /* Map */  ? {} : listItem.type == 1 /* List */  ? [] : clone(listItem.value);\n                    listDocument.push(listItemDocument);\n                    if (listItem.type === 2 /* Map */  || listItem.type === 1 /* List */ ) {\n                        queue.push({\n                            documentFragment: listItem,\n                            document: listItemDocument\n                        });\n                    }\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n        if (documentFragment.type == 2 /* Map */ ) {\n            var map = documentFragment.value;\n            var mapDocument = document;\n            var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;\n            try {\n                for(var _iterator1 = Object.keys(map)[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true){\n                    var subKey = _step1.value;\n                    var mapItem = map[subKey];\n                    var mapItemDocument = mapItem.type == 2 /* Map */  ? {} : mapItem.type == 1 /* List */  ? [] : clone(mapItem.value);\n                    mapDocument[subKey] = mapItemDocument;\n                    if (mapItem.type === 2 /* Map */  || mapItem.type === 1 /* List */ ) {\n                        queue.push({\n                            documentFragment: mapItem,\n                            document: mapItemDocument\n                        });\n                    }\n                }\n            } catch (err) {\n                _didIteratorError1 = true;\n                _iteratorError1 = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion1 && _iterator1.return != null) {\n                        _iterator1.return();\n                    }\n                } finally{\n                    if (_didIteratorError1) {\n                        throw _iteratorError1;\n                    }\n                }\n            }\n        }\n    };\n    var fragment = param.fragment;\n    var rootDocument = fragment.type == 2 /* Map */  ? {} : fragment.type == 1 /* List */  ? [] : clone(fragment.value);\n    if (fragment.type !== 2 /* Map */  && fragment.type !== 1 /* List */ ) {\n        return rootDocument;\n    }\n    var queue = [\n        {\n            documentFragment: fragment,\n            document: rootDocument\n        }\n    ];\n    while(queue.length > 0)_loop();\n    return rootDocument;\n};\nvar getFragmentSubItems = function(param) {\n    var rawDocument = param.rawDocument, fragment = param.fragment;\n    var queue = [];\n    if (fragment.type == 1 /* List */ ) {\n        var list = rawDocument;\n        list.forEach(function(listItem, i) {\n            queue.push({\n                rawDocument: listItem,\n                parentFragment: fragment,\n                parentListIndex: i\n            });\n        });\n    }\n    if (fragment.type == 2 /* Map */ ) {\n        var map = rawDocument;\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = Object.keys(map)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var subKey = _step.value;\n                queue.push({\n                    rawDocument: map[subKey],\n                    parentFragment: fragment,\n                    parentMapKey: subKey\n                });\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }\n    return queue;\n};\nvar documentToFragment = function(document, rootFragmentId) {\n    document = clone(document);\n    var rootType = getFragmentType(document);\n    var rootFragment = {\n        id: rootFragmentId !== null && rootFragmentId !== void 0 ? rootFragmentId : uniqueId(),\n        type: rootType,\n        value: rootType == 2 /* Map */  || rootType == 1 /* List */  ? {} : document\n    };\n    var queue = _to_consumable_array(getFragmentSubItems({\n        rawDocument: document,\n        fragment: rootFragment\n    }));\n    while(queue.length > 0){\n        var _queue;\n        var _queue_shift = queue.shift(), rawDocument = _queue_shift.rawDocument, parentFragment = _queue_shift.parentFragment, parentMapKey = _queue_shift.parentMapKey, parentListIndex = _queue_shift.parentListIndex;\n        var id = uniqueId();\n        var type = getFragmentType(rawDocument);\n        var document2 = type == 2 /* Map */  || type == 1 /* List */  ? {} : rawDocument;\n        var fragment = {\n            id: id,\n            parentId: parentFragment.id,\n            type: type,\n            value: document2\n        };\n        if (parentMapKey) {\n            fragment.parentMapKey = parentMapKey;\n        }\n        if (parentListIndex !== void 0) {\n            fragment.parentListIndex = parentListIndex;\n        }\n        switch(parentFragment.type){\n            case 1 /* List */ :\n                ;\n                parentFragment.value[fragment.id] = fragment;\n                break;\n            case 2 /* Map */ :\n                if (parentMapKey) parentFragment.value[parentMapKey] = fragment;\n                break;\n        }\n        (_queue = queue).push.apply(_queue, _to_consumable_array(getFragmentSubItems({\n            rawDocument: rawDocument,\n            fragment: fragment\n        })));\n    }\n    return rootFragment;\n};\n// src/channels/document/store/utils/localOperationUtils.ts\nvar _getSubDocument = function(document, path) {\n    var subDocument = document;\n    for(var i = 0; i < path.length; ++i){\n        if (subDocument === void 0) {\n            break;\n        }\n        subDocument = subDocument[path[i]];\n    }\n    return subDocument;\n};\nvar _getListOperations = function(path, listPatches, oldList, newList) {\n    oldList = _to_consumable_array(oldList);\n    var operations = [];\n    var i = 0;\n    var j = 0;\n    var previousDeletedOperation = void 0;\n    while(i < oldList.length && j < newList.length){\n        if (oldList[i] === newList[j]) {\n            i++;\n            j++;\n            previousDeletedOperation = void 0;\n        } else if (newList.indexOf(oldList[i]) === -1) {\n            var deleteOp = {\n                op: \"delete\",\n                path: path,\n                index: i\n            };\n            previousDeletedOperation = deleteOp;\n            operations.push(deleteOp);\n            oldList.splice(i, 1);\n        } else if (oldList.indexOf(newList[j]) === -1) {\n            if (previousDeletedOperation && previousDeletedOperation.index === i) {\n                var deletedOpr = operations.splice(-1)[0];\n                if (deletedOpr !== previousDeletedOperation) {\n                    throw new Error(\"Deleted operation is not the last operation\");\n                }\n                var replaceOp = {\n                    op: \"replace\",\n                    path: path,\n                    index: i,\n                    value: newList[j]\n                };\n                operations.push(replaceOp);\n            } else {\n                var insertOp = {\n                    op: \"insert\",\n                    path: path,\n                    index: i,\n                    value: newList[j]\n                };\n                operations.push(insertOp);\n            }\n            oldList.splice(i, 0, newList[j]);\n            i++;\n            j++;\n            previousDeletedOperation = void 0;\n        } else {\n            var k = oldList.indexOf(newList[j], i);\n            operations.push({\n                op: \"move\",\n                path: path,\n                oldIndex: k < 0 ? oldList.length - 1 : k,\n                newIndex: i\n            });\n            var temp = oldList[k];\n            for(var l = k; l > i; l--){\n                oldList[l] = oldList[l - 1];\n            }\n            oldList[i] = temp;\n            previousDeletedOperation = void 0;\n        }\n    }\n    while(i < oldList.length){\n        var deleteOp1 = {\n            op: \"delete\",\n            path: path,\n            index: i\n        };\n        previousDeletedOperation = deleteOp1;\n        operations.push(deleteOp1);\n        oldList.splice(i, 1);\n    }\n    while(j < newList.length){\n        if (previousDeletedOperation && previousDeletedOperation.index === i) {\n            var deletedOpr1 = operations.splice(-1)[0];\n            if (deletedOpr1 !== previousDeletedOperation) {\n                throw new Error(\"Deleted operation is not the last operation\");\n            }\n            var replaceOp1 = {\n                op: \"replace\",\n                path: path,\n                index: i++,\n                value: newList[j++]\n            };\n            operations.push(replaceOp1);\n        } else {\n            var insertOp1 = {\n                op: \"insert\",\n                path: path,\n                index: i++,\n                value: newList[j++]\n            };\n            operations.push(insertOp1);\n        }\n        previousDeletedOperation = void 0;\n    }\n    var finalOperations = [];\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        var _loop = function() {\n            var operation = _step.value;\n            if (operation.op !== \"delete\" && operation.op !== \"insert\" && operation.op !== \"replace\") {\n                finalOperations.push(operation);\n                return \"continue\";\n            }\n            var listPatch = listPatches.find(function(op) {\n                return op.path.length > 0 && op.path[op.path.length - 1] === operation.index;\n            });\n            if (!listPatch) {\n                return \"continue\";\n            }\n            finalOperations.push(operation);\n        };\n        for(var _iterator = operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return finalOperations;\n};\nvar immerPatchesToOperations = function(param) {\n    var patches = param.patches, oldDocument = param.oldDocument, newDocument = param.newDocument;\n    var operations = [];\n    var index = 0;\n    while(patches.length > index){\n        var currentPatch = patches[index];\n        if (currentPatch.path.length === 0) {\n            operations.push({\n                op: \"root\",\n                path: [],\n                value: currentPatch.value\n            });\n            index++;\n            continue;\n        }\n        var path = currentPatch.path;\n        var parentPath = path.slice(0, -1);\n        var parentDocument = _getSubDocument(newDocument, parentPath);\n        if (parentDocument && isList(parentDocument)) {\n            var _operations;\n            var listPatches = [\n                currentPatch\n            ];\n            while(++index){\n                if (patches.length <= index) {\n                    break;\n                }\n                var nextListPatch = patches[index];\n                if (nextListPatch.path.length !== path.length || !listsShallowEqual(parentPath, nextListPatch.path.slice(0, -1))) {\n                    break;\n                }\n                listPatches.push(nextListPatch);\n            }\n            var oldParentDocument = _getSubDocument(oldDocument, parentPath);\n            (_operations = operations).push.apply(_operations, _to_consumable_array(_getListOperations(parentPath, listPatches, oldParentDocument, parentDocument)));\n            continue;\n        }\n        var operationIndex = path[path.length - 1];\n        switch(currentPatch.op){\n            case \"replace\":\n                operations.push({\n                    op: \"replace\",\n                    path: parentPath,\n                    index: operationIndex,\n                    value: currentPatch.value\n                });\n                break;\n            case \"add\":\n                operations.push({\n                    op: \"insert\",\n                    path: parentPath,\n                    index: operationIndex,\n                    value: currentPatch.value\n                });\n                break;\n            case \"remove\":\n                operations.push({\n                    op: \"delete\",\n                    path: parentPath,\n                    index: operationIndex\n                });\n                break;\n        }\n        index++;\n    }\n    return operations;\n};\nvar applyPatchOperationsToFragment = function(param) {\n    var fragment = param.fragment, fragmentIdToPath = param.fragmentIdToPath, operations = param.operations, config = param.config;\n    var requests = [];\n    var immutableFragment = createImmutableFragment(fragment, fragmentIdToPath, config);\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        for(var _iterator = operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n            var operation = _step.value;\n            if (operation.op === \"root\") {\n                if (operations.length > 1) {\n                    throw new Error(\"Cannot have more than one operation with set root.\");\n                }\n                var newFragment = documentToFragment(operation.value);\n                var newFragmentIdToPath = createFragmentIdToPath({\n                    fragment: newFragment\n                });\n                immutableFragment = createImmutableFragment(newFragment, newFragmentIdToPath);\n                requests.push({\n                    op: \"root\",\n                    value: clone(newFragment)\n                });\n                break;\n            }\n            switch(operation.op){\n                case \"insert\":\n                    {\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Inserting fragment\", operation.path, operation.index);\n                        }\n                        var insertedFragment = immutableFragment.insertAtImmerPath({\n                            insertedFragment: documentToFragment(operation.value),\n                            parentImmerPath: operation.path,\n                            index: operation.index\n                        }).insertedFragment;\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Inserted successfully fragment \".concat(insertedFragment.id));\n                        }\n                        requests.push({\n                            op: \"insert\",\n                            parentId: insertedFragment.parentId,\n                            parentMapKey: insertedFragment.parentMapKey,\n                            parentListIndex: insertedFragment.parentListIndex,\n                            value: clone(insertedFragment)\n                        });\n                    }\n                    break;\n                case \"delete\":\n                    {\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Removing fragment\", operation.path, operation.index);\n                        }\n                        var immerPath = _to_consumable_array(operation.path).concat([\n                            operation.index\n                        ]);\n                        var removedFragment = immutableFragment.deleteAtImmerPath({\n                            immerPath: immerPath\n                        }).removedFragment;\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Removed fragment successfully \".concat(removedFragment.id));\n                        }\n                        requests.push({\n                            op: \"delete\",\n                            id: removedFragment.id,\n                            parentId: removedFragment.parentId\n                        });\n                    }\n                    break;\n                case \"replace\":\n                    {\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation start] Replacing fragment\", operation.path, operation.index);\n                        }\n                        var immerPath1 = _to_consumable_array(operation.path).concat([\n                            operation.index\n                        ]);\n                        var removedFragment1 = immutableFragment.deleteAtImmerPath({\n                            immerPath: immerPath1\n                        }).removedFragment;\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Removed fragment \".concat(removedFragment1.id, \" \").concat(removedFragment1.parentListIndex, \" (replace)\"));\n                        }\n                        var insertedFragment1 = immutableFragment.insertAtImmerPath({\n                            insertedFragment: documentToFragment(operation.value, removedFragment1.id),\n                            parentImmerPath: operation.path,\n                            index: operation.index\n                        }).insertedFragment;\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Inserted fragment \".concat(insertedFragment1.id, \" (replace) - finished\"));\n                        }\n                        requests.push({\n                            op: \"replace\",\n                            id: insertedFragment1.id,\n                            value: clone(insertedFragment1)\n                        });\n                    }\n                    break;\n                case \"move\":\n                    {\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Moving fragment\", operation.path, operation.oldIndex, operation.newIndex);\n                        }\n                        var _immutableFragment_moveIndexAtImmerPath = immutableFragment.moveIndexAtImmerPath({\n                            listImmerPath: operation.path,\n                            fromIndex: operation.oldIndex,\n                            toIndex: operation.newIndex\n                        }), movedFragment = _immutableFragment_moveIndexAtImmerPath.movedFragment, toIndex = _immutableFragment_moveIndexAtImmerPath.toIndex;\n                        if (config.logging.localOperations) {\n                            console.log(\"[Local operation] Moved fragment successfully \", movedFragment.id);\n                        }\n                        requests.push({\n                            op: \"move\",\n                            id: movedFragment.id,\n                            index: toIndex,\n                            parentId: movedFragment.parentId\n                        });\n                    }\n                    break;\n                default:\n                    console.warn(\"Unhandled operation '\".concat(operation.op, \"' in local operations.\"));\n                    break;\n            }\n        }\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return {\n        newFragment: immutableFragment.getFragment(),\n        newFragmentIdToPath: immutableFragment.getFragmentIdToPath(),\n        requests: requests\n    };\n};\n// src/channels/document/store/utils/remoteOperationUtils.ts\nvar import_immer2 = __webpack_require__(/*! immer */ \"../../node_modules/immer/dist/cjs/index.js\");\n// src/channels/document/store/utils/minifyOperations.ts\nvar minifyOperations = function(operations) {\n    var minifiedOperations = [];\n    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n    try {\n        var _loop = function() {\n            var operation = _step.value;\n            switch(operation.op){\n                case \"root\":\n                    minifiedOperations = [\n                        operation\n                    ];\n                    break;\n                case \"insert\":\n                    {\n                        minifiedOperations.push(operation);\n                    }\n                    break;\n                case \"replace\":\n                    {\n                        minifiedOperations = minifiedOperations.filter(function(opr) {\n                            return !(opr.op === DocumentOperationReplace && opr.id === operation.id);\n                        });\n                        minifiedOperations.push(operation);\n                    }\n                    break;\n                case \"delete\":\n                    {\n                        var lastInsertIndex = minifiedOperations.map(function(opr) {\n                            return opr.op === DocumentOperationInsert && opr.value.id === operation.id;\n                        }).lastIndexOf(true);\n                        if (lastInsertIndex > 0) {\n                            var removedInsert = minifiedOperations[lastInsertIndex];\n                            if (removedInsert.parentListIndex !== void 0 && lastInsertIndex !== minifiedOperations.length - 1) {\n                                minifiedOperations.push(operation);\n                            } else {\n                                minifiedOperations.splice(lastInsertIndex, 1);\n                            }\n                        } else {\n                            minifiedOperations.push(operation);\n                        }\n                    }\n                    break;\n                case \"move\":\n                    {\n                        if (minifiedOperations.length > 0) {\n                            var lastOp = minifiedOperations[minifiedOperations.length - 1];\n                            if (lastOp.op === DocumentOperationMove && lastOp.id === operation.id) {\n                                minifiedOperations[minifiedOperations.length - 1] = operation;\n                                break;\n                            }\n                        }\n                        minifiedOperations.push(operation);\n                    }\n                    break;\n            }\n        };\n        for(var _iterator = operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true)_loop();\n    } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n    } finally{\n        try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n            }\n        } finally{\n            if (_didIteratorError) {\n                throw _iteratorError;\n            }\n        }\n    }\n    return minifiedOperations;\n};\n// src/channels/document/store/utils/remoteOperationUtils.ts\nvar applyRemoteOperationsToStores = function(messages, stores) {\n    var _instance;\n    var operations = (_instance = []).concat.apply(_instance, _to_consumable_array(messages.map(function(m) {\n        return m.operations;\n    })));\n    var minifiedOperations = minifyOperations(operations);\n    var newMessages = [\n        {\n            messageId: \"\",\n            type: \"ops\",\n            docId: \"\",\n            clientId: \"\",\n            clientSubId: \"\",\n            operations: minifiedOperations\n        }\n    ];\n    stores.forEach(function(store) {\n        try {\n            store.applyRemoteOperations(newMessages);\n        } catch (error) {\n            console.error(\"Error with store \".concat(store.getName()), error);\n            throw error;\n        }\n    });\n};\nvar applyRemoteOperationsMessages = function(param) {\n    var document = param.document, fragment = param.fragment, fragmentIdToPath = param.fragmentIdToPath, messages = param.messages, config = param.config, storeName = param.storeName;\n    var operations = messages.map(function(m) {\n        return m.operations;\n    }).reduce(function(a, b) {\n        return a.concat(b);\n    }, []);\n    var lastRootIndex = operations.map(function(o) {\n        return o.op === \"root\";\n    }).lastIndexOf(true);\n    if (lastRootIndex >= 0) {\n        var rootOperation = operations[lastRootIndex];\n        fragment = clone(rootOperation.value);\n        document = fragmentToDocument({\n            fragment: fragment\n        });\n        fragmentIdToPath = createFragmentIdToPath({\n            fragment: fragment\n        });\n        operations = operations.slice(lastRootIndex + 1);\n    }\n    var immutableFragment = createImmutableFragment(fragment, fragmentIdToPath, config);\n    var newDocument = (0, import_immer2.produce)(document, function(draftDocument) {\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var operation = _step.value;\n                switch(operation.op){\n                    case \"insert\":\n                        {\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Insert started on fragment \").concat(operation.value.id));\n                            }\n                            var insertWithFragmentIdResult = immutableFragment.insertWithFragmentId({\n                                insertedFragment: clone(operation.value),\n                                parentFragmentId: operation.parentId\n                            });\n                            if (!insertWithFragmentIdResult) {\n                                if (config.logging.remoteOperations) {\n                                    console.log(\"[Remote operation in store \".concat(storeName, \"] Insert did not finish on fragment \").concat(operation.value.id));\n                                }\n                                continue;\n                            }\n                            var insertedFragment = insertWithFragmentIdResult.insertedFragment, parentFragment = insertWithFragmentIdResult.parentFragment, parentFragmentPath = insertWithFragmentIdResult.parentFragmentPath;\n                            var insertedDocument = fragmentToDocument({\n                                fragment: insertedFragment\n                            });\n                            var parentDocument = immutableFragment.getSubDocumentFromFragmentPath(draftDocument, parentFragmentPath);\n                            if (parentFragment.type === 1 /* List */ ) {\n                                var list = parentDocument;\n                                var documentIndex = insertedFragment.parentListIndex;\n                                list.splice(documentIndex, 0, insertedDocument);\n                            } else {\n                                var index = insertedFragment.parentMapKey;\n                                parentDocument[index] = insertedDocument;\n                            }\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Insert completed on fragment \").concat(operation.value.id));\n                            }\n                        }\n                        break;\n                    case \"replace\":\n                        {\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Replacing fragment \").concat(operation.id));\n                            }\n                            var deleteWithFragmentIdResult = immutableFragment.deleteWithFragmentId({\n                                fragmentId: operation.id\n                            });\n                            if (!deleteWithFragmentIdResult) {\n                                if (config.logging.remoteOperations) {\n                                    console.log(\"[Remote operation in store \".concat(storeName, \"] Failed to delete fragment \").concat(operation.id, \" (replace)\"));\n                                }\n                                continue;\n                            }\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Deleted fragment \").concat(operation.id, \" (replace)\"));\n                            }\n                            var removedIndex = deleteWithFragmentIdResult.removedIndex, parentFragment1 = deleteWithFragmentIdResult.parentFragment, parentFragmentPath1 = deleteWithFragmentIdResult.parentFragmentPath;\n                            var fragmentToInsert = clone(operation.value);\n                            if (parentFragment1.type === 1 /* List */ ) {\n                                fragmentToInsert.parentListIndex = removedIndex;\n                            }\n                            var insertWithFragmentIdResult1 = immutableFragment.insertWithFragmentId({\n                                insertedFragment: fragmentToInsert,\n                                parentFragmentId: fragmentToInsert.parentId\n                            });\n                            if (!insertWithFragmentIdResult1) {\n                                if (config.logging.remoteOperations) {\n                                    console.log(\"[Remote operation in store \".concat(storeName, \"] Failed to insert \").concat(operation.id, \" (replace)\"));\n                                }\n                                continue;\n                            }\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Inserted fragment \").concat(operation.id, \" (replace)\"));\n                            }\n                            var insertedFragment1 = insertWithFragmentIdResult1.insertedFragment;\n                            var insertedDocument1 = fragmentToDocument({\n                                fragment: insertedFragment1\n                            });\n                            var parentDocument1 = immutableFragment.getSubDocumentFromFragmentPath(draftDocument, parentFragmentPath1);\n                            if (parentFragment1.type === 1 /* List */ ) {\n                                var list1 = parentDocument1;\n                                var documentIndex1 = insertedFragment1.parentListIndex;\n                                list1[documentIndex1] = insertedDocument1;\n                            } else {\n                                var index1 = insertedFragment1.parentMapKey;\n                                parentDocument1[index1] = insertedDocument1;\n                            }\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Replaced successfully \").concat(operation.id));\n                            }\n                        }\n                        break;\n                    case \"delete\":\n                        {\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Delete started on fragment \").concat(operation.id));\n                            }\n                            var deleteWithFragmentIdResult1 = immutableFragment.deleteWithFragmentId({\n                                fragmentId: operation.id\n                            });\n                            if (!deleteWithFragmentIdResult1) {\n                                if (config.logging.remoteOperations) {\n                                    console.log(\"[Remote operation in store \".concat(storeName, \"] Delete did not finish on fragment \").concat(operation.id));\n                                }\n                                continue;\n                            }\n                            var removedIndex1 = deleteWithFragmentIdResult1.removedIndex, parentFragment2 = deleteWithFragmentIdResult1.parentFragment, parentFragmentPath2 = deleteWithFragmentIdResult1.parentFragmentPath;\n                            var parentDocument2 = immutableFragment.getSubDocumentFromFragmentPath(draftDocument, parentFragmentPath2);\n                            if (parentFragment2.type === 1 /* List */ ) {\n                                var list2 = parentDocument2;\n                                list2.splice(removedIndex1, 1);\n                            } else {\n                                delete parentDocument2[removedIndex1];\n                            }\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Delete successfully on fragment \").concat(operation.id));\n                            }\n                        }\n                        break;\n                    case \"move\":\n                        {\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Moving fragment \").concat(operation.id));\n                            }\n                            var moveIndexWithFragmentIdResult = immutableFragment.moveIndexWithFragmentId({\n                                fragmentId: operation.id,\n                                toIndex: operation.index\n                            });\n                            if (!moveIndexWithFragmentIdResult) {\n                                if (config.logging.remoteOperations) {\n                                    console.log(\"[Remote operation in store \".concat(storeName, \"] Moving failed for fragment \").concat(operation.id));\n                                }\n                                continue;\n                            }\n                            var fromIndex = moveIndexWithFragmentIdResult.fromIndex, toIndex = moveIndexWithFragmentIdResult.toIndex, listFragmentPath = moveIndexWithFragmentIdResult.listFragmentPath;\n                            var list3 = immutableFragment.getSubDocumentFromFragmentPath(draftDocument, listFragmentPath);\n                            list3.splice(toIndex, 0, list3.splice(fromIndex, 1)[0]);\n                            if (config.logging.remoteOperations) {\n                                console.log(\"[Remote operation in store \".concat(storeName, \"] Moving was successful for fragment \").concat(operation.id));\n                            }\n                        }\n                        break;\n                    default:\n                        console.warn(\"Unhandled operation message '\".concat(operation.op, \"' for a \").concat(fragment.type, \" fragment.\"));\n                        break;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    });\n    return {\n        newDocument: newDocument,\n        newFragment: immutableFragment.getFragment(),\n        newFragmentIdToPath: immutableFragment.getFragmentIdToPath()\n    };\n};\n// src/channels/document/store/useRealtimeStore.ts\n(0, import_immer3.enablePatches)();\nvar useRealtimeStore = function(param) {\n    var onPatchOperations = param.onPatchOperations, config = param.config, name = param.name;\n    var onPatchOperationsRef = (0, import_react11.useRef)();\n    (0, import_react11.useEffect)(function() {\n        onPatchOperationsRef.current = onPatchOperations;\n    }, [\n        onPatchOperations\n    ]);\n    var useStoreWithPatchRef = (0, import_react11.useRef)((0, import_zustand3.create)()((0, import_middleware3.subscribeWithSelector)(function(set, get) {\n        return {\n            document: void 0,\n            fragment: void 0,\n            fragmentIdToPath: void 0,\n            getRoot: function() {\n                return get();\n            },\n            setRoot: function(param) {\n                var document = param.document, fragment = param.fragment, fragmentIdToPath = param.fragmentIdToPath;\n                if (document && fragment && fragmentIdToPath) {\n                    set({\n                        document: (0, import_immer3.freeze)(document),\n                        fragment: fragment,\n                        fragmentIdToPath: fragmentIdToPath\n                    });\n                } else {\n                    set({\n                        document: document,\n                        fragment: fragment,\n                        fragmentIdToPath: fragmentIdToPath\n                    });\n                }\n            },\n            patch: function(fn) {\n                var oldDocument = get().document;\n                var oldFragment = get().fragment;\n                var oldFragmentIdToPath = get().fragmentIdToPath;\n                var _ref = _sliced_to_array((0, import_immer3.produceWithPatches)(oldDocument, fn), 3), newDocument = _ref[0], patches = _ref[1], invertPatches = _ref[2];\n                var operations = immerPatchesToOperations({\n                    patches: patches,\n                    oldDocument: oldDocument,\n                    newDocument: newDocument\n                });\n                var _applyPatchOperationsToFragment = applyPatchOperationsToFragment({\n                    fragment: oldFragment,\n                    fragmentIdToPath: oldFragmentIdToPath,\n                    operations: operations,\n                    config: config\n                }), newFragment = _applyPatchOperationsToFragment.newFragment, newFragmentIdToPath = _applyPatchOperationsToFragment.newFragmentIdToPath, requests = _applyPatchOperationsToFragment.requests;\n                set({\n                    document: newDocument,\n                    fragment: newFragment,\n                    fragmentIdToPath: newFragmentIdToPath\n                });\n                if (onPatchOperationsRef.current) {\n                    onPatchOperationsRef.current(requests);\n                }\n            },\n            applyRemoteOperations: function(messages) {\n                var oldDocument = get().document;\n                var oldFragment = get().fragment;\n                var oldFragmentIdToPath = get().fragmentIdToPath;\n                var _applyRemoteOperationsMessages = applyRemoteOperationsMessages({\n                    document: oldDocument,\n                    fragment: oldFragment,\n                    fragmentIdToPath: oldFragmentIdToPath,\n                    messages: messages,\n                    storeName: name,\n                    config: config\n                }), newDocument = _applyRemoteOperationsMessages.newDocument, newFragment = _applyRemoteOperationsMessages.newFragment, newFragmentIdToPath = _applyRemoteOperationsMessages.newFragmentIdToPath;\n                set({\n                    document: newDocument,\n                    fragment: newFragment,\n                    fragmentIdToPath: newFragmentIdToPath\n                });\n            },\n            resolveConflicts: function(conflictFragmentIds, truthStore) {\n                var oldDocument = get().document;\n                var oldFragment = get().fragment;\n                var oldFragmentIdToPath = get().fragmentIdToPath;\n                var truthStoreRoot = truthStore.getRoot();\n                var _resolveConflictsInStore = resolveConflictsInStore({\n                    conflictFragmentIds: conflictFragmentIds,\n                    conflictStore: {\n                        document: oldDocument,\n                        fragment: oldFragment,\n                        fragmentIdToPath: oldFragmentIdToPath\n                    },\n                    truthStore: truthStoreRoot,\n                    config: config\n                }), newDocument = _resolveConflictsInStore.newDocument, newFragment = _resolveConflictsInStore.newFragment, newFragmentIdToPath = _resolveConflictsInStore.newFragmentIdToPath;\n                set({\n                    document: newDocument,\n                    fragment: newFragment,\n                    fragmentIdToPath: newFragmentIdToPath\n                });\n            }\n        };\n    })));\n    var getName = (0, import_react11.useCallback)(function() {\n        return name;\n    }, []);\n    var getRoot = (0, import_react11.useMemo)(function() {\n        return function() {\n            return useStoreWithPatchRef.current.getState().getRoot();\n        };\n    }, []);\n    var setRoot = (0, import_react11.useMemo)(function() {\n        return function(props) {\n            return useStoreWithPatchRef.current.getState().setRoot(props);\n        };\n    }, []);\n    var useStore = (0, import_react11.useMemo)(function() {\n        return function(selector, equalityFn) {\n            return useStoreWithPatchRef.current(function(root) {\n                return root.fragment === void 0 ? void 0 : selector ? selector(root.document) : root.document;\n            }, equalityFn);\n        };\n    }, []);\n    var subscribe = (0, import_react11.useMemo)(function() {\n        return function(selector, listener, options) {\n            return useStoreWithPatchRef.current.subscribe(function(root) {\n                return root.fragment === void 0 ? void 0 : selector ? selector(root.document) : root.document;\n            }, listener, options);\n        };\n    }, []);\n    var patch = (0, import_react11.useMemo)(function() {\n        return function(fn) {\n            return useStoreWithPatchRef.current.getState().patch(fn);\n        };\n    }, []);\n    var applyRemoteOperations = (0, import_react11.useMemo)(function() {\n        return function(messages) {\n            return useStoreWithPatchRef.current.getState().applyRemoteOperations(messages);\n        };\n    }, []);\n    var resolveConflicts = (0, import_react11.useMemo)(function() {\n        return function(conflictFragmentIds, truthStore) {\n            return useStoreWithPatchRef.current.getState().resolveConflicts(conflictFragmentIds, truthStore);\n        };\n    }, []);\n    return {\n        getName: getName,\n        getRoot: getRoot,\n        setRoot: setRoot,\n        useStore: useStore,\n        patch: patch,\n        subscribe: subscribe,\n        applyRemoteOperations: applyRemoteOperations,\n        resolveConflicts: resolveConflicts\n    };\n};\n// src/channels/document/useDocument.ts\nvar OpsMessageType = \"ops\";\nvar MaxOpsPerMessage = 30;\nvar useDocumentChannel = function(param) {\n    var config = param.config, connectionStatus = param.connectionStatus, connectionStatusRef = param.connectionStatusRef, useChannel = param.useChannel, documentId = param.documentId, requestedThrottle = param.throttle;\n    var _ref = _sliced_to_array((0, import_react12.useState)(\"Unready\" /* Unready */ ), 2), subscriptionStatus = _ref[0], setSubscriptionStatus = _ref[1];\n    var subscriptionStatusRef = (0, import_react12.useRef)(\"Unready\" /* Unready */ );\n    var _ref1 = _sliced_to_array((0, import_react12.useState)(\"Unready\" /* Unready */ ), 2), availabilityStatus = _ref1[0], setAvailabilityStatus = _ref1[1];\n    var availabilityStatusRef = (0, import_react12.useRef)(\"Unready\" /* Unready */ );\n    var _ref2 = _sliced_to_array((0, import_react12.useState)(0), 2), throttle = _ref2[0], setThrottle = _ref2[1];\n    var sendMessageRef = (0, import_react12.useRef)();\n    var documentIdRef = (0, import_react12.useRef)(documentId);\n    var preSyncReceivedOperationsRef = (0, import_react12.useRef)([]);\n    var conflictsIdsRef = (0, import_react12.useRef)([]);\n    var unackedOperationsRef = (0, import_react12.useRef)([]);\n    var saveLocalChangesRef = (0, import_react12.useRef)();\n    var subscriptionIdRef = (0, import_react12.useRef)();\n    var subscribedToDocumentIdRef = (0, import_react12.useRef)();\n    var sendOperations = (0, import_react12.useCallback)(function(request) {\n        var _conflictsIdsRef_current;\n        var conflicts = [];\n        var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n        try {\n            for(var _iterator = request.operations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                var op = _step.value;\n                switch(op.op){\n                    case \"root\":\n                        conflicts.push(op.value.id);\n                        break;\n                    case \"insert\":\n                        conflicts.push(op.parentId);\n                        break;\n                    case \"replace\":\n                        conflicts.push(op.value.parentId);\n                        conflicts.push(op.value.id);\n                        break;\n                    case \"move\":\n                        conflicts.push(op.parentId);\n                        break;\n                    case \"delete\":\n                        conflicts.push(op.parentId);\n                        break;\n                }\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally{\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                }\n            } finally{\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n        (_conflictsIdsRef_current = conflictsIdsRef.current).push.apply(_conflictsIdsRef_current, _to_consumable_array(conflicts));\n        unackedOperationsRef.current.push(request);\n        sendMessageRef.current(request);\n    }, []);\n    var onLocalPatchOperations = (0, import_react12.useCallback)(function(requests) {\n        if (requests.length === 0) {\n            return;\n        }\n        var request = {\n            messageId: uniqueId(),\n            subId: subscriptionIdRef.current,\n            type: OpsMessageType,\n            operations: requests\n        };\n        if (saveLocalChangesRef.current) {\n            saveLocalChangesRef.current(request);\n        }\n        if (subscriptionStatusRef.current !== \"Ready\" /* Ready */ ) {\n            return;\n        }\n        sendOperations(request);\n    }, []);\n    var localStore = useRealtimeStore({\n        onPatchOperations: onLocalPatchOperations,\n        name: \"local\",\n        config: config\n    });\n    var remoteStore = useRealtimeStore({\n        name: \"local\",\n        config: config\n    });\n    var _useDocumentAutosave = useDocumentAutosave({\n        config: config,\n        documentId: documentId,\n        subscriptionIdRef: subscriptionIdRef,\n        localStore: localStore,\n        onLocalData: (0, import_react12.useCallback)(function(fragment) {\n            if (availabilityStatusRef.current === \"Ready\" /* Ready */ ) {\n                return;\n            }\n            if (fragment.type !== 1 /* List */  && fragment.type !== 2 /* Map */ ) {\n                return;\n            }\n            var document = fragmentToDocument({\n                fragment: fragment\n            });\n            var fragmentIdToPath = createFragmentIdToPath({\n                fragment: fragment\n            });\n            localStore.setRoot({\n                document: document,\n                fragment: fragment,\n                fragmentIdToPath: _object_spread({}, fragmentIdToPath)\n            });\n            conflictsIdsRef.current = [];\n            unackedOperationsRef.current = [];\n            setAvailabilityStatus(\"ReadyLocal\" /* ReadyLocal */ );\n            availabilityStatusRef.current = \"ReadyLocal\" /* ReadyLocal */ ;\n        }, []),\n        onNoLocalData: (0, import_react12.useCallback)(function() {\n            if (availabilityStatusRef.current === \"Ready\" /* Ready */ ) {\n                return;\n            }\n            conflictsIdsRef.current = [];\n            unackedOperationsRef.current = [];\n            setAvailabilityStatus(\"Unready\" /* Unready */ );\n            availabilityStatusRef.current = \"Unready\" /* Unready */ ;\n        }, [])\n    }), saveLocalChanges = _useDocumentAutosave.saveLocalChanges, markForLocalSaving = _useDocumentAutosave.markForLocalSaving, updateLocalChanges = _useDocumentAutosave.updateLocalChanges, getLocalChangesToSync = _useDocumentAutosave.getLocalChangesToSync, acknowledgeLocalChange = _useDocumentAutosave.acknowledgeLocalChange;\n    (0, import_react12.useEffect)(function() {\n        saveLocalChangesRef.current = saveLocalChanges;\n    }, [\n        saveLocalChanges\n    ]);\n    (0, import_react12.useEffect)(function() {\n        if (subscriptionStatus !== \"Ready\" /* Ready */ ) {\n            setThrottle(0);\n            return;\n        }\n        setThrottle(requestedThrottle);\n    }, [\n        subscriptionStatus,\n        requestedThrottle\n    ]);\n    var onSyncMessage = (0, import_react12.useCallback)(function(fragment) {\n        var localChanges = getLocalChangesToSync();\n        var document = fragmentToDocument({\n            fragment: fragment\n        });\n        var fragmentIdToPath = createFragmentIdToPath({\n            fragment: fragment\n        });\n        localStore.setRoot({\n            document: document,\n            fragment: fragment,\n            fragmentIdToPath: _object_spread({}, fragmentIdToPath)\n        });\n        remoteStore.setRoot({\n            document: document,\n            fragment: fragment,\n            fragmentIdToPath: _object_spread({}, fragmentIdToPath)\n        });\n        conflictsIdsRef.current = [];\n        unackedOperationsRef.current = [];\n        if (preSyncReceivedOperationsRef.current.length > 0) {\n            applyRemoteOperationsToStores(preSyncReceivedOperationsRef.current, [\n                localStore,\n                remoteStore\n            ]);\n            preSyncReceivedOperationsRef.current = [];\n        }\n        if (localChanges.length > 0) {\n            applyRemoteOperationsToStores(localChanges, [\n                localStore\n            ]);\n            var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;\n            try {\n                for(var _iterator = localChanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){\n                    var request = _step.value;\n                    sendOperations(request);\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally{\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                    }\n                } finally{\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n        }\n        setSubscriptionStatus(\"Ready\" /* Ready */ );\n        subscriptionStatusRef.current = \"Ready\" /* Ready */ ;\n        setAvailabilityStatus(\"Ready\" /* Ready */ );\n        availabilityStatusRef.current = \"Ready\" /* Ready */ ;\n        markForLocalSaving();\n    }, []);\n    var onAckMessage = (0, import_react12.useCallback)(function(ack) {\n        if (subscriptionStatusRef.current !== \"Ready\" /* Ready */ ) {\n            return;\n        }\n        var request = unackedOperationsRef.current.find(function(r) {\n            return r.messageId === ack.ackMessageId;\n        });\n        for(var opIndex = 0; opIndex < request.operations.length; ++opIndex){\n            var _ack_opsMetadata;\n            var opMetadata = (_ack_opsMetadata = ack.opsMetadata) === null || _ack_opsMetadata === void 0 ? void 0 : _ack_opsMetadata[opIndex];\n            if (!opMetadata) {\n                continue;\n            }\n            var operation = request.operations[opIndex];\n            if (operation.op === \"insert\" && opMetadata.parentListIndex !== void 0) {\n                operation.parentListIndex = opMetadata.parentListIndex;\n                operation.value.parentListIndex = opMetadata.parentListIndex;\n            } else if (operation.op === \"replace\" && opMetadata.parentListIndex !== void 0) {\n                operation.value.parentListIndex = opMetadata.parentListIndex;\n            } else if (operation.op === \"move\" && opMetadata.index !== void 0) {\n                operation.index = opMetadata.index;\n            }\n            if (opMetadata.ignored) {\n                request.operations[opIndex] = void 0;\n            }\n        }\n        request.operations = request.operations.filter(function(o) {\n            return !!o;\n        });\n        unackedOperationsRef.current.splice(unackedOperationsRef.current.indexOf(request), 1);\n        applyRemoteOperationsToStores([\n            request\n        ], [\n            remoteStore\n        ]);\n        acknowledgeLocalChange(ack.ackMessageId);\n        if (unackedOperationsRef.current.length === 0) {\n            if (config.logging.conflicts) {\n                console.log(\"Resolving conflicts\");\n            }\n            localStore.resolveConflicts(conflictsIdsRef.current, remoteStore);\n            conflictsIdsRef.current = [];\n            if (config.logging.conflicts) {\n                var local = localStore.getRoot();\n                var remote = remoteStore.getRoot();\n                var storesEqual = areStoresEqual({\n                    document: local.document,\n                    fragment: local.fragment,\n                    fragmentIdToPath: local.fragmentIdToPath\n                }, {\n                    document: remote.document,\n                    fragment: remote.fragment,\n                    fragmentIdToPath: remote.fragmentIdToPath\n                });\n                if (!storesEqual.documentsEqual || !storesEqual.fragmentsEqual || !storesEqual.fragmentIdToPathsEqual) {\n                    console.warn(\"Conflicts not resolved. Remote and local are NOT equal!\", \"Previous request -> \", request);\n                    if (!storesEqual.documentsEqual) {\n                        console.warn(\"Documents not equal\", JSON.parse(JSON.stringify(local.document)), JSON.parse(JSON.stringify(remote.document)));\n                    }\n                    if (!storesEqual.fragmentsEqual) {\n                        console.warn(\"Fragments not equal\", JSON.parse(JSON.stringify(local.fragment)), JSON.parse(JSON.stringify(remote.fragment)));\n                    }\n                    if (!storesEqual.fragmentIdToPathsEqual) {\n                        console.warn(\"Fragment id to paths not equal\", JSON.parse(JSON.stringify(local.fragmentIdToPath)), JSON.parse(JSON.stringify(remote.fragmentIdToPath)));\n                    }\n                } else {\n                    console.log(\"Conflicts resolved, remote and local are equal.\");\n                }\n            }\n        }\n    }, []);\n    var onOpsMessage = (0, import_react12.useCallback)(function(message) {\n        if (subscriptionStatusRef.current === \"Subscribing\" /* Subscribing */ ) {\n            preSyncReceivedOperationsRef.current.push(message);\n            return;\n        }\n        if (subscriptionStatusRef.current !== \"Ready\" /* Ready */ ) {\n            return;\n        }\n        applyRemoteOperationsToStores([\n            message\n        ], [\n            localStore,\n            remoteStore\n        ]);\n        markForLocalSaving();\n    }, []);\n    var onDocumentMessage = (0, import_react12.useCallback)(function(message) {\n        if (message.docId !== documentIdRef.current) {\n            return;\n        }\n        switch(message.type){\n            case \"sync\":\n                {\n                    if (subscriptionIdRef.current !== message.subId) {\n                        return;\n                    }\n                    onSyncMessage(message.document);\n                }\n                break;\n            case \"ack\":\n                {\n                    var ackMessage = message;\n                    if (subscriptionIdRef.current !== ackMessage.subId) {\n                        return;\n                    }\n                    onAckMessage(ackMessage);\n                }\n                break;\n            case \"ops\":\n                {\n                    var documentOpsMessage = message;\n                    if (subscriptionIdRef.current === documentOpsMessage.clientSubId) {\n                        return;\n                    }\n                    onOpsMessage(documentOpsMessage);\n                }\n                break;\n            default:\n                console.warn(\"Document message with type '\".concat(message.type, \"' unhandled.\"));\n                break;\n        }\n    }, [\n        onSyncMessage,\n        onAckMessage,\n        onOpsMessage\n    ]);\n    var patch = (0, import_react12.useCallback)(function(fn) {\n        if (availabilityStatusRef.current !== \"Ready\" /* Ready */  && availabilityStatusRef.current !== \"ReadyLocal\" /* ReadyLocal */ ) {\n            console.warn(\"Cannot patch document when document edit status is \".concat(availabilityStatusRef.current, \".\"));\n            return;\n        }\n        localStore.patch(fn);\n    }, [\n        localStore\n    ]);\n    var groupMessagesOnSend = (0, import_react12.useCallback)(function(messages) {\n        var notOpsMessages = messages.filter(function(m) {\n            return m.type !== OpsMessageType;\n        });\n        var opsMessages = messages.filter(function(m) {\n            return m.type === OpsMessageType;\n        });\n        if (opsMessages.length === 0) {\n            return notOpsMessages;\n        }\n        var groupedMessages = [];\n        var opsMessagesBySubIdMap = groupBy(opsMessages, function(m) {\n            return m.subId;\n        });\n        opsMessagesBySubIdMap.forEach(function(opsMessagesBySubId, subId) {\n            var _instance;\n            if (subId !== subscriptionIdRef.current) {\n                opsMessagesBySubId = opsMessagesBySubId.filter(function(m) {\n                    return m.type !== OpsMessageType;\n                });\n            }\n            var operations = (_instance = []).concat.apply(_instance, _to_consumable_array(opsMessagesBySubId.map(function(m) {\n                return m.operations;\n            })));\n            var minifiedOperations = minifyOperations(operations);\n            if (minifiedOperations.length === 0) {\n                return;\n            }\n            for(var i = 0; i < minifiedOperations.length; i += MaxOpsPerMessage){\n                var chunk = minifiedOperations.slice(i, i + MaxOpsPerMessage);\n                groupedMessages.push({\n                    messageId: uniqueId(),\n                    type: OpsMessageType,\n                    subId: subId,\n                    operations: chunk\n                });\n            }\n        });\n        if (groupedMessages.length > 0) {\n            var _unackedOperationsRef_current;\n            var opsIndex = unackedOperationsRef.current.indexOf(opsMessages[0]);\n            (_unackedOperationsRef_current = unackedOperationsRef.current).splice.apply(_unackedOperationsRef_current, [\n                opsIndex < 0 ? 0 : opsIndex,\n                0\n            ].concat(_to_consumable_array(groupedMessages)));\n        }\n        updateLocalChanges({\n            removedChanges: opsMessages,\n            addedChanges: groupedMessages\n        });\n        unackedOperationsRef.current = unackedOperationsRef.current.filter(function(opMessage) {\n            return !opsMessages.includes(opMessage);\n        });\n        if (groupedMessages.length > 0) {\n            return _to_consumable_array(notOpsMessages).concat(_to_consumable_array(groupedMessages));\n        }\n        return notOpsMessages;\n    }, []);\n    var sendMessage = useChannel({\n        channel: \"document\",\n        onMessage: onDocumentMessage,\n        throttle: throttle,\n        groupMessagesOnSend: groupMessagesOnSend\n    }).sendMessage;\n    (0, import_react12.useEffect)(function() {\n        sendMessageRef.current = sendMessage;\n    }, [\n        sendMessage\n    ]);\n    var isOfflineCapable = (0, import_react12.useCallback)(function() {\n        return config.autosave.enabled && (availabilityStatusRef.current === \"Ready\" /* Ready */  || availabilityStatusRef.current === \"ReadyLocal\" /* ReadyLocal */ );\n    }, []);\n    var resetStoresToUnavailable = (0, import_react12.useCallback)(function() {\n        conflictsIdsRef.current = [];\n        unackedOperationsRef.current = [];\n        localStore.setRoot({\n            document: void 0,\n            fragment: void 0,\n            fragmentIdToPath: void 0\n        });\n        remoteStore.setRoot({\n            document: void 0,\n            fragment: void 0,\n            fragmentIdToPath: void 0\n        });\n        setAvailabilityStatus(\"Unready\" /* Unready */ );\n        availabilityStatusRef.current = \"Unready\" /* Unready */ ;\n        subscriptionIdRef.current = void 0;\n        subscribedToDocumentIdRef.current = void 0;\n    }, []);\n    var setStoreLocallyAvailable = (0, import_react12.useCallback)(function() {\n        setAvailabilityStatus(\"ReadyLocal\" /* ReadyLocal */ );\n        availabilityStatusRef.current = \"ReadyLocal\" /* ReadyLocal */ ;\n    }, []);\n    var subscribe = (0, import_react12.useCallback)(function(docId) {\n        subscriptionIdRef.current = uniqueId(5);\n        subscribedToDocumentIdRef.current = docId;\n        sendMessage({\n            messageId: uniqueId(),\n            type: \"subscribe\",\n            docId: subscribedToDocumentIdRef.current,\n            subId: subscriptionIdRef.current\n        });\n    }, []);\n    (0, import_react12.useEffect)(function() {\n        if (connectionStatus !== \"Open\" /* Open */ ) {\n            setSubscriptionStatus(\"Unready\" /* Unready */ );\n            subscriptionStatusRef.current = \"Unready\" /* Unready */ ;\n            if (!isOfflineCapable()) {\n                resetStoresToUnavailable();\n            } else {\n                setStoreLocallyAvailable();\n            }\n            return;\n        }\n        setSubscriptionStatus(\"Subscribing\" /* Subscribing */ );\n        subscriptionStatusRef.current = \"Subscribing\" /* Subscribing */ ;\n        return function() {\n            subscriptionIdRef.current = void 0;\n            subscribedToDocumentIdRef.current = void 0;\n        };\n    }, [\n        connectionStatus\n    ]);\n    (0, import_react12.useEffect)(function() {\n        documentIdRef.current = documentId;\n        if (subscriptionIdRef.current && connectionStatusRef.current === \"Open\" /* Open */ ) {\n            sendMessage({\n                messageId: uniqueId(),\n                type: \"unsubscribe\",\n                subId: subscriptionIdRef.current\n            });\n        }\n        resetStoresToUnavailable();\n        if (!documentId || connectionStatusRef.current !== \"Open\" /* Open */ ) {\n            setSubscriptionStatus(\"Unready\" /* Unready */ );\n            subscriptionStatusRef.current = \"Unready\" /* Unready */ ;\n            return;\n        }\n        if (subscriptionStatusRef.current === \"Subscribing\" /* Subscribing */ ) {\n            subscribe(documentId);\n        }\n        setSubscriptionStatus(\"Subscribing\" /* Subscribing */ );\n        subscriptionStatusRef.current = \"Subscribing\" /* Subscribing */ ;\n    }, [\n        documentId\n    ]);\n    (0, import_react12.useEffect)(function() {\n        if (subscriptionStatus !== \"Subscribing\" /* Subscribing */  || subscriptionIdRef.current !== void 0) {\n            return;\n        }\n        subscribe(documentIdRef.current);\n    }, [\n        subscriptionStatus\n    ]);\n    return {\n        subscriptionStatus: subscriptionStatus,\n        availabilityStatus: availabilityStatus,\n        useStore: localStore.useStore,\n        patch: patch,\n        subscribe: localStore.subscribe\n    };\n};\nvar groupBy = function(list, keyGetter) {\n    var map = /* @__PURE__ */ new Map();\n    list.forEach(function(item) {\n        var key = keyGetter(item);\n        var collection = map.get(key);\n        if (!collection) {\n            map.set(key, [\n                item\n            ]);\n        } else {\n            collection.push(item);\n        }\n    });\n    return map;\n};\n// src/useRealtimeDocument.ts\nvar RealtimeDocumentStatus = /* @__PURE__ */ function(RealtimeDocumentStatus3) {\n    RealtimeDocumentStatus3[\"Unready\"] = \"Unready\";\n    RealtimeDocumentStatus3[\"Ready\"] = \"Ready\";\n    return RealtimeDocumentStatus3;\n}(RealtimeDocumentStatus || {});\nvar useRealtimeDocument = function(param) {\n    var config = param.config, connectionStatus = param.connectionStatus, connectionStatusRef = param.connectionStatusRef, useChannel = param.useChannel, documentId = param.documentId, throttleOption = param.throttle;\n    var throttle = (0, import_react13.useMemo)(function() {\n        return getThrottle(throttleOption);\n    }, [\n        throttleOption\n    ]);\n    var _useDocumentChannel = useDocumentChannel({\n        config: config,\n        connectionStatus: connectionStatus,\n        connectionStatusRef: connectionStatusRef,\n        useChannel: useChannel,\n        documentId: documentId,\n        throttle: throttle\n    }), availabilityStatus = _useDocumentChannel.availabilityStatus, subscriptionStatus = _useDocumentChannel.subscriptionStatus, useStore = _useDocumentChannel.useStore, patch = _useDocumentChannel.patch, subscribe = _useDocumentChannel.subscribe;\n    var documentStatus = (0, import_react13.useMemo)(function() {\n        if (availabilityStatus === \"Ready\" /* Ready */  || availabilityStatus === \"ReadyLocal\" /* ReadyLocal */  || subscriptionStatus == \"Ready\" /* Ready */ ) {\n            return \"Ready\" /* Ready */ ;\n        }\n        return \"Unready\" /* Unready */ ;\n    }, [\n        availabilityStatus,\n        subscriptionStatus\n    ]);\n    return {\n        documentStatus: documentStatus,\n        useStore: useStore,\n        patch: patch,\n        subscribe: subscribe\n    };\n};\n// src/useRealtime.ts\nvar useRealtime = function(options) {\n    var _useRealtimeConnection = useRealtimeConnection(options), connectionStatus = _useRealtimeConnection.connectionStatus, connectionStatusRef = _useRealtimeConnection.connectionStatusRef, presenceStatus = _useRealtimeConnection.presenceStatus, config = _useRealtimeConnection.config, useChannel = _useRealtimeConnection.useChannel, useMe = _useRealtimeConnection.useMe, useCollaborators = _useRealtimeConnection.useCollaborators, useBroadcastListener = _useRealtimeConnection.useBroadcastListener, patchMe = _useRealtimeConnection.patchMe, subscribeCollaborators = _useRealtimeConnection.subscribeCollaborators, subscribeMe = _useRealtimeConnection.subscribeMe, broadcast = _useRealtimeConnection.broadcast;\n    var _useRealtimeDocument = useRealtimeDocument({\n        config: config,\n        connectionStatus: connectionStatus,\n        connectionStatusRef: connectionStatusRef,\n        useChannel: useChannel,\n        documentId: options.documentId,\n        throttle: options.throttle\n    }), documentStatus = _useRealtimeDocument.documentStatus, useStore = _useRealtimeDocument.useStore, patch = _useRealtimeDocument.patch, subscribe = _useRealtimeDocument.subscribe;\n    return {\n        documentStatus: documentStatus,\n        connectionStatus: connectionStatus,\n        presenceStatus: presenceStatus,\n        useStore: useStore,\n        patch: patch,\n        subscribe: subscribe,\n        useCollaborators: useCollaborators,\n        subscribeCollaborators: subscribeCollaborators,\n        useMe: useMe,\n        patchMe: patchMe,\n        subscribeMe: subscribeMe,\n        broadcast: broadcast,\n        useBroadcastListener: useBroadcastListener\n    };\n};\n// src/createRealtimeContext.tsx\nvar createRealtimeContext = function() {\n    var RealtimeContext = import_react14.default.createContext(null);\n    var RealtimeProvider = function(param) {\n        var children = param.children, documentId = param.documentId, getAuthToken = param.getAuthToken, publicAuthKey = param.publicAuthKey, autosave = param.autosave, throttle = param.throttle, _package = param._package;\n        var _useRealtime = useRealtime({\n            documentId: documentId,\n            getAuthToken: getAuthToken,\n            publicAuthKey: publicAuthKey,\n            autosave: autosave,\n            throttle: throttle,\n            _package: _package\n        }), connectionStatus = _useRealtime.connectionStatus, presenceStatus = _useRealtime.presenceStatus, documentStatus = _useRealtime.documentStatus, useStore2 = _useRealtime.useStore, patch = _useRealtime.patch, subscribe = _useRealtime.subscribe, useCollaborators2 = _useRealtime.useCollaborators, subscribeCollaborators = _useRealtime.subscribeCollaborators, useMe2 = _useRealtime.useMe, patchMe = _useRealtime.patchMe, subscribeMe = _useRealtime.subscribeMe, broadcast = _useRealtime.broadcast, useBroadcastListener2 = _useRealtime.useBroadcastListener;\n        return /* @__PURE__ */ import_react14.default.createElement(RealtimeContext.Provider, {\n            value: {\n                connectionStatus: connectionStatus,\n                documentStatus: documentStatus,\n                presenceStatus: presenceStatus,\n                useStore: useStore2,\n                patch: patch,\n                subscribe: subscribe,\n                useCollaborators: useCollaborators2,\n                subscribeCollaborators: subscribeCollaborators,\n                useMe: useMe2,\n                patchMe: patchMe,\n                subscribeMe: subscribeMe,\n                broadcast: broadcast,\n                useBroadcastListener: useBroadcastListener2\n            }\n        }, children);\n    };\n    var useRealtimeContext = function() {\n        return import_react14.default.useContext(RealtimeContext);\n    };\n    var useConnectionStatus = function() {\n        var connectionStatus = useRealtimeContext().connectionStatus;\n        if (connectionStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return connectionStatus;\n    };\n    var usePresenceStatus = function() {\n        var presenceStatus = useRealtimeContext().presenceStatus;\n        if (presenceStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return presenceStatus;\n    };\n    var useDocumentStatus = function() {\n        var documentStatus = useRealtimeContext().documentStatus;\n        if (documentStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return documentStatus;\n    };\n    var useStore = function(selector, equalityFn) {\n        var _useRealtimeContext = useRealtimeContext(), useStore2 = _useRealtimeContext.useStore;\n        if (useStore2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useStore2(selector, equalityFn) : useStore2();\n    };\n    var usePatch = function() {\n        var patch = useRealtimeContext().patch;\n        if (patch === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return patch;\n    };\n    var useSubscribe = function() {\n        var subscribe = useRealtimeContext().subscribe;\n        if (subscribe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribe;\n    };\n    var useCollaborators = function(selector, equalityFn) {\n        var _useRealtimeContext = useRealtimeContext(), useCollaborators2 = _useRealtimeContext.useCollaborators;\n        if (useCollaborators2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useCollaborators2(selector, equalityFn) : useCollaborators2();\n    };\n    var useSubscribeCollaborators = function() {\n        var subscribeCollaborators = useRealtimeContext().subscribeCollaborators;\n        if (subscribeCollaborators === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribeCollaborators;\n    };\n    var useMe = function(selector, equalityFn) {\n        var _useRealtimeContext = useRealtimeContext(), useMe2 = _useRealtimeContext.useMe;\n        if (useMe2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useMe2(selector, equalityFn) : useMe2();\n    };\n    var usePatchMe = function() {\n        var patchMe = useRealtimeContext().patchMe;\n        if (patchMe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return patchMe;\n    };\n    var useSubscribeMe = function() {\n        var subscribeMe = useRealtimeContext().subscribeMe;\n        if (subscribeMe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribeMe;\n    };\n    var useBroadcast = function() {\n        var broadcast = useRealtimeContext().broadcast;\n        if (broadcast === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return broadcast;\n    };\n    var useBroadcastListener = function(onEvent) {\n        var _useRealtimeContext = useRealtimeContext(), useBroadcastListener2 = _useRealtimeContext.useBroadcastListener;\n        if (useBroadcastListener2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return useBroadcastListener2(onEvent);\n    };\n    return {\n        RealtimeProvider: RealtimeProvider,\n        useRealtimeContext: useRealtimeContext,\n        useConnectionStatus: useConnectionStatus,\n        usePresenceStatus: usePresenceStatus,\n        useDocumentStatus: useDocumentStatus,\n        useStore: useStore,\n        usePatch: usePatch,\n        useSubscribe: useSubscribe,\n        useCollaborators: useCollaborators,\n        useSubscribeCollaborators: useSubscribeCollaborators,\n        useMe: useMe,\n        usePatchMe: usePatchMe,\n        useSubscribeMe: useSubscribeMe,\n        useBroadcast: useBroadcast,\n        useBroadcastListener: useBroadcastListener\n    };\n};\n// src/createRealtimeDocumentContext.tsx\nvar import_react15 = __toESM(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\nvar createRealtimeDocumentContext = function(param) {\n    var useRealtimeGroupContext = param.useRealtimeGroupContext;\n    var RealtimeDocumentContext = import_react15.default.createContext(null);\n    var RealtimeDocumentProvider = function(param) {\n        var children = param.children, documentId = param.documentId;\n        var _useRealtimeGroupContext = useRealtimeGroupContext(), connectionStatus = _useRealtimeGroupContext.connectionStatus, _package = _useRealtimeGroupContext._package;\n        if (_package === null) {\n            throw new Error(\"No RealtimeGroupProvider provided\");\n        }\n        var _useRealtimeDocument = useRealtimeDocument(_object_spread({\n            connectionStatus: connectionStatus,\n            documentId: documentId\n        }, _package)), documentStatus = _useRealtimeDocument.documentStatus, useStore2 = _useRealtimeDocument.useStore, patch = _useRealtimeDocument.patch, subscribe = _useRealtimeDocument.subscribe;\n        return /* @__PURE__ */ import_react15.default.createElement(RealtimeDocumentContext.Provider, {\n            value: {\n                documentStatus: documentStatus,\n                useStore: useStore2,\n                patch: patch,\n                subscribe: subscribe\n            }\n        }, children);\n    };\n    var useRealtimeDocumentContext = function() {\n        return import_react15.default.useContext(RealtimeDocumentContext);\n    };\n    var useDocumentStatus = function() {\n        var documentStatus = useRealtimeDocumentContext().documentStatus;\n        if (documentStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return documentStatus;\n    };\n    var useStore = function(selector, equalityFn) {\n        var _useRealtimeDocumentContext = useRealtimeDocumentContext(), useStore2 = _useRealtimeDocumentContext.useStore;\n        if (useStore2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useStore2(selector, equalityFn) : useStore2();\n    };\n    var usePatch = function() {\n        var patch = useRealtimeDocumentContext().patch;\n        if (patch === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return patch;\n    };\n    var useSubscribe = function() {\n        var subscribe = useRealtimeDocumentContext().subscribe;\n        if (subscribe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribe;\n    };\n    return {\n        RealtimeDocumentProvider: RealtimeDocumentProvider,\n        useRealtimeDocumentContext: useRealtimeDocumentContext,\n        useDocumentStatus: useDocumentStatus,\n        useStore: useStore,\n        usePatch: usePatch,\n        useSubscribe: useSubscribe\n    };\n};\n// src/createRealtimeGroupContext.tsx\nvar import_react16 = __toESM(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\nvar createRealtimeGroupContext = function() {\n    var RealtimeGroupContext = import_react16.default.createContext(null);\n    var RealtimeGroupProvider = function(param) {\n        var children = param.children, groupId = param.groupId, getAuthToken = param.getAuthToken, publicAuthKey = param.publicAuthKey, autosave = param.autosave, throttle = param.throttle, _package = param._package;\n        var _useRealtimeConnection = useRealtimeConnection({\n            groupId: groupId,\n            getAuthToken: getAuthToken,\n            publicAuthKey: publicAuthKey,\n            autosave: autosave,\n            throttle: throttle,\n            _package: _package\n        }), connectionStatus = _useRealtimeConnection.connectionStatus, connectionStatusRef = _useRealtimeConnection.connectionStatusRef, presenceStatus = _useRealtimeConnection.presenceStatus, useCollaborators2 = _useRealtimeConnection.useCollaborators, subscribeCollaborators = _useRealtimeConnection.subscribeCollaborators, useMe2 = _useRealtimeConnection.useMe, patchMe = _useRealtimeConnection.patchMe, subscribeMe = _useRealtimeConnection.subscribeMe, broadcast = _useRealtimeConnection.broadcast, useBroadcastListener2 = _useRealtimeConnection.useBroadcastListener, config = _useRealtimeConnection.config, useChannel = _useRealtimeConnection.useChannel;\n        return /* @__PURE__ */ import_react16.default.createElement(RealtimeGroupContext.Provider, {\n            value: {\n                connectionStatus: connectionStatus,\n                presenceStatus: presenceStatus,\n                useCollaborators: useCollaborators2,\n                subscribeCollaborators: subscribeCollaborators,\n                useMe: useMe2,\n                patchMe: patchMe,\n                subscribeMe: subscribeMe,\n                broadcast: broadcast,\n                useBroadcastListener: useBroadcastListener2,\n                _package: {\n                    config: config,\n                    useChannel: useChannel,\n                    connectionStatusRef: connectionStatusRef\n                }\n            }\n        }, children);\n    };\n    var useRealtimeGroupContext = function() {\n        return import_react16.default.useContext(RealtimeGroupContext);\n    };\n    var useConnectionStatus = function() {\n        var connectionStatus = useRealtimeGroupContext().connectionStatus;\n        if (connectionStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return connectionStatus;\n    };\n    var usePresenceStatus = function() {\n        var presenceStatus = useRealtimeGroupContext().presenceStatus;\n        if (presenceStatus === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return presenceStatus;\n    };\n    var useCollaborators = function(selector, equalityFn) {\n        var _useRealtimeGroupContext = useRealtimeGroupContext(), useCollaborators2 = _useRealtimeGroupContext.useCollaborators;\n        if (useCollaborators2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useCollaborators2(selector, equalityFn) : useCollaborators2();\n    };\n    var useSubscribeCollaborators = function() {\n        var subscribeCollaborators = useRealtimeGroupContext().subscribeCollaborators;\n        if (subscribeCollaborators === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribeCollaborators;\n    };\n    var useMe = function(selector, equalityFn) {\n        var _useRealtimeGroupContext = useRealtimeGroupContext(), useMe2 = _useRealtimeGroupContext.useMe;\n        if (useMe2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return selector ? useMe2(selector, equalityFn) : useMe2();\n    };\n    var usePatchMe = function() {\n        var patchMe = useRealtimeGroupContext().patchMe;\n        if (patchMe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return patchMe;\n    };\n    var useSubscribeMe = function() {\n        var subscribeMe = useRealtimeGroupContext().subscribeMe;\n        if (subscribeMe === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return subscribeMe;\n    };\n    var useBroadcast = function() {\n        var broadcast = useRealtimeGroupContext().broadcast;\n        if (broadcast === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return broadcast;\n    };\n    var useBroadcastListener = function(onEvent) {\n        var _useRealtimeGroupContext = useRealtimeGroupContext(), useBroadcastListener2 = _useRealtimeGroupContext.useBroadcastListener;\n        if (useBroadcastListener2 === null) {\n            throw new Error(\"No RealtimeProvider provided\");\n        }\n        return useBroadcastListener2(onEvent);\n    };\n    return {\n        RealtimeGroupProvider: RealtimeGroupProvider,\n        useRealtimeGroupContext: useRealtimeGroupContext,\n        useConnectionStatus: useConnectionStatus,\n        usePresenceStatus: usePresenceStatus,\n        useCollaborators: useCollaborators,\n        useSubscribeCollaborators: useSubscribeCollaborators,\n        useMe: useMe,\n        usePatchMe: usePatchMe,\n        useSubscribeMe: useSubscribeMe,\n        useBroadcast: useBroadcast,\n        useBroadcastListener: useBroadcastListener\n    };\n};\n// src/useAutosave.ts\nvar import_react17 = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar useAutosave = function(props) {\n    var config = (0, import_react17.useMemo)(function() {\n        return getAutosaveConfig({\n            enabled: true,\n            storeNamePostfix: props === null || props === void 0 ? void 0 : props.storeNamePostfix,\n            disableWarning: props === null || props === void 0 ? void 0 : props.disableWarning\n        });\n    }, []);\n    var autosaveDatabaseRef = (0, import_react17.useRef)();\n    (0, import_react17.useEffect)(function() {\n        var autosaveDatabase = getIndexedAutosaveInstance({\n            storeNamePostfix: config.storeNamePostfix,\n            disableWarning: config.disableWarning\n        });\n        var connect = function() {\n            var _ref = _async_to_generator(function() {\n                var enabled;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            return [\n                                4,\n                                autosaveDatabase.connect()\n                            ];\n                        case 1:\n                            enabled = _state.sent();\n                            if (!enabled) {\n                                return [\n                                    2\n                                ];\n                            }\n                            autosaveDatabaseRef.current = autosaveDatabase;\n                            return [\n                                2\n                            ];\n                    }\n                });\n            });\n            return function connect() {\n                return _ref.apply(this, arguments);\n            };\n        }();\n        connect().catch(function(error) {\n            console.error(error);\n        });\n        return function() {\n            autosaveDatabase.disconnect().catch(function(error) {\n                console.error(error);\n            });\n        };\n    }, []);\n    var createNewDocument = (0, import_react17.useCallback)(function() {\n        var _ref = _async_to_generator(function(param) {\n            var documentId, document, documentMetadata, fragment;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        documentId = param.documentId, document = param.document;\n                        if (!autosaveDatabaseRef.current) {\n                            console.warn(\"Autosave database not initialized\");\n                            return [\n                                2\n                            ];\n                        }\n                        documentMetadata = {\n                            localOnly: true,\n                            unsavedChanges: true\n                        };\n                        fragment = documentToFragment(document);\n                        return [\n                            4,\n                            autosaveDatabaseRef.current.saveDocumentMetadata({\n                                documentId: documentId,\n                                documentMetadata: documentMetadata\n                            })\n                        ];\n                    case 1:\n                        _state.sent();\n                        return [\n                            4,\n                            autosaveDatabaseRef.current.saveFragment({\n                                documentId: documentId,\n                                fragment: fragment\n                            })\n                        ];\n                    case 2:\n                        _state.sent();\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n        return function(_) {\n            return _ref.apply(this, arguments);\n        };\n    }(), []);\n    return {\n        createNewDocument: createNewDocument\n    };\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BpbnJlYWx0aW1lL3JlYWN0L2Rpc3QvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtCQUErQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLG1GQUFtRixnRUFBZ0U7QUFDbkosVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixtQkFBTyxDQUFDLGdEQUFPO0FBQ25DO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsZ0RBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxnREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsZ0RBQU87QUFDcEM7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxnREFBTztBQUNwQztBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdEQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLG1FQUFtRTtBQUNwSjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNkJBQTZCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFPLENBQUMsZ0RBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBTyxDQUFDLGdEQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLGdEQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLENBU0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9AaW5yZWFsdGltZS9yZWFjdC9kaXN0L2luZGV4LmpzP2Y4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfYXJyYXlfd2l0aF9ob2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KGFycik7XG59XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfY2xhc3NfY2FsbF9jaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVfY2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0ICE9IG51bGwgJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgIHJldHVybiAhIXJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0obGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG59XG5mdW5jdGlvbiBfaXRlcmFibGVfdG9fYXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoX2kgPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBfYXJyID0gW107XG4gICAgdmFyIF9uID0gdHJ1ZTtcbiAgICB2YXIgX2QgPSBmYWxzZTtcbiAgICB2YXIgX3MsIF9lO1xuICAgIHRyeSB7XG4gICAgICAgIGZvcihfaSA9IF9pLmNhbGwoYXJyKTsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSl7XG4gICAgICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kID0gdHJ1ZTtcbiAgICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xufVxuZnVuY3Rpb24gX25vbl9pdGVyYWJsZV9yZXN0KCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cbmZ1bmN0aW9uIF9ub25faXRlcmFibGVfc3ByZWFkKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXFxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5mdW5jdGlvbiBfb2JqZWN0X2Rlc3RydWN0dXJpbmdfZW1wdHkobykge1xuICAgIGlmIChvID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBkZXN0cnVjdHVyZSBcIiArIG8pO1xuICAgIHJldHVybiBvO1xufVxuZnVuY3Rpb24gX29iamVjdF9zcHJlYWQodGFyZ2V0KSB7XG4gICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICB2YXIgb3duS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBvd25LZXlzID0gb3duS2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBvd25LZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBfZGVmaW5lX3Byb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xuICAgICAgICBpZiAoZW51bWVyYWJsZU9ubHkpIHtcbiAgICAgICAgICAgIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbihzeW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0X3NwcmVhZF9wcm9wcyh0YXJnZXQsIHNvdXJjZSkge1xuICAgIHNvdXJjZSA9IHNvdXJjZSAhPSBudWxsID8gc291cmNlIDoge307XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9zbGljZWRfdG9fYXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheV93aXRoX2hvbGVzKGFycikgfHwgX2l0ZXJhYmxlX3RvX2FycmF5X2xpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KGFyciwgaSkgfHwgX25vbl9pdGVyYWJsZV9yZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9fY29uc3VtYWJsZV9hcnJheShhcnIpIHtcbiAgICByZXR1cm4gX2FycmF5X3dpdGhvdXRfaG9sZXMoYXJyKSB8fCBfaXRlcmFibGVfdG9fYXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkoYXJyKSB8fCBfbm9uX2l0ZXJhYmxlX3NwcmVhZCgpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkX2l0ZXJhYmxlX3RvX2FycmF5KG8sIG1pbkxlbikge1xuICAgIGlmICghbykgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheV9saWtlX3RvX2FycmF5KG8sIG1pbkxlbik7XG4gICAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICAgIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obik7XG4gICAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuKGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwKFtcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgIHZcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUoXyl0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtcbiAgICAgICAgICAgICAgICBvcFswXSAmIDIsXG4gICAgICAgICAgICAgICAgdC52YWx1ZVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHN3aXRjaChvcFswXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvcFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICBfLmxhYmVsKys7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgb3AgPSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfLmxhYmVsID0gb3BbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSB0WzJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5vcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb3AgPSBbXG4gICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICBlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGYgPSB0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbn1cbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSBmdW5jdGlvbih0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpX19kZWZQcm9wKHRhcmdldCwgbmFtZSwge1xuICAgICAgICBnZXQ6IGFsbFtuYW1lXSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9IGZ1bmN0aW9uKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpIHtcbiAgICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdCkgX19kZWZQcm9wKHRvLCBrZXksIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfX2dldE93blByb3BOYW1lcyhmcm9tKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpX2xvb3AoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSBmdW5jdGlvbihtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcygvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gICAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgICAvLyBjb21wYXRpYmxlIHRyYW5zZm9ybSAoaS5lLiBcIl9fZXNNb2R1bGVcIiBoYXMgbm90IGJlZW4gc2V0KSwgdGhlbiBzZXRcbiAgICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gICAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7XG4gICAgICAgIHZhbHVlOiBtb2QsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KSA6IHRhcmdldCwgbW9kKTtcbn07XG52YXIgX190b0NvbW1vbkpTID0gZnVuY3Rpb24obW9kKSB7XG4gICAgcmV0dXJuIF9fY29weVByb3BzKF9fZGVmUHJvcCh7fSwgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICAgICAgdmFsdWU6IHRydWVcbiAgICB9KSwgbW9kKTtcbn07XG4vLyBzcmMvaW5kZXgudHNcbnZhciBzcmNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3JjX2V4cG9ydHMsIHtcbiAgICBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUmVhbHRpbWVDb25uZWN0aW9uU3RhdHVzO1xuICAgIH0sXG4gICAgUmVhbHRpbWVEb2N1bWVudFN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFsdGltZURvY3VtZW50U3RhdHVzO1xuICAgIH0sXG4gICAgUmVhbHRpbWVQcmVzZW5jZVN0YXR1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFsdGltZVByZXNlbmNlU3RhdHVzO1xuICAgIH0sXG4gICAgY3JlYXRlUmVhbHRpbWVDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlYWx0aW1lQ29udGV4dDtcbiAgICB9LFxuICAgIGNyZWF0ZVJlYWx0aW1lRG9jdW1lbnRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlYWx0aW1lRG9jdW1lbnRDb250ZXh0O1xuICAgIH0sXG4gICAgY3JlYXRlUmVhbHRpbWVHcm91cENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVhbHRpbWVHcm91cENvbnRleHQ7XG4gICAgfSxcbiAgICB1c2VBdXRvc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VBdXRvc2F2ZTtcbiAgICB9LFxuICAgIHVzZVJlYWx0aW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZVJlYWx0aW1lO1xuICAgIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBfX3RvQ29tbW9uSlMoc3JjX2V4cG9ydHMpO1xuLy8gc3JjL2NoYW5uZWxzL3ByZXNlbmNlL3VzZVByZXNlbmNlLnRzXG52YXIgaW1wb3J0X3JlYWN0NCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbi8vIHNyYy9hdXRoL3VzZUF1dGgudHNcbnZhciBpbXBvcnRfcmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgQXV0aGVudGljYXRpb25FcnJvckV4cG9uZW50aWFsVGltZXJTdGFydCA9IDFlMztcbnZhciBBdXRoZW50aWNhdGlvbkVycm9yRXhwb25lbnRpYWxUaW1lck1heCA9IDhlMztcbnZhciBSZUF1dGhlbnRpY2F0aW9uVGltZUJlZm9yZVRva2VuRXhwaXJ5ID0gMi41ICogNjAgKiAxZTM7XG52YXIgZ2V0Snd0UGF5bG9hZCA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgdmFyIGJhc2U2NFVybCA9IHRva2VuLnNwbGl0KFwiLlwiKVsxXTtcbiAgICB2YXIgYmFzZTY0ID0gYmFzZTY0VXJsLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIHZhciBqc29uUGF5bG9hZCA9IGRlY29kZVVSSUNvbXBvbmVudChhdG9iKGJhc2U2NCkuc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiJVwiICsgKFwiMDBcIiArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC0yKTtcbiAgICB9KS5qb2luKFwiXCIpKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShqc29uUGF5bG9hZCk7XG59O1xudmFyIGF1dGhlbnRpY2F0ZUZuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgIHZhciByZWFsdGltZUF1dGgsIGRvY3VtZW50SWQsIGdyb3VwSWQsIF9yZWYsIHNvY2tldFVybCwgdG9rZW4sIHByb2plY3RJZCwgdG9rZW5QYXlsb2FkLCB0b2tlbkV4cGlyeVRpbWU7XG4gICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICByZWFsdGltZUF1dGggPSBwYXJhbS5yZWFsdGltZUF1dGgsIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkLCBncm91cElkID0gcGFyYW0uZ3JvdXBJZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsdGltZUF1dGguYXV0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cElkOiBncm91cElkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgX3JlZiA9IF9zdGF0ZS5zZW50KCksIHNvY2tldFVybCA9IF9yZWYuc29ja2V0VXJsLCB0b2tlbiA9IF9yZWYudG9rZW4sIHByb2plY3RJZCA9IF9yZWYucHJvamVjdElkO1xuICAgICAgICAgICAgICAgICAgICB0b2tlblBheWxvYWQgPSBnZXRKd3RQYXlsb2FkKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FeHBpcnlUaW1lID0gdG9rZW5QYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29ja2V0VXJsOiBzb2NrZXRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuRXhwaXJ5VGltZTogdG9rZW5FeHBpcnlUaW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZDogcHJvamVjdElkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiBhdXRoZW50aWNhdGVGbihfKSB7XG4gICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0oKTtcbnZhciB1c2VBdXRoID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgY29uZmlnID0gcGFyYW0uY29uZmlnLCBkb2N1bWVudElkID0gcGFyYW0uZG9jdW1lbnRJZCwgZ3JvdXBJZCA9IHBhcmFtLmdyb3VwSWQsIGdldEF1dGhUb2tlbiA9IHBhcmFtLmdldEF1dGhUb2tlbiwgcHVibGljQXV0aEtleSA9IHBhcmFtLnB1YmxpY0F1dGhLZXk7XG4gICAgdmFyIF9yZWYgPSBfc2xpY2VkX3RvX2FycmF5KCgwLCBpbXBvcnRfcmVhY3QudXNlU3RhdGUpKHt9KSwgMiksIGF1dGhEYXRhID0gX3JlZlswXSwgc2V0QXV0aERhdGEgPSBfcmVmWzFdO1xuICAgIHZhciBfcmVmMSA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdC51c2VTdGF0ZSkoXCJBdXRoZW50aWNhdGluZ1wiIC8qIEF1dGhlbnRpY2F0aW5nICovICksIDIpLCBzdGF0dXMgPSBfcmVmMVswXSwgc2V0U3RhdHVzID0gX3JlZjFbMV07XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZF90b19hcnJheSgoMCwgaW1wb3J0X3JlYWN0LnVzZVN0YXRlKSgwKSwgMiksIGV4cG9uZW50aWFsVGltZXIgPSBfcmVmMlswXSwgc2V0RXhwb25lbnRpYWxUaW1lciA9IF9yZWYyWzFdO1xuICAgIHZhciByZWFsdGltZUF1dGggPSAoMCwgaW1wb3J0X3JlYWN0LnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlYWx0aW1lQXV0aCh7XG4gICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIGdldEF1dGhUb2tlbjogZ2V0QXV0aFRva2VuLFxuICAgICAgICAgICAgcHVibGljQXV0aEtleTogcHVibGljQXV0aEtleVxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIGdldEF1dGhUb2tlbixcbiAgICAgICAgcHVibGljQXV0aEtleVxuICAgIF0pO1xuICAgIHZhciBhdXRoZW50aWNhdGUgPSAoMCwgaW1wb3J0X3JlYWN0LnVzZUNhbGxiYWNrKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0ZUZuKHtcbiAgICAgICAgICAgIHJlYWx0aW1lQXV0aDogcmVhbHRpbWVBdXRoLFxuICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IGdyb3VwSWRcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICByZWFsdGltZUF1dGgsXG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGdyb3VwSWRcbiAgICBdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IFwiRXJyb3JcIiAvKiBFcnJvciAqLyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldFN0YXR1cyhcIkF1dGhlbnRpY2F0aW5nXCIgLyogQXV0aGVudGljYXRpbmcgKi8gKTtcbiAgICAgICAgfSwgZXhwb25lbnRpYWxUaW1lcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBleHBvbmVudGlhbFRpbWVyLFxuICAgICAgICBzZXRTdGF0dXNcbiAgICBdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IFwiQXV0aGVudGljYXRlZFwiIC8qIEF1dGhlbnRpY2F0ZWQgKi8gIHx8IGF1dGhEYXRhLnRva2VuRXhwaXJ5VGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IGF1dGhEYXRhLnRva2VuRXhwaXJ5VGltZSAtIERhdGUubm93KCkgLyAxZTMgLSBSZUF1dGhlbnRpY2F0aW9uVGltZUJlZm9yZVRva2VuRXhwaXJ5IC8gMWUzO1xuICAgICAgICAgICAgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdHVzKFwiQXV0aGVudGljYXRpbmdcIiAvKiBBdXRoZW50aWNhdGluZyAqLyApO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5zb2NrZXRTdGF0dXMpIGNvbnNvbGUubG9nKFwiQXV0aCBzdGF0dXMgLT4gQXV0aGVudGljYXRpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDVlMyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBhdXRoRGF0YSxcbiAgICAgICAgc2V0U3RhdHVzXG4gICAgXSk7XG4gICAgKDAsIGltcG9ydF9yZWFjdC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBcIkF1dGhlbnRpY2F0ZWRcIiAvKiBBdXRoZW50aWNhdGVkICovICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudElkID09PSB2b2lkIDAgJiYgZ3JvdXBJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50SWQgIT09IHZvaWQgMCAmJiBhdXRoRGF0YS5kb2N1bWVudElkID09PSBkb2N1bWVudElkIHx8IGdyb3VwSWQgIT09IHZvaWQgMCAmJiBhdXRoRGF0YS5ncm91cElkID09PSBncm91cElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0QXV0aERhdGEoe30pO1xuICAgICAgICBzZXRTdGF0dXMoXCJBdXRoZW50aWNhdGluZ1wiIC8qIEF1dGhlbnRpY2F0aW5nICovICk7XG4gICAgICAgIHNldEV4cG9uZW50aWFsVGltZXIoMCk7XG4gICAgfSwgW1xuICAgICAgICBzdGF0dXMsXG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGdyb3VwSWRcbiAgICBdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkb2N1bWVudElkID09PSB2b2lkIDAgJiYgZ3JvdXBJZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzZXRBdXRoRGF0YSh7fSk7XG4gICAgICAgICAgICBzZXRTdGF0dXMoXCJBdXRoZW50aWNhdGluZ1wiIC8qIEF1dGhlbnRpY2F0aW5nICovICk7XG4gICAgICAgICAgICBzZXRFeHBvbmVudGlhbFRpbWVyKDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgIT09IFwiQXV0aGVudGljYXRpbmdcIiAvKiBBdXRoZW50aWNhdGluZyAqLyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhdXRoZW50aWNhdGUoKS50aGVuKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgc29ja2V0VXJsID0gcGFyYW0uc29ja2V0VXJsLCB0b2tlbiA9IHBhcmFtLnRva2VuLCB0b2tlbkV4cGlyeVRpbWUgPSBwYXJhbS50b2tlbkV4cGlyeVRpbWUsIHByb2plY3RJZCA9IHBhcmFtLnByb2plY3RJZDtcbiAgICAgICAgICAgIHNldEF1dGhEYXRhKHtcbiAgICAgICAgICAgICAgICBzb2NrZXRVcmw6IHNvY2tldFVybCxcbiAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgdG9rZW5FeHBpcnlUaW1lOiB0b2tlbkV4cGlyeVRpbWUsXG4gICAgICAgICAgICAgICAgcHJvamVjdElkOiBwcm9qZWN0SWQsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCxcbiAgICAgICAgICAgICAgICBncm91cElkOiBncm91cElkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFN0YXR1cyhcIkF1dGhlbnRpY2F0ZWRcIiAvKiBBdXRoZW50aWNhdGVkICovICk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSBjb25zb2xlLmxvZyhcIkF1dGggc3RhdHVzIC0+IEF1dGhlbnRpY2F0ZWRcIik7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICBzZXRTdGF0dXMoXCJFcnJvclwiIC8qIEVycm9yICovICk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSBjb25zb2xlLmxvZyhcIkF1dGggc3RhdHVzJyAtPiBFcnJvclwiKTtcbiAgICAgICAgICAgIHZhciBuZXdFeHBvbmVudGlhbFRpbWVyID0gTWF0aC5taW4oQXV0aGVudGljYXRpb25FcnJvckV4cG9uZW50aWFsVGltZXJNYXgsIGV4cG9uZW50aWFsVGltZXIgPCBBdXRoZW50aWNhdGlvbkVycm9yRXhwb25lbnRpYWxUaW1lclN0YXJ0ID8gQXV0aGVudGljYXRpb25FcnJvckV4cG9uZW50aWFsVGltZXJTdGFydCA6IGV4cG9uZW50aWFsVGltZXIgKiAyKTtcbiAgICAgICAgICAgIHNldEV4cG9uZW50aWFsVGltZXIobmV3RXhwb25lbnRpYWxUaW1lcik7XG4gICAgICAgIH0pO1xuICAgIH0sIFtcbiAgICAgICAgc3RhdHVzLFxuICAgICAgICBhdXRoZW50aWNhdGUsXG4gICAgICAgIGRvY3VtZW50SWQsXG4gICAgICAgIGdyb3VwSWRcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgc29ja2V0VXJsOiBhdXRoRGF0YS5zb2NrZXRVcmwsXG4gICAgICAgIHRva2VuOiBhdXRoRGF0YS50b2tlbixcbiAgICAgICAgcHJvamVjdElkOiBhdXRoRGF0YS5wcm9qZWN0SWRcbiAgICB9O1xufTtcbi8vIHNyYy9jb3JlL2F1dGgvcmVhbHRpbWVBdXRoLnRzXG52YXIgUmVhbHRpbWVBdXRoID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSZWFsdGltZUF1dGgocGFyYW0pIHtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHBhcmFtLmNvbmZpZywgZ2V0QXV0aFRva2VuID0gcGFyYW0uZ2V0QXV0aFRva2VuLCBwdWJsaWNBdXRoS2V5ID0gcGFyYW0ucHVibGljQXV0aEtleTtcbiAgICAgICAgX2NsYXNzX2NhbGxfY2hlY2sodGhpcywgUmVhbHRpbWVBdXRoKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLl9nZXRBdXRoVG9rZW4gPSBnZXRBdXRoVG9rZW47XG4gICAgICAgIHRoaXMuX3B1YmxpY0F1dGhLZXkgPSBwdWJsaWNBdXRoS2V5O1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKFJlYWx0aW1lQXV0aCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiYXV0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF1dGgocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRJZCA9IHBhcmFtLmRvY3VtZW50SWQsIGdyb3VwSWQgPSBwYXJhbS5ncm91cElkO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiwgcmVzcG9uc2UsIHRva2VuUGF5bG9hZCwgcHJvamVjdElkLCBzb2NrZXRVcmw7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9nZXRBdXRoVG9rZW4pIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9nZXRBdXRoVG9rZW4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJZDogZ3JvdXBJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9wdWJsaWNBdXRoS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJCb3RoICdnZXRBdXRoVG9rZW4nIGFuZCAncHVibGljQXV0aEtleScgd2VyZSBwcm92aWRlZC4gJ2dldEF1dGhUb2tlbicgd2lsbCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX3B1YmxpY0F1dGhLZXkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLl9wdWJsaWNBdXRoS2V5LnN0YXJ0c1dpdGgoXCJwdWJsaWNfXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkICdwdWJsaWNBdXRoS2V5Jy4gSXQgc2hvdWxkIHN0YXJ0IHdpdGggJ3B1YmxpY18nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZldGNoKF90aGlzLl9jb25maWcuYXV0aFVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoS2V5OiBfdGhpcy5fcHVibGljQXV0aEtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcImluY2x1ZGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAxIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgYSB3cm9uZyAncHVibGljQXV0aEtleScgd2FzIHByb3ZpZGVkIG9yICdwdWJsaWNBdXRoS2V5JyBpcyBub3QgZW5hYmxlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gX3N0YXRlLnNlbnQoKS50b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFaXRoZXIgJ2dldEF1dGhUb2tlbicgb3IgJ3B1YmxpY0F1dGhLZXknIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5QYXlsb2FkID0gZ2V0Snd0UGF5bG9hZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RJZCA9IHRva2VuUGF5bG9hZC5wcm9qZWN0SWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldFVybCA9IGdyb3VwSWQgIT09IHZvaWQgMCA/IFwiXCIuY29uY2F0KF90aGlzLl9jb25maWcud2ViU29ja2V0VXJsLCBcIi9wcm9qZWN0cy9cIikuY29uY2F0KHByb2plY3RJZCwgXCIvZ3JvdXBzL1wiKS5jb25jYXQoZ3JvdXBJZCkgOiBcIlwiLmNvbmNhdChfdGhpcy5fY29uZmlnLndlYlNvY2tldFVybCwgXCIvcHJvamVjdHMvXCIpLmNvbmNhdChwcm9qZWN0SWQsIFwiL2RvY3VtZW50cy9cIikuY29uY2F0KGRvY3VtZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXRVcmw6IHNvY2tldFVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0SWQ6IHByb2plY3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoRXhwaXJ5VGltZTogdG9rZW5QYXlsb2FkLmV4cCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbjogdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSZWFsdGltZUF1dGg7XG59KCk7XG4vLyBzcmMvY29yZS9zb2NrZXQvcmVhbHRpbWVXZWJzb2NrZXQudHNcbnZhciBzb2NrZXRUaW1lb3V0ID0gMTVlMztcbnZhciBSZWFsdGltZVdlYlNvY2tldCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWVXZWJTb2NrZXQocGFyYW0pIHtcbiAgICAgICAgdmFyIG9uT3BlbiA9IHBhcmFtLm9uT3Blbiwgb25Db25uZWN0aW5nID0gcGFyYW0ub25Db25uZWN0aW5nLCBvbkNsb3NlID0gcGFyYW0ub25DbG9zZSwgb25NZXNzYWdlID0gcGFyYW0ub25NZXNzYWdlLCBjb25maWcgPSBwYXJhbS5jb25maWc7XG4gICAgICAgIF9jbGFzc19jYWxsX2NoZWNrKHRoaXMsIFJlYWx0aW1lV2ViU29ja2V0KTtcbiAgICAgICAgdGhpcy5fb25PcGVuID0gb25PcGVuO1xuICAgICAgICB0aGlzLl9vbkNvbm5lY3RpbmcgPSBvbkNvbm5lY3Rpbmc7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UgPSBvbkNsb3NlO1xuICAgICAgICB0aGlzLl9vbk1lc3NhZ2UgPSBvbk1lc3NhZ2U7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhSZWFsdGltZVdlYlNvY2tldCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2V0U29ja2V0VXJsXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U29ja2V0VXJsKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNvY2tldFVybCA9IHBhcmFtLnNvY2tldFVybDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrZXRVcmwgPSBzb2NrZXRVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJfanNvblN0cmluZ2lmeVJlcGxhY2VyXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2pzb25TdHJpbmdpZnlSZXBsYWNlcihrLCB2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPT09IHZvaWQgMCA/IG51bGwgOiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2VuZE1lc3NhZ2VcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kTWVzc2FnZShjaGFubmVsLCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX193ZWJTb2NrZXQsIF90aGlzX193ZWJTb2NrZXQxO1xuICAgICAgICAgICAgICAgIGlmICgoKF90aGlzX193ZWJTb2NrZXQgPSB0aGlzLl93ZWJTb2NrZXQpID09PSBudWxsIHx8IF90aGlzX193ZWJTb2NrZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX193ZWJTb2NrZXQucmVhZHlTdGF0ZSkgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF90aGlzX193ZWJTb2NrZXQxID0gdGhpcy5fd2ViU29ja2V0KSA9PT0gbnVsbCB8fCBfdGhpc19fd2ViU29ja2V0MSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfX3dlYlNvY2tldDEuc2VuZChcIlwiLmNvbmNhdChjaGFubmVsLCBcIjpcIikuY29uY2F0KEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIHRoaXMuX2pzb25TdHJpbmdpZnlSZXBsYWNlcikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNsb3NlXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2xvc2UodGhpcy5fd2ViU29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIl9jbG9zZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jbG9zZSh3ZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dFRpbWVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXdlYlNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgd2ViU29ja2V0LmNsb3NlKDFlMywgXCJDbG9zaW5nIHNvY2tldCBtYW51YWxseVwiKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NvY2tldFVybCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHNvY2tldCB1cmwuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgd2ViU29ja2V0ID0gbmV3IFdlYlNvY2tldCh0aGlzLl9zb2NrZXRVcmwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlYlNvY2tldCA9IHdlYlNvY2tldDtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UmVjZWl2ZWRNZXNzYWdlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dFRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3cgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdy5nZXRUaW1lKCkgLSBfdGhpcy5fbGFzdFJlY2VpdmVkTWVzc2FnZS5nZXRUaW1lKCkgPiBzb2NrZXRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoX3RoaXNfX2NvbmZpZyA9IF90aGlzLl9jb25maWcpID09PSBudWxsIHx8IF90aGlzX19jb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX19jb25maWcubG9nZ2luZy5zb2NrZXRTdGF0dXMpIGNvbnNvbGUubG9nKFwiQ2xvc2luZyBzb2NrZXQgaW4gdGltZW91dCB0aW1lclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZSh3ZWJTb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgc29ja2V0VGltZW91dCAvIDIpO1xuICAgICAgICAgICAgICAgIHdlYlNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9vbk9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbk9wZW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2ViU29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX29uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgZS5jb2RlID09PSAzZTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICdcIi5jb25jYXQoZS5jb2RlLCBcIicsIHR5cGUgJ1wiKS5jb25jYXQoZS50eXBlLCBcIicgYW5kIHJlYXNvbiAnXCIpLmNvbmNhdChlLnJlYXNvbiwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKF90aGlzX19jb25maWcgPSBfdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19fY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNvY2tldCBjbG9zZWQgd2l0aCBjb2RlICdcIi5jb25jYXQoZS5jb2RlLCBcIicsIHR5cGUgJ1wiKS5jb25jYXQoZS50eXBlLCBcIicgYW5kIHJlYXNvbiAnXCIpLmNvbmNhdChlLnJlYXNvbiwgXCInLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdlYlNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF90aGlzX19jb25maWcgPSBfdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19fY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSBjb25zb2xlLmxvZyhcIkNsb3Npbmcgc29ja2V0IGluIG9uRXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9jbG9zZSh3ZWJTb2NrZXQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgd2ViU29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fb25NZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIklnbm9yZWQgbWVzc2FnZSAnXCIuY29uY2F0KGUuZGF0YSwgXCInIGFzIG5vIG9uTWVzc2FnZSBob29rIHdhcyBmb3VuZC5cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0UmVjZWl2ZWRNZXNzYWdlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bnBhcnNlZE1lc3NhZ2UgPSBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1bnBhcnNlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXhPZkNvbG9uID0gdW5wYXJzZWRNZXNzYWdlLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXhPZkNvbG9uIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgZm9ybWF0dGVkIG1lc3NhZ2UgZnJvbSBzZXJ2ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFubmVsID0gdW5wYXJzZWRNZXNzYWdlLnN1YnN0cmluZygwLCBpbmRleE9mQ29sb24pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZVN0ciA9IHVucGFyc2VkTWVzc2FnZS5zdWJzdHJpbmcoaW5kZXhPZkNvbG9uICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UobWVzc2FnZVN0cik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBKU09OIGluIG1lc3NhZ2UgZnJvbSBzZXJ2ZXIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9vbk1lc3NhZ2UoY2hhbm5lbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fb25Db25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ29ubmVjdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSZWFsdGltZVdlYlNvY2tldDtcbn0oKTtcbi8vIHNyYy9jb3JlL3R5cGVzL2RvY3VtZW50T3BlcmF0aW9uLnRzXG52YXIgRG9jdW1lbnRPcGVyYXRpb25Sb290ID0gXCJyb290XCI7XG52YXIgRG9jdW1lbnRPcGVyYXRpb25JbnNlcnQgPSBcImluc2VydFwiO1xudmFyIERvY3VtZW50T3BlcmF0aW9uUmVwbGFjZSA9IFwicmVwbGFjZVwiO1xudmFyIERvY3VtZW50T3BlcmF0aW9uTW92ZSA9IFwibW92ZVwiO1xuLy8gc3JjL2NvcmUvdXRpbHMvdHlwZVV0aWxzLnRzXG52YXIgY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZShhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgX3BhcmFtID0gX3NsaWNlZF90b19hcnJheShwYXJhbSwgMiksIGsgPSBfcGFyYW1bMF0sIHYgPSBfcGFyYW1bMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkKHt9LCBwcmV2KSwgX2RlZmluZV9wcm9wZXJ0eSh7fSwgaywgY2xvbmUodikpKTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcbnZhciBpc01hcCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhX2luc3RhbmNlb2YodmFsdWUsIEFycmF5KSAmJiAhX2luc3RhbmNlb2YodmFsdWUsIERhdGUpO1xufTtcbnZhciBpc0xpc3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKTtcbn07XG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID09PSB2YWx1ZTtcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgX2luc3RhbmNlb2YodmFsdWUsIFN0cmluZyk7XG59O1xudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59O1xudmFyIGxpc3RzU2hhbGxvd0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBsaXN0c1NoYWxsb3dTdGFydHNXaXRoID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChhLmxlbmd0aCA+IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vLyBzcmMvY29yZS91dGlscy91bmlxdWVJZC50c1xudmFyIHVybEFscGhhYmV0ID0gXCJ1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0XCI7XG52YXIgdW5pcXVlSWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdm9pZCAwID8gYXJndW1lbnRzWzBdIDogMTA7XG4gICAgdmFyIGlkID0gXCJcIjtcbiAgICB2YXIgaSA9IHNpemU7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgaWQgKz0gdXJsQWxwaGFiZXRbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG4vLyBzcmMvc29ja2V0L3R5cGVzLnRzXG52YXIgUmVhbHRpbWVDb25uZWN0aW9uU3RhdHVzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFJlYWx0aW1lQ29ubmVjdGlvblN0YXR1czIpIHtcbiAgICBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXMyW1wiQ2xvc2VkXCJdID0gXCJDbG9zZWRcIjtcbiAgICBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXMyW1wiQ29ubmVjdGluZ1wiXSA9IFwiQ29ubmVjdGluZ1wiO1xuICAgIFJlYWx0aW1lQ29ubmVjdGlvblN0YXR1czJbXCJBdXRoZW50aWNhdGluZ1wiXSA9IFwiQXV0aGVudGljYXRpbmdcIjtcbiAgICBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXMyW1wiT3BlblwiXSA9IFwiT3BlblwiO1xuICAgIHJldHVybiBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXMyO1xufShSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXMgfHwge30pO1xuLy8gc3JjL2NoYW5uZWxzL3ByZXNlbmNlL3VzZUNvbGxhYm9yYXRvclN0b3JlLnRzXG52YXIgaW1wb3J0X3JlYWN0MiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfenVzdGFuZCA9IHJlcXVpcmUoXCJ6dXN0YW5kXCIpO1xudmFyIGltcG9ydF9taWRkbGV3YXJlID0gcmVxdWlyZShcInp1c3RhbmQvbWlkZGxld2FyZVwiKTtcbnZhciB1c2VDb2xsYWJvcmF0b3JTdG9yZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB1c2VTdG9yZVdpdGhQYXRjaFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZVJlZikoKDAsIGltcG9ydF96dXN0YW5kLmNyZWF0ZSkoKSgoMCwgaW1wb3J0X21pZGRsZXdhcmUuc3Vic2NyaWJlV2l0aFNlbGVjdG9yKShmdW5jdGlvbihzZXQsIGdldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IFtdLFxuICAgICAgICAgICAgcGF0Y2g6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IF90b19jb25zdW1hYmxlX2FycmF5KGZuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXNlbmNlczogZ2V0KCkuZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldCgpLmluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKSk7XG4gICAgdmFyIHBhdGNoID0gKDAsIGltcG9ydF9yZWFjdDIudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlV2l0aFBhdGNoUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5wYXRjaChmbik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciByZXNldCA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnJlc2V0KCk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciB1c2VTdG9yZSA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZVdpdGhQYXRjaFJlZi5jdXJyZW50KGZ1bmN0aW9uKHJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5kYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RvciA/IHNlbGVjdG9yKHJvb3QuZGF0YSkgOiByb290LmRhdGE7XG4gICAgICAgICAgICB9LCBlcXVhbGl0eUZuKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHN1YnNjcmliZSA9ICgwLCBpbXBvcnRfcmVhY3QyLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudC5zdWJzY3JpYmUoZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LmRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdG9yID8gc2VsZWN0b3Iocm9vdC5kYXRhKSA6IHJvb3QuZGF0YTtcbiAgICAgICAgICAgIH0sIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU3RvcmU6IHVzZVN0b3JlLFxuICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgICAgICByZXNldDogcmVzZXRcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9wcmVzZW5jZS91c2VQcmVzZW5jZVN0b3JlLnRzXG52YXIgaW1wb3J0X3JlYWN0MyA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfenVzdGFuZDIgPSByZXF1aXJlKFwienVzdGFuZFwiKTtcbnZhciBpbXBvcnRfbWlkZGxld2FyZTIgPSByZXF1aXJlKFwienVzdGFuZC9taWRkbGV3YXJlXCIpO1xudmFyIHVzZVByZXNlbmNlU3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXNlU3RvcmVXaXRoUGF0Y2hSZWYgPSAoMCwgaW1wb3J0X3JlYWN0My51c2VSZWYpKCgwLCBpbXBvcnRfenVzdGFuZDIuY3JlYXRlKSgpKCgwLCBpbXBvcnRfbWlkZGxld2FyZTIuc3Vic2NyaWJlV2l0aFNlbGVjdG9yKShmdW5jdGlvbihzZXQsIGdldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGNoOiBmdW5jdGlvbihmbikge1xuICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogZ2V0KCkuZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0KCkuaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KSkpO1xuICAgIHZhciBwYXRjaCA9ICgwLCBpbXBvcnRfcmVhY3QzLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZVdpdGhQYXRjaFJlZi5jdXJyZW50LmdldFN0YXRlKCkucGF0Y2goZm4pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgcmVzZXQgPSAoMCwgaW1wb3J0X3JlYWN0My51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlV2l0aFBhdGNoUmVmLmN1cnJlbnQuZ2V0U3RhdGUoKS5yZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgdXNlU3RvcmUgPSAoMCwgaW1wb3J0X3JlYWN0My51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudChmdW5jdGlvbihyb290KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0b3IgPyBzZWxlY3Rvcihyb290LmRhdGEpIDogcm9vdC5kYXRhO1xuICAgICAgICAgICAgfSwgZXF1YWxpdHlGbik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciBzdWJzY3JpYmUgPSAoMCwgaW1wb3J0X3JlYWN0My51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlV2l0aFBhdGNoUmVmLmN1cnJlbnQuc3Vic2NyaWJlKGZ1bmN0aW9uKHJvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm9vdC5kYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RvciA/IHNlbGVjdG9yKHJvb3QuZGF0YSkgOiByb290LmRhdGE7XG4gICAgICAgICAgICB9LCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVN0b3JlOiB1c2VTdG9yZSxcbiAgICAgICAgcGF0Y2g6IHBhdGNoLFxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgcmVzZXQ6IHJlc2V0XG4gICAgfTtcbn07XG4vLyBzcmMvY2hhbm5lbHMvcHJlc2VuY2UvdXRpbHMudHNcbnZhciBtZXJnZURhdGEgPSBmdW5jdGlvbihvbGREYXRhLCBuZXdEYXRhKSB7XG4gICAgaWYgKG9sZERhdGEgPT09IHZvaWQgMCB8fCBuZXdEYXRhID09IHZvaWQgMCB8fCAhaXNNYXAob2xkRGF0YSkgfHwgIWlzTWFwKG5ld0RhdGEpKSB7XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0X3NwcmVhZCh7fSwgb2xkRGF0YSwgbmV3RGF0YSk7XG4gICAgfVxufTtcbi8vIHNyYy9jaGFubmVscy9wcmVzZW5jZS91c2VQcmVzZW5jZS50c1xudmFyIFJlYWx0aW1lUHJlc2VuY2VTdGF0dXMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oUmVhbHRpbWVQcmVzZW5jZVN0YXR1czIpIHtcbiAgICBSZWFsdGltZVByZXNlbmNlU3RhdHVzMltcIlVucmVhZHlcIl0gPSBcIlVucmVhZHlcIjtcbiAgICBSZWFsdGltZVByZXNlbmNlU3RhdHVzMltcIlN5bmNpbmdcIl0gPSBcIlN5bmNpbmdcIjtcbiAgICBSZWFsdGltZVByZXNlbmNlU3RhdHVzMltcIlJlYWR5XCJdID0gXCJSZWFkeVwiO1xuICAgIHJldHVybiBSZWFsdGltZVByZXNlbmNlU3RhdHVzMjtcbn0oUmVhbHRpbWVQcmVzZW5jZVN0YXR1cyB8fCB7fSk7XG52YXIgUmVwbGFjZU1lc3NhZ2VUeXBlID0gXCJyZXBsYWNlXCI7XG52YXIgVXBkYXRlTWVzc2FnZVR5cGUgPSBcInVwZGF0ZVwiO1xudmFyIHVzZVByZXNlbmNlQ2hhbm5lbCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGNvbm5lY3Rpb25TdGF0dXMgPSBwYXJhbS5jb25uZWN0aW9uU3RhdHVzLCBjb25uZWN0aW9uU3RhdHVzUmVmID0gcGFyYW0uY29ubmVjdGlvblN0YXR1c1JlZiwgdXNlQ2hhbm5lbCA9IHBhcmFtLnVzZUNoYW5uZWwsIHRocm90dGxlID0gcGFyYW0udGhyb3R0bGU7XG4gICAgdmFyIF9yZWYgPSBfc2xpY2VkX3RvX2FycmF5KCgwLCBpbXBvcnRfcmVhY3Q0LnVzZVN0YXRlKShcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovICksIDIpLCBzdGF0dXMgPSBfcmVmWzBdLCBzZXRTdGF0dXMgPSBfcmVmWzFdO1xuICAgIHZhciBzdGF0dXNSZWYgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VSZWYpKFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKTtcbiAgICB2YXIgcHJlc2VuY2VDbGllbnRJZFJlZiA9ICgwLCBpbXBvcnRfcmVhY3Q0LnVzZVJlZikoKTtcbiAgICB2YXIgcHJlc2VuY2VMb2FkZWRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VSZWYpKGZhbHNlKTtcbiAgICB2YXIgcHJlU3luY01lc3NhZ2VzUmVmID0gKDAsIGltcG9ydF9yZWFjdDQudXNlUmVmKShbXSk7XG4gICAgdmFyIGNvbGxhYm9yYXRvclN0b3JlID0gdXNlQ29sbGFib3JhdG9yU3RvcmUoKTtcbiAgICB2YXIgcHJlc2VuY2VTdG9yZSA9IHVzZVByZXNlbmNlU3RvcmUoKTtcbiAgICB2YXIgYXBwbHlQcmVzZW5jZUNsaWVudFJlc3BvbnNlID0gKDAsIGltcG9ydF9yZWFjdDQudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHN3aXRjaChyZXNwb25zZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJjbGllbnRfYWRkXCI6XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmNsaWVudC5jbGllbnRJZCA9PT0gcHJlc2VuY2VDbGllbnRJZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlU3RvcmUucGF0Y2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IHBhcmFtLnByZXNlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UuY2xpZW50LmRhdGEgPSBwcmVzZW5jZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlbmNlLmRhdGEgJiYgaXNNYXAocHJlc2VuY2UuZGF0YSkgJiYgT2JqZWN0LmtleXMocHJlc2VuY2UuZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNsaWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSWQ6IHVuaXF1ZUlkKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUmVwbGFjZU1lc3NhZ2VUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGNsb25lKHByZXNlbmNlLmRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5jbGllbnQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZXRTdGF0dXMoXCJSZWFkeVwiIC8qIFJlYWR5ICovICk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1JlZi5jdXJyZW50ID0gXCJSZWFkeVwiIC8qIFJlYWR5ICovIDtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VMb2FkZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsYWJvcmF0b3JTdG9yZS5wYXRjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2VzID0gcGFyYW0ucHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZXMgPSBwcmVzZW5jZXMuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNsaWVudElkICE9PSByZXNwb25zZS5jbGllbnQuY2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZXMucHVzaChyZXNwb25zZS5jbGllbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNsaWVudF9yZW1vdmVcIjpcbiAgICAgICAgICAgICAgICBjb2xsYWJvcmF0b3JTdG9yZS5wYXRjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2VzID0gcGFyYW0ucHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZXMgPSBwcmVzZW5jZXMuZmlsdGVyKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNsaWVudElkICE9PSByZXNwb25zZS5jbGllbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2xpZW50X3JlcGxhY2VfbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY2xpZW50SWQgPT09IHByZXNlbmNlQ2xpZW50SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVN0b3JlLnBhdGNoKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBwYXJhbS5wcmVzZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0X3NwcmVhZF9wcm9wcyhfb2JqZWN0X3NwcmVhZCh7fSwgcHJlc2VuY2UpLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJlc3BvbnNlLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2xsYWJvcmF0b3JTdG9yZS5wYXRjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlc2VuY2VzID0gcGFyYW0ucHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwcmVzZW5jZXMuZmluZEluZGV4KGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwLmNsaWVudElkID09PSByZXNwb25zZS5jbGllbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VzW2luZGV4XSA9IF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkKHt9LCBwcmVzZW5jZXNbaW5kZXhdKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IHJlc3BvbnNlLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNsaWVudF9yZXBsYWNlX2RhdGFcIjpcbiAgICAgICAgICAgIGNhc2UgXCJjbGllbnRfdXBkYXRlX2RhdGFcIjpcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuY2xpZW50SWQgPT09IHByZXNlbmNlQ2xpZW50SWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29sbGFib3JhdG9yU3RvcmUucGF0Y2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXNlbmNlcyA9IHBhcmFtLnByZXNlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcHJlc2VuY2VzLmZpbmRJbmRleChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5jbGllbnRJZCA9PT0gcmVzcG9uc2UuY2xpZW50SWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlc1tpbmRleF0gPSBfb2JqZWN0X3NwcmVhZF9wcm9wcyhfb2JqZWN0X3NwcmVhZCh7fSwgcHJlc2VuY2VzW2luZGV4XSksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLnR5cGUgPT09IFwiY2xpZW50X3JlcGxhY2VfZGF0YVwiID8gcmVzcG9uc2UuZGF0YSA6IG1lcmdlRGF0YShwcmVzZW5jZXNbaW5kZXhdLmRhdGEsIHJlc3BvbnNlLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVVwZGF0ZWRBdDogcmVzcG9uc2UuZGF0YVVwZGF0ZWRBdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0NC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcHJlU3luY01lc3NhZ2VzUmVmLmN1cnJlbnQuZm9yRWFjaChmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseVByZXNlbmNlQ2xpZW50UmVzcG9uc2UobXNnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZVN5bmNNZXNzYWdlc1JlZi5jdXJyZW50ID0gW107XG4gICAgfSwgW1xuICAgICAgICBzdGF0dXNcbiAgICBdKTtcbiAgICB2YXIgb25QcmVzZW5jZU1lc3NhZ2UgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VDYWxsYmFjaykoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAoKHN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlN5bmNpbmdcIiAvKiBTeW5jaW5nICovICAmJiAhcHJlc2VuY2VDbGllbnRJZFJlZi5jdXJyZW50IHx8IHByZVN5bmNNZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA+IDApICYmIG1lc3NhZ2UudHlwZS5zdGFydHNXaXRoKFwiY2xpZW50X1wiKSkge1xuICAgICAgICAgICAgcHJlU3luY01lc3NhZ2VzUmVmLmN1cnJlbnQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gobWVzc2FnZS50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJzeW5jXCI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3luY1Jlc3BvbnNlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgY29sbGFib3JhdG9yU3RvcmUucGF0Y2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWYgPSBfb2JqZWN0X2Rlc3RydWN0dXJpbmdfZW1wdHkocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNSZXNwb25zZS5jbGllbnRzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VDbGllbnRJZFJlZi5jdXJyZW50ID0gc3luY1Jlc3BvbnNlLm1lLmNsaWVudElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjbGllbnRfYWRkXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xpZW50X3JlbW92ZVwiOlxuICAgICAgICAgICAgY2FzZSBcImNsaWVudF9yZXBsYWNlX21ldGFkYXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xpZW50X3VwZGF0ZV9kYXRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiY2xpZW50X3JlcGxhY2VfZGF0YVwiOlxuICAgICAgICAgICAgICAgIGFwcGx5UHJlc2VuY2VDbGllbnRSZXNwb25zZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUHJlc2VuY2UgbWVzc2FnZSB3aXRoIHR5cGUgJ1wiLmNvbmNhdChtZXNzYWdlLnR5cGUsIFwiJyB1bmhhbmRsZWQuXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sIFtcbiAgICAgICAgYXBwbHlQcmVzZW5jZUNsaWVudFJlc3BvbnNlXG4gICAgXSk7XG4gICAgdmFyIGdyb3VwTWVzc2FnZXNPblNlbmQgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VDYWxsYmFjaykoZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdNZXNzYWdlID0gbWVzc2FnZXNbMF07XG4gICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IG1lc3NhZ2VzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBSZXBsYWNlTWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWVzc2FnZS50eXBlID0gUmVwbGFjZU1lc3NhZ2VUeXBlO1xuICAgICAgICAgICAgICAgICAgICBuZXdNZXNzYWdlLmRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdNZXNzYWdlLmRhdGEgPSBtZXJnZURhdGEobmV3TWVzc2FnZS5kYXRhLCBtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXdNZXNzYWdlXG4gICAgICAgIF07XG4gICAgfSwgW10pO1xuICAgIHZhciBzZW5kTWVzc2FnZSA9IHVzZUNoYW5uZWwoe1xuICAgICAgICBjaGFubmVsOiBcInByZXNlbmNlXCIsXG4gICAgICAgIG9uTWVzc2FnZTogb25QcmVzZW5jZU1lc3NhZ2UsXG4gICAgICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICAgICAgZ3JvdXBNZXNzYWdlc09uU2VuZDogZ3JvdXBNZXNzYWdlc09uU2VuZFxuICAgIH0pLnNlbmRNZXNzYWdlO1xuICAgIHZhciBwYXRjaE1lID0gKDAsIGltcG9ydF9yZWFjdDQudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1c1JlZi5jdXJyZW50ICE9PSBcIk9wZW5cIiAvKiBPcGVuICovICkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBwYXRjaCBwcmVzZW5jZSBkYXRhIGJlZm9yZSBjb25uZWN0aW9uIGlzIG9wZW4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlc2VuY2VMb2FkZWRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBwYXRjaCBwcmVzZW5jZSBkYXRhIGJlZm9yZSBwcmVzZW5jZSBpcyByZWFkeS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlc2VuY2VTdG9yZS5wYXRjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IHBhcmFtLnByZXNlbmNlO1xuICAgICAgICAgICAgICAgIHZhciBjbG9uZWREYXRhID0gY2xvbmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3Rfc3ByZWFkX3Byb3BzKF9vYmplY3Rfc3ByZWFkKHt9LCBwcmVzZW5jZSksIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBsYWNlKSA/IGNsb25lZERhdGEgOiBtZXJnZURhdGEocHJlc2VuY2UuZGF0YSwgY2xvbmVkRGF0YSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVcGRhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGxhY2UpID8gUmVwbGFjZU1lc3NhZ2VUeXBlIDogVXBkYXRlTWVzc2FnZVR5cGUsXG4gICAgICAgICAgICAgICAgZGF0YTogY2xvbmUoZGF0YSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc2VuZE1lc3NhZ2VcbiAgICBdKTtcbiAgICB2YXIgcmVzZXQgPSAoMCwgaW1wb3J0X3JlYWN0NC51c2VDYWxsYmFjaykoZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbGxhYm9yYXRvclN0b3JlLnJlc2V0KCk7XG4gICAgICAgIHByZXNlbmNlU3RvcmUucmVzZXQoKTtcbiAgICAgICAgcHJlc2VuY2VDbGllbnRJZFJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgICBwcmVTeW5jTWVzc2FnZXNSZWYuY3VycmVudCA9IFtdO1xuICAgIH0sIFtdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0NC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gXCJPcGVuXCIgLyogT3BlbiAqLyAgJiYgc3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0dXMgIT09IFwiT3BlblwiIC8qIE9wZW4gKi8gICYmIGNvbm5lY3Rpb25TdGF0dXMgIT09IFwiQXV0aGVudGljYXRpbmdcIiAvKiBBdXRoZW50aWNhdGluZyAqLyApIHtcbiAgICAgICAgICAgIHNldFN0YXR1cyhcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovICk7XG4gICAgICAgICAgICBzdGF0dXNSZWYuY3VycmVudCA9IFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdGF0dXMoXCJTeW5jaW5nXCIgLyogU3luY2luZyAqLyApO1xuICAgICAgICBzdGF0dXNSZWYuY3VycmVudCA9IFwiU3luY2luZ1wiIC8qIFN5bmNpbmcgKi8gO1xuICAgIH0sIFtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1c1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICB1c2VDb2xsYWJvcmF0b3JzOiBjb2xsYWJvcmF0b3JTdG9yZS51c2VTdG9yZSxcbiAgICAgICAgc3Vic2NyaWJlQ29sbGFib3JhdG9yczogY29sbGFib3JhdG9yU3RvcmUuc3Vic2NyaWJlLFxuICAgICAgICB1c2VNZTogcHJlc2VuY2VTdG9yZS51c2VTdG9yZSxcbiAgICAgICAgcGF0Y2hNZTogcGF0Y2hNZSxcbiAgICAgICAgc3Vic2NyaWJlTWU6IHByZXNlbmNlU3RvcmUuc3Vic2NyaWJlXG4gICAgfTtcbn07XG4vLyBzcmMvY3JlYXRlUmVhbHRpbWVDb250ZXh0LnRzeFxudmFyIGltcG9ydF9yZWFjdDE0ID0gX190b0VTTShyZXF1aXJlKFwicmVhY3RcIikpO1xuLy8gc3JjL3VzZVJlYWx0aW1lQ29ubmVjdGlvbi50c1xudmFyIGltcG9ydF9yZWFjdDkgPSByZXF1aXJlKFwicmVhY3RcIik7XG4vLyBzcmMvY2hhbm5lbHMvYnJvYWRjYXN0L3VzZUJyb2FkY2FzdC50c1xudmFyIGltcG9ydF9yZWFjdDUgPSByZXF1aXJlKFwicmVhY3RcIik7XG4vLyBzcmMvY2hhbm5lbHMvYnJvYWRjYXN0L2NyZWF0ZUJyb2FkY2FzdFN0b3JlLnRzXG52YXIgY3JlYXRlQnJvYWRjYXN0U3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB2YXIgcmVnaXN0ZXJFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGxpc3RlbmVycyA9PT0gbnVsbCB8fCBsaXN0ZW5lcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgc3Vic2NyaWJlVG9FdmVudHMgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID09PSBudWxsIHx8IGxpc3RlbmVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3RlckV2ZW50OiByZWdpc3RlckV2ZW50LFxuICAgICAgICBzdWJzY3JpYmVUb0V2ZW50czogc3Vic2NyaWJlVG9FdmVudHNcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9icm9hZGNhc3QvdXNlQnJvYWRjYXN0LnRzXG52YXIgdXNlQnJvYWRjYXN0Q2hhbm5lbCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGNvbm5lY3Rpb25TdGF0dXNSZWYgPSBwYXJhbS5jb25uZWN0aW9uU3RhdHVzUmVmLCB1c2VDaGFubmVsID0gcGFyYW0udXNlQ2hhbm5lbCwgdGhyb3R0bGUgPSBwYXJhbS50aHJvdHRsZTtcbiAgICB2YXIgYnJvYWRjYXN0U3RvcmVSZWYgPSAoMCwgaW1wb3J0X3JlYWN0NS51c2VSZWYpKGNyZWF0ZUJyb2FkY2FzdFN0b3JlKCkpO1xuICAgIHZhciBzZW5kTWVzc2FnZSA9IHVzZUNoYW5uZWwoe1xuICAgICAgICBjaGFubmVsOiBcImJyb2FkY2FzdFwiLFxuICAgICAgICBvbk1lc3NhZ2U6ICgwLCBpbXBvcnRfcmVhY3Q1LnVzZUNhbGxiYWNrKShmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcImJyb2FkY2FzdFwiKSB7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0U3RvcmVSZWYuY3VycmVudC5yZWdpc3RlckV2ZW50KG1lc3NhZ2UuZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSksXG4gICAgICAgIHRocm90dGxlOiB0aHJvdHRsZVxuICAgIH0pLnNlbmRNZXNzYWdlO1xuICAgIHZhciBicm9hZGNhc3QgPSAoMCwgaW1wb3J0X3JlYWN0NS51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiT3BlblwiIC8qIE9wZW4gKi8gKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ2Fubm90IHNlbmQgYnJvYWRjYXN0IGV2ZW50IHdoZW4gY29ubmVjdGlvbiBzdGF0dXMgaXMgbm90IG9wZW4uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEgPSBvcHRpb25zLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlY2lwaWVudENsaWVudElkcykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnJlY2lwaWVudENsaWVudElkcyA9IG9wdGlvbnMucmVjaXBpZW50Q2xpZW50SWRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJyb2FkY2FzdFwiLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBzZW5kTWVzc2FnZVxuICAgIF0pO1xuICAgIHZhciB1c2VCcm9hZGNhc3RMaXN0ZW5lciA9ICgwLCBpbXBvcnRfcmVhY3Q1LnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob25FdmVudCkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gKDAsIGltcG9ydF9yZWFjdDUudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9uRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgIG9uRXZlbnRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgKDAsIGltcG9ydF9yZWFjdDUudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJvYWRjYXN0U3RvcmVSZWYuY3VycmVudC5zdWJzY3JpYmVUb0V2ZW50cyhjYWxsYmFjayk7XG4gICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBicm9hZGNhc3Q6IGJyb2FkY2FzdCxcbiAgICAgICAgdXNlQnJvYWRjYXN0TGlzdGVuZXI6IHVzZUJyb2FkY2FzdExpc3RlbmVyXG4gICAgfTtcbn07XG4vLyBzcmMvY2hhbm5lbHMvc3lzdGVtL3VzZVN5c3RlbS50c1xudmFyIGltcG9ydF9yZWFjdDYgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdXNlU3lzdGVtQ2hhbm5lbCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIHVzZUNoYW5uZWwgPSBwYXJhbS51c2VDaGFubmVsO1xuICAgIHZhciBzZW5kTWVzc2FnZSA9IHVzZUNoYW5uZWwoe1xuICAgICAgICBjaGFubmVsOiBcInN5c3RlbVwiLFxuICAgICAgICBvbk1lc3NhZ2U6ICgwLCBpbXBvcnRfcmVhY3Q2LnVzZUNhbGxiYWNrKShmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS50eXBlID09PSBcInBpbmdcIikge1xuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUlkOiB1bmlxdWVJZCgpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInBvbmdcIixcbiAgICAgICAgICAgICAgICAgICAgYWNrTWVzc2FnZUlkOiBtZXNzYWdlLm1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSksXG4gICAgICAgIHRocm90dGxlOiAxMDBcbiAgICB9KS5zZW5kTWVzc2FnZTtcbn07XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvYXV0b3NhdmUvaW5kZXhlZGRiX2F1dG9zYXZlLnRzXG52YXIgZGJOYW1lUHJlZml4ID0gXCJyZWFsdGltZV9kYXRhYmFzZVwiO1xudmFyIGZyYWdtZW50c09iamVjdFN0b3JlTmFtZSA9IFwiZnJhZ21lbnRzXCI7XG52YXIgZG9jdW1lbnRzTWV0YWRhdGFPYmplY3RTdG9yZU5hbWUgPSBcImRvY3VtZW50c19tZXRhZGF0YVwiO1xudmFyIG9wZXJhdGlvbnNPYmplY3RTdG9yZU5hbWUgPSBcIm9wZXJhdGlvbnNcIjtcbnZhciBkb2N1bWVudElkSW5PcGVyYXRpb25zT2JqZWN0U3RvcmUgPSBcImRvY3VtZW50SWRJbmRleFwiO1xudmFyIGRiVmVyc2lvbiA9IDE7XG52YXIgSW5kZXhlZEF1dG9zYXZlID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbmRleGVkQXV0b3NhdmUocGFyYW0pIHtcbiAgICAgICAgdmFyIHN0b3JlTmFtZVBvc3RmaXggPSBwYXJhbS5zdG9yZU5hbWVQb3N0Zml4LCBkaXNhYmxlV2FybmluZyA9IHBhcmFtLmRpc2FibGVXYXJuaW5nO1xuICAgICAgICBfY2xhc3NfY2FsbF9jaGVjayh0aGlzLCBJbmRleGVkQXV0b3NhdmUpO1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuX3N0b3JlTmFtZVBvc3RmaXggPSBzdG9yZU5hbWVQb3N0Zml4O1xuICAgICAgICB0aGlzLl9kaXNhYmxlV2FybmluZyA9IGRpc2FibGVXYXJuaW5nO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKEluZGV4ZWRBdXRvc2F2ZSwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmluZGV4ZWREQikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXZSdyZSBzb3JyeSB0byBpbmZvcm0geW91IHRoYXQgeW91ciBjdXJyZW50IHJ1bnRpbWUgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgQXV0b3NhdmUgZmVhdHVyZSwgd2hpY2ggaXMgYnVpbHQgdXBvbiBJbmRleGVkREIuXCIsIFwiQXMgYSByZXN1bHQsIHdlIGhhdmUgZGlzYWJsZWQgdGhlIEF1dG9zYXZlIGZlYXR1cmUgZm9yIHlvdXIgY3VycmVudCBydW50aW1lLlwiLCBcIkhvd2V2ZXIsIHdlJ3JlIG1vcmUgdGhhbiBoYXBweSB0byBoZWxwIGFuZCBjb25zaWRlciBhZGRpbmcgc3VwcG9ydCBmb3IgaXQgaWYgeW91IGNvdWxkIGtpbmRseSBzZW5kIHVzIGEgbWVzc2FnZSB3aXRoIHlvdXIgdXNlIGNhc2UgYW5kIHJ1bnRpbWUgZW52aXJvbm1lbnQgYXQgc3VwcG9ydEBpbnJlYWx0aW1lLmFwcC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZGF0YWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pbml0UHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc2FibGVXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJQbGVhc2Ugbm90ZSB0aGF0IHRoZSBSZWFsdGltZSBhdXRvc2F2ZSBmZWF0dXJlIGlzIHN0aWxsIGluIGJldGEgYW5kIG5vdCB5ZXQgc3RhYmxlIGZvciBwcm9kdWN0aW9uIHVzZS4gSXQgY3VycmVudGx5IHJlbGllcyBvbiBJbmRleGVkREIgYW5kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgaXQuIFdlJ3JlIGNvbnN0YW50bHkgd29ya2luZyBvbiBpbXByb3ZpbmcgdGhpcyBmZWF0dXJlIHRvIGVuc3VyZSBzZWFtbGVzcyBhbmQgcmVsaWFibGUgZnVuY3Rpb25hbGl0eS5cIiwgXCJXZSdyZSBleHBsb3JpbmcgbmV3IHdheXMgdG8gZW5oYW5jZSB0aGUgUmVhbHRpbWUgcGFja2FnZSBpbnRlcmZhY2UsIHdoaWNoIHdvdWxkIGFsbG93IGZvciBzZWxlY3RpdmUgc3luY2luZyBvZiBtZXNzYWdlcywgc2VlaW5nIHRoZSBudW1iZXIgb2YgY2hhbmdlcywgYXBwbHlpbmcgY2hhbmdlcywgYW5kIG1vcmUuIE91ciBjdXJyZW50IHN0cmF0ZWd5IGlzIHRvIHN0b3JlIGFsbCBjaGFuZ2VzIGFuZCBzeW5jIHdoZW4gY29ubmVjdGlvbnMgYXJlIG1hZGUuXCIsIFwiSWYgeW91IGhhdmUgYW55IGZlZWRiYWNrIG9yIHN1Z2dlc3Rpb25zIG9uIGhvdyB3ZSBjYW4gaW1wcm92ZSB0aGlzIGZlYXR1cmUgb3Igc3VwcG9ydCBtb3JlIGVudmlyb25tZW50cywgcGxlYXNlIGNvbnRhY3QgdXMgYXQgc3VwcG9ydEBpbnJlYWx0aW1lLmFwcC4gT3VyIHRlYW0gaXMgZGVkaWNhdGVkIHRvIHByb3ZpZGluZyB5b3Ugd2l0aCB0aGUgYmVzdCBwb3NzaWJsZSBleHBlcmllbmNlIHVzaW5nIG91ciBzb2Z0d2FyZSBwYWNrYWdlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbml0UHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSB3aW5kb3cuaW5kZXhlZERCLm9wZW4oXCJcIi5jb25jYXQoZGJOYW1lUHJlZml4LCBcIl9cIikuY29uY2F0KF90aGlzLl9zdG9yZU5hbWVQb3N0Zml4KSwgZGJWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkRhdGFiYXNlIGVycm9yOlwiLCBldmVudC50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGIgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9kYXRhYmFzZSA9IGRiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoZnJhZ21lbnRzT2JqZWN0U3RvcmVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKGRvY3VtZW50c01ldGFkYXRhT2JqZWN0U3RvcmVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25zT2JqZWN0U3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShvcGVyYXRpb25zT2JqZWN0U3RvcmVOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnNPYmplY3RTdG9yZS5jcmVhdGVJbmRleChkb2N1bWVudElkSW5PcGVyYXRpb25zT2JqZWN0U3RvcmUsIFwiZG9jdW1lbnRJZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9ucysrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0UHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9ucy0tO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jb25uZWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhYmFzZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFiYXNlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0UHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXREb2N1bWVudE1ldGFkYXRhXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RG9jdW1lbnRNZXRhZGF0YShwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudElkID0gcGFyYW0uZG9jdW1lbnRJZDtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIG9iamVjdFN0b3JlLCBwcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBfdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24oZG9jdW1lbnRzTWV0YWRhdGFPYmplY3RTdG9yZU5hbWUsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKGRvY3VtZW50c01ldGFkYXRhT2JqZWN0U3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldChkb2N1bWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JlcXVlc3RfcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKChfcmVxdWVzdF9yZXN1bHQgPSByZXF1ZXN0LnJlc3VsdCkgPT09IG51bGwgfHwgX3JlcXVlc3RfcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVxdWVzdF9yZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2F2ZURvY3VtZW50TWV0YWRhdGFcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRG9jdW1lbnRNZXRhZGF0YShkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRhYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuX2RhdGFiYXNlLnRyYW5zYWN0aW9uKGRvY3VtZW50c01ldGFkYXRhT2JqZWN0U3RvcmVOYW1lLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShkb2N1bWVudHNNZXRhZGF0YU9iamVjdFN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBvYmplY3RTdG9yZS5wdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGRhdGEuZG9jdW1lbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuZG9jdW1lbnRNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcHV0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHV0UmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJkZWxldGVEb2N1bWVudE1ldGFkYXRhXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlRG9jdW1lbnRNZXRhZGF0YShwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudElkID0gcGFyYW0uZG9jdW1lbnRJZDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24oZG9jdW1lbnRzTWV0YWRhdGFPYmplY3RTdG9yZU5hbWUsIFwicmVhZHdyaXRlXCIpO1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKGRvY3VtZW50c01ldGFkYXRhT2JqZWN0U3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlUmVxdWVzdCA9IG9iamVjdFN0b3JlLmRlbGV0ZShkb2N1bWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGVsZXRlUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRGcmFnbWVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZyYWdtZW50KHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZGF0YWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YWJhc2Ugbm90IGluaXRpYWxpemVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSB0aGlzLl9kYXRhYmFzZS50cmFuc2FjdGlvbihmcmFnbWVudHNPYmplY3RTdG9yZU5hbWUsIFwicmVhZG9ubHlcIik7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoZnJhZ21lbnRzT2JqZWN0U3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IG9iamVjdFN0b3JlLmdldChkb2N1bWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVxdWVzdF9yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKChfcmVxdWVzdF9yZXN1bHQgPSByZXF1ZXN0LnJlc3VsdCkgPT09IG51bGwgfHwgX3JlcXVlc3RfcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVxdWVzdF9yZXN1bHQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2F2ZUZyYWdtZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZUZyYWdtZW50KGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24oZnJhZ21lbnRzT2JqZWN0U3RvcmVOYW1lLCBcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShmcmFnbWVudHNPYmplY3RTdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdXRSZXF1ZXN0ID0gb2JqZWN0U3RvcmUucHV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBkYXRhLmRvY3VtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLmZyYWdtZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChwdXRSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImRlbGV0ZUZyYWdtZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlRnJhZ21lbnQocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRJZCA9IHBhcmFtLmRvY3VtZW50SWQ7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kYXRhYmFzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHRoaXMuX2RhdGFiYXNlLnRyYW5zYWN0aW9uKGZyYWdtZW50c09iamVjdFN0b3JlTmFtZSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoZnJhZ21lbnRzT2JqZWN0U3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRlUmVxdWVzdCA9IG9iamVjdFN0b3JlLmRlbGV0ZShkb2N1bWVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodm9pZCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZGVsZXRlUmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJnZXRPcGVyYXRpb25zXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3BlcmF0aW9ucyhwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudElkID0gcGFyYW0uZG9jdW1lbnRJZDtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIG9iamVjdFN0b3JlLCBpbmRleCwgcmVxdWVzdCwgb3BlcmF0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBfdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24ob3BlcmF0aW9uc09iamVjdFN0b3JlTmFtZSwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0U3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShvcGVyYXRpb25zT2JqZWN0U3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBvYmplY3RTdG9yZS5pbmRleChkb2N1bWVudElkSW5PcGVyYXRpb25zT2JqZWN0U3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ID0gaW5kZXguZ2V0QWxsKGRvY3VtZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVxdWVzdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmlkIC0gYi5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24ob3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VXaXRoSWQgPSBvcGVyYXRpb24ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlV2l0aElkLmlkID0gb3BlcmF0aW9uLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlV2l0aElkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNhdmVPcGVyYXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlT3BlcmF0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24ob3BlcmF0aW9uc09iamVjdFN0b3JlTmFtZSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUob3BlcmF0aW9uc09iamVjdFN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHB1dFJlcXVlc3QgPSBvYmplY3RTdG9yZS5wdXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHB1dFJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1lc3NhZ2UuaWQgPSBwdXRSZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcHV0UmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocHV0UmVxdWVzdC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZW1vdmVPcGVyYXRpb25cIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVPcGVyYXRpb24oaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RhdGFiYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFiYXNlIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gdGhpcy5fZGF0YWJhc2UudHJhbnNhY3Rpb24ob3BlcmF0aW9uc09iamVjdFN0b3JlTmFtZSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgICAgICAgICAgdmFyIG9iamVjdFN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUob3BlcmF0aW9uc09iamVjdFN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVJlcXVlc3QgPSBvYmplY3RTdG9yZS5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2b2lkIDApO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChkZWxldGVSZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBJbmRleGVkQXV0b3NhdmU7XG59KCk7XG4vLyBzcmMvY29uZmlnLnRzXG52YXIgYWxsb3dlZEVudmlyb25tZW50cyA9IFtcbiAgICBcImxvY2FsXCIsXG4gICAgXCJkZXZlbG9wbWVudFwiLFxuICAgIFwicHJvZHVjdGlvblwiXG5dO1xudmFyIHdlYlNvY2tldFVybHMgPSB7XG4gICAgbG9jYWw6IFwid3M6Ly8xMjcuMC4wLjE6ODc4N1wiLFxuICAgIGRldmVsb3BtZW50OiBcIndzczovL3dvcmtlci5pbnJlYWx0aW1lLmxvdmVcIixcbiAgICBwcm9kdWN0aW9uOiBcIndzczovL3dvcmtlci5pbnJlYWx0aW1lLmFwcFwiXG59O1xudmFyIGF1dGhVcmxzID0ge1xuICAgIGxvY2FsOiBcImh0dHA6Ly8xMjcuMC4wLjE6ODc4Ny9hdXRoXCIsXG4gICAgZGV2ZWxvcG1lbnQ6IFwiaHR0cHM6Ly93b3JrZXIuaW5yZWFsdGltZS5sb3ZlL2F1dGhcIixcbiAgICBwcm9kdWN0aW9uOiBcImh0dHBzOi8vd29ya2VyLmlucmVhbHRpbWUuYXBwL2F1dGhcIlxufTtcbnZhciBnZXRSZWFsdGltZUNvbmZpZyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGVudmlyb25tZW50ID0gcGFyYW0uZW52aXJvbm1lbnQsIGxvZ2dpbmcgPSBwYXJhbS5sb2dnaW5nLCBhdXRvc2F2ZSA9IHBhcmFtLmF1dG9zYXZlO1xuICAgIGlmICghZW52aXJvbm1lbnQgfHwgIWFsbG93ZWRFbnZpcm9ubWVudHMuaW5jbHVkZXMoZW52aXJvbm1lbnQpKSB7XG4gICAgICAgIGVudmlyb25tZW50ID0gXCJwcm9kdWN0aW9uXCI7XG4gICAgfVxuICAgIHZhciBhdXRoVXJsID0gYXV0aFVybHNbZW52aXJvbm1lbnRdO1xuICAgIHZhciB3ZWJTb2NrZXRVcmwgPSB3ZWJTb2NrZXRVcmxzW2Vudmlyb25tZW50XTtcbiAgICB2YXIgX2xvZ2dpbmdfY29uZmxpY3RzLCBfbG9nZ2luZ19zb2NrZXRTdGF0dXMsIF9sb2dnaW5nX2xpc3RGcmFnbWVudEluZGV4ZXMsIF9sb2dnaW5nX2xvY2FsT3BlcmF0aW9ucywgX2xvZ2dpbmdfcmVtb3RlT3BlcmF0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBlbnZpcm9ubWVudDogZW52aXJvbm1lbnQsXG4gICAgICAgIGF1dGhVcmw6IGF1dGhVcmwsXG4gICAgICAgIHdlYlNvY2tldFVybDogd2ViU29ja2V0VXJsLFxuICAgICAgICBsb2dnaW5nOiB7XG4gICAgICAgICAgICBjb25mbGljdHM6IChfbG9nZ2luZ19jb25mbGljdHMgPSBsb2dnaW5nID09PSBudWxsIHx8IGxvZ2dpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dpbmcuY29uZmxpY3RzKSAhPT0gbnVsbCAmJiBfbG9nZ2luZ19jb25mbGljdHMgIT09IHZvaWQgMCA/IF9sb2dnaW5nX2NvbmZsaWN0cyA6IGZhbHNlLFxuICAgICAgICAgICAgc29ja2V0U3RhdHVzOiAoX2xvZ2dpbmdfc29ja2V0U3RhdHVzID0gbG9nZ2luZyA9PT0gbnVsbCB8fCBsb2dnaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnaW5nLnNvY2tldFN0YXR1cykgIT09IG51bGwgJiYgX2xvZ2dpbmdfc29ja2V0U3RhdHVzICE9PSB2b2lkIDAgPyBfbG9nZ2luZ19zb2NrZXRTdGF0dXMgOiBmYWxzZSxcbiAgICAgICAgICAgIGxpc3RGcmFnbWVudEluZGV4ZXM6IChfbG9nZ2luZ19saXN0RnJhZ21lbnRJbmRleGVzID0gbG9nZ2luZyA9PT0gbnVsbCB8fCBsb2dnaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2dnaW5nLmxpc3RGcmFnbWVudEluZGV4ZXMpICE9PSBudWxsICYmIF9sb2dnaW5nX2xpc3RGcmFnbWVudEluZGV4ZXMgIT09IHZvaWQgMCA/IF9sb2dnaW5nX2xpc3RGcmFnbWVudEluZGV4ZXMgOiBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsT3BlcmF0aW9uczogKF9sb2dnaW5nX2xvY2FsT3BlcmF0aW9ucyA9IGxvZ2dpbmcgPT09IG51bGwgfHwgbG9nZ2luZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2luZy5sb2NhbE9wZXJhdGlvbnMpICE9PSBudWxsICYmIF9sb2dnaW5nX2xvY2FsT3BlcmF0aW9ucyAhPT0gdm9pZCAwID8gX2xvZ2dpbmdfbG9jYWxPcGVyYXRpb25zIDogZmFsc2UsXG4gICAgICAgICAgICByZW1vdGVPcGVyYXRpb25zOiAoX2xvZ2dpbmdfcmVtb3RlT3BlcmF0aW9ucyA9IGxvZ2dpbmcgPT09IG51bGwgfHwgbG9nZ2luZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSAhPT0gbnVsbCAmJiBfbG9nZ2luZ19yZW1vdGVPcGVyYXRpb25zICE9PSB2b2lkIDAgPyBfbG9nZ2luZ19yZW1vdGVPcGVyYXRpb25zIDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYXV0b3NhdmU6IGdldEF1dG9zYXZlQ29uZmlnKGF1dG9zYXZlKVxuICAgIH07XG59O1xudmFyIGdldEF1dG9zYXZlQ29uZmlnID0gZnVuY3Rpb24oYXV0b3NhdmUpIHtcbiAgICB2YXIgYXV0b3NhdmVPYmogPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzdG9yZU5hbWVQb3N0Zml4OiBcImRlZmF1bHRcIixcbiAgICAgICAgZGlzYWJsZVdhcm5pbmc6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAoYXV0b3NhdmUgJiYgaXNNYXAoYXV0b3NhdmUpKSB7XG4gICAgICAgIHZhciB2ZXJib3NlQXV0b3NhdmUgPSBhdXRvc2F2ZTtcbiAgICAgICAgdmFyIF92ZXJib3NlQXV0b3NhdmVfc3RvcmVOYW1lUG9zdGZpeDtcbiAgICAgICAgYXV0b3NhdmVPYmogPSB7XG4gICAgICAgICAgICBlbmFibGVkOiB2ZXJib3NlQXV0b3NhdmUuZW5hYmxlZCA9PT0gdm9pZCAwIHx8IHZlcmJvc2VBdXRvc2F2ZS5lbmFibGVkLFxuICAgICAgICAgICAgLy8gRGVmYXVsdCBpZiBhdXRvc2F2ZT17fSB0aGVuIGl0IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHN0b3JlTmFtZVBvc3RmaXg6IChfdmVyYm9zZUF1dG9zYXZlX3N0b3JlTmFtZVBvc3RmaXggPSB2ZXJib3NlQXV0b3NhdmUuc3RvcmVOYW1lUG9zdGZpeCkgIT09IG51bGwgJiYgX3ZlcmJvc2VBdXRvc2F2ZV9zdG9yZU5hbWVQb3N0Zml4ICE9PSB2b2lkIDAgPyBfdmVyYm9zZUF1dG9zYXZlX3N0b3JlTmFtZVBvc3RmaXggOiBhdXRvc2F2ZU9iai5zdG9yZU5hbWVQb3N0Zml4LFxuICAgICAgICAgICAgZGlzYWJsZVdhcm5pbmc6ICEhKHZlcmJvc2VBdXRvc2F2ZSA9PT0gbnVsbCB8fCB2ZXJib3NlQXV0b3NhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZlcmJvc2VBdXRvc2F2ZS5kaXNhYmxlV2FybmluZylcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGF1dG9zYXZlKSB7XG4gICAgICAgIGF1dG9zYXZlT2JqLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gYXV0b3NhdmVPYmo7XG59O1xudmFyIGluZGV4ZWRBdXRvc2F2ZU1hcCA9IHt9O1xudmFyIGdldEluZGV4ZWRBdXRvc2F2ZUluc3RhbmNlID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgc3RvcmVOYW1lUG9zdGZpeCA9IHBhcmFtLnN0b3JlTmFtZVBvc3RmaXgsIGRpc2FibGVXYXJuaW5nID0gcGFyYW0uZGlzYWJsZVdhcm5pbmc7XG4gICAgaWYgKCFpbmRleGVkQXV0b3NhdmVNYXBbc3RvcmVOYW1lUG9zdGZpeF0pIHtcbiAgICAgICAgaW5kZXhlZEF1dG9zYXZlTWFwW3N0b3JlTmFtZVBvc3RmaXhdID0gbmV3IEluZGV4ZWRBdXRvc2F2ZSh7XG4gICAgICAgICAgICBzdG9yZU5hbWVQb3N0Zml4OiBzdG9yZU5hbWVQb3N0Zml4LFxuICAgICAgICAgICAgZGlzYWJsZVdhcm5pbmc6IGRpc2FibGVXYXJuaW5nXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXhlZEF1dG9zYXZlTWFwW3N0b3JlTmFtZVBvc3RmaXhdO1xufTtcbi8vIHNyYy9zb2NrZXQvdXNlV2ViU29ja2V0LnRzXG52YXIgaW1wb3J0X3JlYWN0OCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbi8vIHNyYy9zb2NrZXQvY3JlYXRlTWVzc2FnZVN0b3JlLnRzXG52YXIgY3JlYXRlTWVzc2FnZVN0b3JlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxpc3RlbmVyc1RvQ2hhbm5lbCA9IHt9O1xuICAgIHZhciByZWdpc3Rlck1lc3NhZ2UgPSBmdW5jdGlvbihjaGFubmVsLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnNUb0NoYW5uZWxbY2hhbm5lbF07XG4gICAgICAgIGxpc3RlbmVycyA9PT0gbnVsbCB8fCBsaXN0ZW5lcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsKG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBzdWJzY3JpYmVUb0NoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsLCBsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbGlzdGVuZXJzID0gbGlzdGVuZXJzVG9DaGFubmVsW2NoYW5uZWxdO1xuICAgICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyc1RvQ2hhbm5lbFtjaGFubmVsXSA9IGxpc3RlbmVycztcbiAgICAgICAgfVxuICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGlzdGVuZXJzID09PSBudWxsIHx8IGxpc3RlbmVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWdpc3Rlck1lc3NhZ2U6IHJlZ2lzdGVyTWVzc2FnZSxcbiAgICAgICAgc3Vic2NyaWJlVG9DaGFubmVsOiBzdWJzY3JpYmVUb0NoYW5uZWxcbiAgICB9O1xufTtcbi8vIHNyYy9zb2NrZXQvdXNlTWVzc2FnZXMudHNcbnZhciBpbXBvcnRfcmVhY3Q3ID0gcmVxdWlyZShcInJlYWN0XCIpO1xudmFyIHVzZU1lc3NhZ2VzID0gZnVuY3Rpb24oc3RvcmUsIGNoYW5uZWwsIG9uTWVzc2FnZSkge1xuICAgIHZhciBjYWxsYmFjayA9ICgwLCBpbXBvcnRfcmVhY3Q3LnVzZUNhbGxiYWNrKShmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBvbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgfSwgW1xuICAgICAgICBvbk1lc3NhZ2VcbiAgICBdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0Ny51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc3RvcmUuc3Vic2NyaWJlVG9DaGFubmVsKGNoYW5uZWwsIGNhbGxiYWNrKTtcbiAgICB9LCBbXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBjaGFubmVsLFxuICAgICAgICBjYWxsYmFja1xuICAgIF0pO1xuICAgIHJldHVybiB7fTtcbn07XG4vLyBzcmMvc29ja2V0L3VzZVdlYlNvY2tldC50c1xudmFyIHVzZVdlYlNvY2tldCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIHNvY2tldFVybCA9IHBhcmFtLnNvY2tldFVybCwgdG9rZW4gPSBwYXJhbS50b2tlbiwgY29uZmlnID0gcGFyYW0uY29uZmlnO1xuICAgIHZhciBfcmVmID0gX3NsaWNlZF90b19hcnJheSgoMCwgaW1wb3J0X3JlYWN0OC51c2VTdGF0ZSkoXCJDbG9zZWRcIiAvKiBDbG9zZWQgKi8gKSwgMiksIHNvY2tldFN0YXR1cyA9IF9yZWZbMF0sIHNldFNvY2tldFN0YXR1cyA9IF9yZWZbMV07XG4gICAgdmFyIHNvY2tldFN0YXR1c1JlZiA9ICgwLCBpbXBvcnRfcmVhY3Q4LnVzZVJlZikoc29ja2V0U3RhdHVzKTtcbiAgICB2YXIgX3JlZjEgPSBfc2xpY2VkX3RvX2FycmF5KCgwLCBpbXBvcnRfcmVhY3Q4LnVzZVN0YXRlKSgpLCAyKSwgbGFzdFRva2VuID0gX3JlZjFbMF0sIHNldExhc3RUb2tlbiA9IF9yZWYxWzFdO1xuICAgIHZhciBtZXNzYWdlU3RvcmVSZWYgPSAoMCwgaW1wb3J0X3JlYWN0OC51c2VSZWYpKGNyZWF0ZU1lc3NhZ2VTdG9yZSgpKTtcbiAgICB2YXIgYXV0aENoYW5uZWxQcmVmaXggPSBcImF1dGhcIjtcbiAgICB2YXIgcmVhbHRpbWVXZWJTb2NrZXRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0OC51c2VSZWYpKCk7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZF90b19hcnJheSgoMCwgaW1wb3J0X3JlYWN0OC51c2VTdGF0ZSkoMCksIDIpLCByZWNvbm5lY3RDb3VudGVyID0gX3JlZjJbMF0sIHNldFJlY29ubmVjdENvdW50ZXIgPSBfcmVmMlsxXTtcbiAgICB2YXIgdXNlQ2hhbm5lbCA9ICgwLCBpbXBvcnRfcmVhY3Q4LnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gcGFyYW0uY2hhbm5lbCwgb25NZXNzYWdlID0gcGFyYW0ub25NZXNzYWdlLCB0aHJvdHRsZSA9IHBhcmFtLnRocm90dGxlLCBncm91cE1lc3NhZ2VzT25TZW5kID0gcGFyYW0uZ3JvdXBNZXNzYWdlc09uU2VuZDtcbiAgICAgICAgICAgIHJldHVybiB1c2VSYXdDaGFubmVsKHtcbiAgICAgICAgICAgICAgICByZWFsdGltZVdlYlNvY2tldFJlZjogcmVhbHRpbWVXZWJTb2NrZXRSZWYsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVN0b3JlUmVmOiBtZXNzYWdlU3RvcmVSZWYsXG4gICAgICAgICAgICAgICAgY2hhbm5lbDogY2hhbm5lbCxcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2U6IG9uTWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0aHJvdHRsZTogdGhyb3R0bGUsXG4gICAgICAgICAgICAgICAgZ3JvdXBNZXNzYWdlc09uU2VuZDogZ3JvdXBNZXNzYWdlc09uU2VuZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHZhciBuZXdSZWFsdGltZVdlYlNvY2tldCA9ICgwLCBpbXBvcnRfcmVhY3Q4LnVzZUNhbGxiYWNrKShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlYWx0aW1lV2ViU29ja2V0ID0gbmV3IFJlYWx0aW1lV2ViU29ja2V0KHtcbiAgICAgICAgICAgIG9uT3BlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWx0aW1lV2ViU29ja2V0UmVmLmN1cnJlbnQgIT09IHJlYWx0aW1lV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnNvY2tldFN0YXR1cykgY29uc29sZS5sb2coXCJTb2NrZXQgc3RhdHVzIC0+IEF1dGhlbnRpY2F0aW5nXCIpO1xuICAgICAgICAgICAgICAgIHNldFNvY2tldFN0YXR1cyhcIkF1dGhlbnRpY2F0aW5nXCIgLyogQXV0aGVudGljYXRpbmcgKi8gKTtcbiAgICAgICAgICAgICAgICBzb2NrZXRTdGF0dXNSZWYuY3VycmVudCA9IFwiQXV0aGVudGljYXRpbmdcIiAvKiBBdXRoZW50aWNhdGluZyAqLyA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25Db25uZWN0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhbHRpbWVXZWJTb2NrZXRSZWYuY3VycmVudCAhPT0gcmVhbHRpbWVXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSBjb25zb2xlLmxvZyhcIlNvY2tldCBzdGF0dXMgLT4gQ29ubmVjdGluZ1wiKTtcbiAgICAgICAgICAgICAgICBzZXRTb2NrZXRTdGF0dXMoXCJDb25uZWN0aW5nXCIgLyogQ29ubmVjdGluZyAqLyApO1xuICAgICAgICAgICAgICAgIHNvY2tldFN0YXR1c1JlZi5jdXJyZW50ID0gXCJDb25uZWN0aW5nXCIgLyogQ29ubmVjdGluZyAqLyA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlYWx0aW1lV2ViU29ja2V0UmVmLmN1cnJlbnQgIT09IHJlYWx0aW1lV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnNvY2tldFN0YXR1cykgY29uc29sZS5sb2coXCJTb2NrZXQgc3RhdHVzIC0+IENsb3NlZFwiKTtcbiAgICAgICAgICAgICAgICBzZXRTb2NrZXRTdGF0dXMoXCJDbG9zZWRcIiAvKiBDbG9zZWQgKi8gKTtcbiAgICAgICAgICAgICAgICBzb2NrZXRTdGF0dXNSZWYuY3VycmVudCA9IFwiQ2xvc2VkXCIgLyogQ2xvc2VkICovIDtcbiAgICAgICAgICAgICAgICBzZXRMYXN0VG9rZW4odm9pZCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uKGNoYW5uZWwsIG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhbHRpbWVXZWJTb2NrZXRSZWYuY3VycmVudCAhPT0gcmVhbHRpbWVXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXNzYWdlU3RvcmVSZWYuY3VycmVudC5yZWdpc3Rlck1lc3NhZ2UoY2hhbm5lbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZWFsdGltZVdlYlNvY2tldDtcbiAgICB9LCBbXSk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDgudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHNvY2tldFN0YXR1cyAhPT0gXCJDbG9zZWRcIiAvKiBDbG9zZWQgKi8gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RDb3VudGVyKHJlY29ubmVjdENvdW50ZXIgKyAxKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgc29ja2V0U3RhdHVzLFxuICAgICAgICByZWNvbm5lY3RDb3VudGVyXG4gICAgXSk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDgudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzb2NrZXRVcmwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhbHRpbWVXZWJTb2NrZXQgPSBuZXdSZWFsdGltZVdlYlNvY2tldCgpO1xuICAgICAgICByZWFsdGltZVdlYlNvY2tldFJlZi5jdXJyZW50ID0gcmVhbHRpbWVXZWJTb2NrZXQ7XG4gICAgICAgIHJlYWx0aW1lV2ViU29ja2V0LnNldFNvY2tldFVybCh7XG4gICAgICAgICAgICBzb2NrZXRVcmw6IHNvY2tldFVybFxuICAgICAgICB9KTtcbiAgICAgICAgcmVhbHRpbWVXZWJTb2NrZXQuY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcuc29ja2V0U3RhdHVzKSBjb25zb2xlLmxvZyhcIkNsb3NpbmcgZHVlIHRvIGNoYW5nZSBpbiBzb2NrZXRVcmwsIHJlY29ubmVjdCBvciBob3QtcmVsb2FkXCIpO1xuICAgICAgICAgICAgcmVhbHRpbWVXZWJTb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHNvY2tldFVybCxcbiAgICAgICAgcmVjb25uZWN0Q291bnRlclxuICAgIF0pO1xuICAgIHZhciBfdXNlQ2hhbm5lbCA9IHVzZUNoYW5uZWwoe1xuICAgICAgICBjaGFubmVsOiBhdXRoQ2hhbm5lbFByZWZpeCxcbiAgICAgICAgb25NZXNzYWdlOiAoMCwgaW1wb3J0X3JlYWN0OC51c2VDYWxsYmFjaykoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHlwZSAhPT0gXCJ0b2tlblwiIHx8IHNvY2tldFN0YXR1cyAhPT0gXCJBdXRoZW50aWNhdGluZ1wiIC8qIEF1dGhlbnRpY2F0aW5nICovICkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5zb2NrZXRTdGF0dXMpIGNvbnNvbGUubG9nKFwiU29ja2V0IHN0YXR1cyAtPiBPcGVuXCIpO1xuICAgICAgICAgICAgc2V0U29ja2V0U3RhdHVzKFwiT3BlblwiIC8qIE9wZW4gKi8gKTtcbiAgICAgICAgICAgIHNvY2tldFN0YXR1c1JlZi5jdXJyZW50ID0gXCJPcGVuXCIgLyogT3BlbiAqLyA7XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNvY2tldFN0YXR1cyxcbiAgICAgICAgICAgIHRva2VuXG4gICAgICAgIF0pLFxuICAgICAgICB0aHJvdHRsZTogMFxuICAgIH0pLCBzZW5kQXV0aE1lc3NhZ2UgPSBfdXNlQ2hhbm5lbC5zZW5kTWVzc2FnZTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0OC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc29ja2V0U3RhdHVzICE9PSBcIkF1dGhlbnRpY2F0aW5nXCIgLyogQXV0aGVudGljYXRpbmcgKi8gKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGFzdFRva2VuKHRva2VuKTtcbiAgICAgICAgc2VuZEF1dGhNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9rZW5cIixcbiAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgIHRva2VuOiB0b2tlblxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHNlbmRBdXRoTWVzc2FnZSxcbiAgICAgICAgc29ja2V0U3RhdHVzLFxuICAgICAgICB0b2tlblxuICAgIF0pO1xuICAgICgwLCBpbXBvcnRfcmVhY3Q4LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzb2NrZXRTdGF0dXMgIT09IFwiT3BlblwiIC8qIE9wZW4gKi8gIHx8IGxhc3RUb2tlbiA9PT0gdG9rZW4gfHwgIXRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0TGFzdFRva2VuKHRva2VuKTtcbiAgICAgICAgc2VuZEF1dGhNZXNzYWdlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9rZW5cIixcbiAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgIHRva2VuOiB0b2tlblxuICAgICAgICB9KTtcbiAgICB9LCBbXG4gICAgICAgIHNlbmRBdXRoTWVzc2FnZSxcbiAgICAgICAgc29ja2V0U3RhdHVzLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgbGFzdFRva2VuXG4gICAgXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBzb2NrZXRTdGF0dXMsXG4gICAgICAgIHN0YXR1c1JlZjogc29ja2V0U3RhdHVzUmVmLFxuICAgICAgICB1c2VDaGFubmVsOiB1c2VDaGFubmVsXG4gICAgfTtcbn07XG52YXIgdXNlUmF3Q2hhbm5lbCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIHJlYWx0aW1lV2ViU29ja2V0UmVmID0gcGFyYW0ucmVhbHRpbWVXZWJTb2NrZXRSZWYsIG1lc3NhZ2VTdG9yZVJlZiA9IHBhcmFtLm1lc3NhZ2VTdG9yZVJlZiwgY2hhbm5lbCA9IHBhcmFtLmNoYW5uZWwsIG9uTWVzc2FnZSA9IHBhcmFtLm9uTWVzc2FnZSwgdGhyb3R0bGUgPSBwYXJhbS50aHJvdHRsZSwgZ3JvdXBNZXNzYWdlc09uU2VuZCA9IHBhcmFtLmdyb3VwTWVzc2FnZXNPblNlbmQ7XG4gICAgdmFyIG1lc3NhZ2VRdWV1ZVJlZiA9ICgwLCBpbXBvcnRfcmVhY3Q4LnVzZVJlZikoW10pO1xuICAgIHZhciBzZW5kTWVzc2FnZXNJbnRlcnZhbCA9ICgwLCBpbXBvcnRfcmVhY3Q4LnVzZVJlZikoKTtcbiAgICB1c2VNZXNzYWdlcyhtZXNzYWdlU3RvcmVSZWYuY3VycmVudCwgY2hhbm5lbCwgKDAsIGltcG9ydF9yZWFjdDgudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgb25NZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH0sIFtcbiAgICAgICAgb25NZXNzYWdlXG4gICAgXSkpO1xuICAgICgwLCBpbXBvcnRfcmVhY3Q4LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbmRNZXNzYWdlc0ludGVydmFsLmN1cnJlbnQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlUXVldWVSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBncm91cE1lc3NhZ2VzT25TZW5kID8gZ3JvdXBNZXNzYWdlc09uU2VuZChtZXNzYWdlUXVldWVSZWYuY3VycmVudCkgOiBtZXNzYWdlUXVldWVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlUXVldWVSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgbWVzc2FnZXMuZm9yRWFjaChmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWFsdGltZVdlYlNvY2tldFJlZl9jdXJyZW50O1xuICAgICAgICAgICAgICAgIHJldHVybiAoX3JlYWx0aW1lV2ViU29ja2V0UmVmX2N1cnJlbnQgPSByZWFsdGltZVdlYlNvY2tldFJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfcmVhbHRpbWVXZWJTb2NrZXRSZWZfY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlYWx0aW1lV2ViU29ja2V0UmVmX2N1cnJlbnQuc2VuZE1lc3NhZ2UoY2hhbm5lbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdGhyb3R0bGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2xlYXJJbnRlcnZhbChzZW5kTWVzc2FnZXNJbnRlcnZhbC5jdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHRocm90dGxlLFxuICAgICAgICBjaGFubmVsLFxuICAgICAgICBncm91cE1lc3NhZ2VzT25TZW5kXG4gICAgXSk7XG4gICAgdmFyIHNlbmRNZXNzYWdlQ2FsbGJhY2sgPSAoMCwgaW1wb3J0X3JlYWN0OC51c2VDYWxsYmFjaykoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBtZXNzYWdlUXVldWVSZWYuY3VycmVudC5wdXNoKG1lc3NhZ2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZW5kTWVzc2FnZTogc2VuZE1lc3NhZ2VDYWxsYmFja1xuICAgIH07XG59O1xuLy8gc3JjL3Rocm90dGxlLnRzXG52YXIgRGVmYXVsdFRocm90dGxlID0gNTA7XG52YXIgTWluVGhyb3R0bGUgPSAxNTtcbnZhciBNYXhUaHJvdHRsZSA9IDJlMztcbnZhciBnZXRUaHJvdHRsZSA9IGZ1bmN0aW9uKHRocm90dGxlKSB7XG4gICAgaWYgKHRocm90dGxlID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHRUaHJvdHRsZTtcbiAgICB9XG4gICAgaWYgKHRocm90dGxlIDwgTWluVGhyb3R0bGUgfHwgdGhyb3R0bGUgPiBNYXhUaHJvdHRsZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJUaHJvdHRsZSBtdXN0IGJlIGJldHdlZW4gJ1wiLmNvbmNhdChNaW5UaHJvdHRsZSwgXCInIGFuZCAnXCIpLmNvbmNhdChNYXhUaHJvdHRsZSwgXCInLiBEZWZhdWx0ZWQgdG8gJ1wiKS5jb25jYXQoRGVmYXVsdFRocm90dGxlLCBcIidcIikpO1xuICAgICAgICByZXR1cm4gRGVmYXVsdFRocm90dGxlO1xuICAgIH1cbiAgICByZXR1cm4gdGhyb3R0bGU7XG59O1xuLy8gc3JjL3VzZVJlYWx0aW1lQ29ubmVjdGlvbi50c1xudmFyIHVzZVJlYWx0aW1lQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkLCBncm91cElkID0gcGFyYW0uZ3JvdXBJZCwgZ2V0QXV0aFRva2VuID0gcGFyYW0uZ2V0QXV0aFRva2VuLCBwdWJsaWNBdXRoS2V5ID0gcGFyYW0ucHVibGljQXV0aEtleSwgdGhyb3R0bGVPcHRpb24gPSBwYXJhbS50aHJvdHRsZSwgYXV0b3NhdmUgPSBwYXJhbS5hdXRvc2F2ZSwgX3BhY2thZ2UgPSBwYXJhbS5fcGFja2FnZTtcbiAgICB2YXIgY29uZmlnID0gKDAsIGltcG9ydF9yZWFjdDkudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRSZWFsdGltZUNvbmZpZyh7XG4gICAgICAgICAgICBlbnZpcm9ubWVudDogX3BhY2thZ2UgPT09IG51bGwgfHwgX3BhY2thZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wYWNrYWdlLmVudmlyb25tZW50LFxuICAgICAgICAgICAgbG9nZ2luZzogX3BhY2thZ2UgPT09IG51bGwgfHwgX3BhY2thZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wYWNrYWdlLmxvZ2dpbmcsXG4gICAgICAgICAgICBhdXRvc2F2ZTogYXV0b3NhdmVcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIHZhciB0aHJvdHRsZSA9ICgwLCBpbXBvcnRfcmVhY3Q5LnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0VGhyb3R0bGUodGhyb3R0bGVPcHRpb24pO1xuICAgIH0sIFtcbiAgICAgICAgdGhyb3R0bGVPcHRpb25cbiAgICBdKTtcbiAgICB2YXIgX3VzZUF1dGggPSB1c2VBdXRoKHtcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWQsXG4gICAgICAgIGdyb3VwSWQ6IGdyb3VwSWQsXG4gICAgICAgIGdldEF1dGhUb2tlbjogZ2V0QXV0aFRva2VuLFxuICAgICAgICBwdWJsaWNBdXRoS2V5OiBwdWJsaWNBdXRoS2V5XG4gICAgfSksIHRva2VuID0gX3VzZUF1dGgudG9rZW4sIHNvY2tldFVybCA9IF91c2VBdXRoLnNvY2tldFVybDtcbiAgICB2YXIgX3VzZVdlYlNvY2tldCA9IHVzZVdlYlNvY2tldCh7XG4gICAgICAgIHNvY2tldFVybDogc29ja2V0VXJsLFxuICAgICAgICB0b2tlbjogdG9rZW4sXG4gICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgfSksIGNvbm5lY3Rpb25TdGF0dXMgPSBfdXNlV2ViU29ja2V0LnN0YXR1cywgY29ubmVjdGlvblN0YXR1c1JlZiA9IF91c2VXZWJTb2NrZXQuc3RhdHVzUmVmLCB1c2VDaGFubmVsID0gX3VzZVdlYlNvY2tldC51c2VDaGFubmVsO1xuICAgIHVzZVN5c3RlbUNoYW5uZWwoe1xuICAgICAgICB1c2VDaGFubmVsOiB1c2VDaGFubmVsXG4gICAgfSk7XG4gICAgdmFyIF91c2VQcmVzZW5jZUNoYW5uZWwgPSB1c2VQcmVzZW5jZUNoYW5uZWwoe1xuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiBjb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzUmVmOiBjb25uZWN0aW9uU3RhdHVzUmVmLFxuICAgICAgICB1c2VDaGFubmVsOiB1c2VDaGFubmVsLFxuICAgICAgICB0aHJvdHRsZTogdGhyb3R0bGVcbiAgICB9KSwgcHJlc2VuY2VTdGF0dXMgPSBfdXNlUHJlc2VuY2VDaGFubmVsLnN0YXR1cywgdXNlQ29sbGFib3JhdG9ycyA9IF91c2VQcmVzZW5jZUNoYW5uZWwudXNlQ29sbGFib3JhdG9ycywgc3Vic2NyaWJlQ29sbGFib3JhdG9ycyA9IF91c2VQcmVzZW5jZUNoYW5uZWwuc3Vic2NyaWJlQ29sbGFib3JhdG9ycywgdXNlTWUgPSBfdXNlUHJlc2VuY2VDaGFubmVsLnVzZU1lLCBwYXRjaE1lID0gX3VzZVByZXNlbmNlQ2hhbm5lbC5wYXRjaE1lLCBzdWJzY3JpYmVNZSA9IF91c2VQcmVzZW5jZUNoYW5uZWwuc3Vic2NyaWJlTWU7XG4gICAgdmFyIF91c2VCcm9hZGNhc3RDaGFubmVsID0gdXNlQnJvYWRjYXN0Q2hhbm5lbCh7XG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXNSZWY6IGNvbm5lY3Rpb25TdGF0dXNSZWYsXG4gICAgICAgIHVzZUNoYW5uZWw6IHVzZUNoYW5uZWwsXG4gICAgICAgIHRocm90dGxlOiB0aHJvdHRsZVxuICAgIH0pLCBicm9hZGNhc3QgPSBfdXNlQnJvYWRjYXN0Q2hhbm5lbC5icm9hZGNhc3QsIHVzZUJyb2FkY2FzdExpc3RlbmVyID0gX3VzZUJyb2FkY2FzdENoYW5uZWwudXNlQnJvYWRjYXN0TGlzdGVuZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1c1JlZjogY29ubmVjdGlvblN0YXR1c1JlZixcbiAgICAgICAgcHJlc2VuY2VTdGF0dXM6IHByZXNlbmNlU3RhdHVzLFxuICAgICAgICB1c2VDb2xsYWJvcmF0b3JzOiB1c2VDb2xsYWJvcmF0b3JzLFxuICAgICAgICBzdWJzY3JpYmVDb2xsYWJvcmF0b3JzOiBzdWJzY3JpYmVDb2xsYWJvcmF0b3JzLFxuICAgICAgICB1c2VNZTogdXNlTWUsXG4gICAgICAgIHBhdGNoTWU6IHBhdGNoTWUsXG4gICAgICAgIHN1YnNjcmliZU1lOiBzdWJzY3JpYmVNZSxcbiAgICAgICAgYnJvYWRjYXN0OiBicm9hZGNhc3QsXG4gICAgICAgIHVzZUJyb2FkY2FzdExpc3RlbmVyOiB1c2VCcm9hZGNhc3RMaXN0ZW5lcixcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHVzZUNoYW5uZWw6IHVzZUNoYW5uZWxcbiAgICB9O1xufTtcbi8vIHNyYy91c2VSZWFsdGltZURvY3VtZW50LnRzXG52YXIgaW1wb3J0X3JlYWN0MTMgPSByZXF1aXJlKFwicmVhY3RcIik7XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvdXNlRG9jdW1lbnQudHNcbnZhciBpbXBvcnRfcmVhY3QxMiA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC9hdXRvc2F2ZS91c2VEb2N1bWVudEF1dG9zYXZlLnRzXG52YXIgaW1wb3J0X3JlYWN0MTAgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdXNlRG9jdW1lbnRBdXRvc2F2ZSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGNvbmZpZyA9IHBhcmFtLmNvbmZpZywgZG9jdW1lbnRJZCA9IHBhcmFtLmRvY3VtZW50SWQsIHN1YnNjcmlwdGlvbklkUmVmID0gcGFyYW0uc3Vic2NyaXB0aW9uSWRSZWYsIGxvY2FsU3RvcmUgPSBwYXJhbS5sb2NhbFN0b3JlLCBvbkxvY2FsRGF0YSA9IHBhcmFtLm9uTG9jYWxEYXRhLCBvbk5vTG9jYWxEYXRhID0gcGFyYW0ub25Ob0xvY2FsRGF0YTtcbiAgICB2YXIgYXV0b3NhdmVEYXRhYmFzZVJlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VSZWYpKCk7XG4gICAgdmFyIHVuc2F2ZWRDaGFuZ2VzUmVmID0gKDAsIGltcG9ydF9yZWFjdDEwLnVzZVJlZikoZmFsc2UpO1xuICAgIHZhciBsb2NhbENoYW5nZXNSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTAudXNlUmVmKShbXSk7XG4gICAgdmFyIHVucmVtb3ZlZExvY2FsQ2hhbmdlc1JlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VSZWYpKFtdKTtcbiAgICB2YXIgdW5zYXZlZExvY2FsQ2hhbmdlc1JlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VSZWYpKFtdKTtcbiAgICB2YXIgZG9jdW1lbnRNZXRhZGF0YVJlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VSZWYpKCk7XG4gICAgdmFyIG1hcmtGb3JMb2NhbFNhdmluZyA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VDYWxsYmFjaykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHVuc2F2ZWRDaGFuZ2VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2F2ZUxvY2FsQ2hhbmdlcyA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VDYWxsYmFjaykoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICBpZiAoIWF1dG9zYXZlRGF0YWJhc2VSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudE1ldGFkYXRhUmVmLmN1cnJlbnQubG9jYWxPbmx5KSB7XG4gICAgICAgICAgICBtYXJrRm9yTG9jYWxTYXZpbmcoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bnNhdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgbWFya0ZvckxvY2FsU2F2aW5nKCk7XG4gICAgfSwgW10pO1xuICAgICgwLCBpbXBvcnRfcmVhY3QxMC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWRvY3VtZW50SWQgfHwgIWNvbmZpZy5hdXRvc2F2ZS5lbmFibGVkKSB7XG4gICAgICAgICAgICBsb2NhbENoYW5nZXNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdXRvc2F2ZURhdGFiYXNlID0gZ2V0SW5kZXhlZEF1dG9zYXZlSW5zdGFuY2Uoe1xuICAgICAgICAgICAgc3RvcmVOYW1lUG9zdGZpeDogY29uZmlnLmF1dG9zYXZlLnN0b3JlTmFtZVBvc3RmaXgsXG4gICAgICAgICAgICBkaXNhYmxlV2FybmluZzogY29uZmlnLmF1dG9zYXZlLmRpc2FibGVXYXJuaW5nXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG9hZERvY3VtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX3JlZiA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuYWJsZWQsIGRvY3VtZW50TWV0YWRhdGFQcm9taXNlLCBmcmFnbWVudFByb21pc2UsIGxvY2FsQ2hhbmdlc1Byb21pc2UsIGRvY3VtZW50TWV0YWRhdGEsIGZyYWdtZW50LCBsb2NhbENoYW5nZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9zYXZlRGF0YWJhc2UuY29ubmVjdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmFibGVkID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b3NhdmVEYXRhYmFzZVJlZi5jdXJyZW50ID0gYXV0b3NhdmVEYXRhYmFzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1ldGFkYXRhUHJvbWlzZSA9IGF1dG9zYXZlRGF0YWJhc2UuZ2V0RG9jdW1lbnRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFByb21pc2UgPSBhdXRvc2F2ZURhdGFiYXNlLmdldEZyYWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1Byb21pc2UgPSBhdXRvc2F2ZURhdGFiYXNlLmdldE9wZXJhdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNZXRhZGF0YVByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TWV0YWRhdGEgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50UHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1Byb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hhbmdlcyA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50TWV0YWRhdGEgJiYgZnJhZ21lbnQgJiYgbG9jYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uTG9jYWxEYXRhKGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNZXRhZGF0YVJlZi5jdXJyZW50ID0gZG9jdW1lbnRNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQgPSBsb2NhbENoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Ob0xvY2FsRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zYXZlZENoYW5nZXM6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQ2hhbmdlc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2FkRG9jdW1lbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgbG9hZERvY3VtZW50KCkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXV0b3NhdmVEYXRhYmFzZS5kaXNjb25uZWN0KCkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgZG9jdW1lbnRJZFxuICAgIF0pO1xuICAgICgwLCBpbXBvcnRfcmVhY3QxMC51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWNvbmZpZy5hdXRvc2F2ZS5lbmFibGVkIHx8ICFkb2N1bWVudElkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRpbWVyID0gc2V0SW50ZXJ2YWwoLyojX19QVVJFX18qLyBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGF1dG9zYXZlRGF0YWJhc2UsIGNoYW5nZXNUb1NhdmUsIGNoYW5nZXNUb1JlbW92ZSwgZG9jdW1lbnRNZXRhZGF0YVRvU2F2ZSwgZnJhZ21lbnRUb1NhdmUsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24sIF9kaWRJdGVyYXRvckVycm9yLCBfaXRlcmF0b3JFcnJvciwgX2l0ZXJhdG9yLCBfc3RlcCwgcmVxdWVzdCwgXywgXzEsIGVycm9yLCBlcnIsIHByb21pc2VzLCBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSwgX2RpZEl0ZXJhdG9yRXJyb3IxLCBfaXRlcmF0b3JFcnJvcjEsIF9pdGVyYXRvcjEsIF9zdGVwMSwgcmVxdWVzdDEsIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yLCBfZGlkSXRlcmF0b3JFcnJvcjIsIF9pdGVyYXRvckVycm9yMiwgX2l0ZXJhdG9yMiwgX3N0ZXAyLCBwcm9taXNlLCBlcnJvcjEsIGVycjtcbiAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVuc2F2ZWRDaGFuZ2VzUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9zYXZlRGF0YWJhc2UgPSBhdXRvc2F2ZURhdGFiYXNlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dG9zYXZlRGF0YWJhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXNUb1NhdmUgPSB1bnNhdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzVG9SZW1vdmUgPSB1bnJlbW92ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TWV0YWRhdGFUb1NhdmUgPSBkb2N1bWVudE1ldGFkYXRhUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFRvU2F2ZSA9IGxvY2FsU3RvcmUuZ2V0Um9vdCgpLmZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZW1vdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc2F2ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQgPSBsb2NhbENoYW5nZXNSZWYuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhY2hhbmdlc1RvUmVtb3ZlLmluY2x1ZGVzKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNhdmVkQ2hhbmdlc1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b3NhdmVEYXRhYmFzZS5zYXZlRG9jdW1lbnRNZXRhZGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TWV0YWRhdGE6IGRvY3VtZW50TWV0YWRhdGFUb1NhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvc2F2ZURhdGFiYXNlLnNhdmVGcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFRvU2F2ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBjaGFuZ2VzVG9TYXZlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA5XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8xID0gKF8gPSBsb2NhbENoYW5nZXNSZWYuY3VycmVudCkucHVzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvc2F2ZURhdGFiYXNlLnNhdmVPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF8xLmFwcGx5KF8sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA4XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IxID0gZmFsc2UsIF9pdGVyYXRvckVycm9yMSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKF9pdGVyYXRvcjEgPSBjaGFuZ2VzVG9SZW1vdmVbU3ltYm9sLml0ZXJhdG9yXSgpOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xID0gKF9zdGVwMSA9IF9pdGVyYXRvcjEubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEgPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goYXV0b3NhdmVEYXRhYmFzZS5yZW1vdmVPcGVyYXRpb24ocmVxdWVzdDEuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvcjEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMSA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xICYmIF9pdGVyYXRvcjEucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2UsIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yMiA9IHByb21pc2VzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE0O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gKF9zdGVwMiA9IF9pdGVyYXRvcjIubmV4dCgpKS5kb25lKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE5XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZSA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE4XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yMSA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIgPSBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMiA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiAmJiBfaXRlcmF0b3IyLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIDUwMCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgZG9jdW1lbnRJZFxuICAgIF0pO1xuICAgIHZhciBnZXRMb2NhbENoYW5nZXNUb1N5bmMgPSAoMCwgaW1wb3J0X3JlYWN0MTAudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWF1dG9zYXZlRGF0YWJhc2VSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudE1ldGFkYXRhUmVmLmN1cnJlbnQubG9jYWxPbmx5KSB7XG4gICAgICAgICAgICB2YXIgc2V0Um9vdFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUlkOiB1bmlxdWVJZCgpLFxuICAgICAgICAgICAgICAgIHR5cGU6IE9wc01lc3NhZ2VUeXBlLFxuICAgICAgICAgICAgICAgIHN1YklkOiBzdWJzY3JpcHRpb25JZFJlZi5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3A6IERvY3VtZW50T3BlcmF0aW9uUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBsb2NhbFN0b3JlLmdldFJvb3QoKS5mcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVuc2F2ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudCA9IFtcbiAgICAgICAgICAgICAgICBzZXRSb290UmVxdWVzdFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGRvY3VtZW50TWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgICAgICBsb2NhbE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHVuc2F2ZWRDaGFuZ2VzOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFya0ZvckxvY2FsU2F2aW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHNldFJvb3RSZXF1ZXN0XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbENoYW5nZXMgPSBfdG9fY29uc3VtYWJsZV9hcnJheShsb2NhbENoYW5nZXNSZWYuY3VycmVudCkuY29uY2F0KF90b19jb25zdW1hYmxlX2FycmF5KHVuc2F2ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudCkpO1xuICAgICAgICBsb2NhbENoYW5nZXMgPSBsb2NhbENoYW5nZXMuZmlsdGVyKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAhdW5yZW1vdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIubWVzc2FnZUlkID09PSByZXF1ZXN0Lm1lc3NhZ2VJZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsQ2hhbmdlcztcbiAgICB9LCBbXSk7XG4gICAgdmFyIHVwZGF0ZUxvY2FsQ2hhbmdlcyA9ICgwLCBpbXBvcnRfcmVhY3QxMC51c2VDYWxsYmFjaykoZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIHJlbW92ZWRDaGFuZ2VzID0gcGFyYW0ucmVtb3ZlZENoYW5nZXMsIGFkZGVkQ2hhbmdlcyA9IHBhcmFtLmFkZGVkQ2hhbmdlcztcbiAgICAgICAgdmFyIF91bnJlbW92ZWRMb2NhbENoYW5nZXNSZWZfY3VycmVudCwgX3Vuc2F2ZWRMb2NhbENoYW5nZXNSZWZfY3VycmVudDtcbiAgICAgICAgaWYgKCFhdXRvc2F2ZURhdGFiYXNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB1bnNhdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQgPSB1bnNhdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uKG9wTWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuICFyZW1vdmVkQ2hhbmdlcy5pbmNsdWRlcyhvcE1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvY2FsQ2hhbmdlc1RvUmVtb3ZlID0gbG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQuZmlsdGVyKGZ1bmN0aW9uKG9wTWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWRDaGFuZ2VzLmluY2x1ZGVzKG9wTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAoX3VucmVtb3ZlZExvY2FsQ2hhbmdlc1JlZl9jdXJyZW50ID0gdW5yZW1vdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQpLnB1c2guYXBwbHkoX3VucmVtb3ZlZExvY2FsQ2hhbmdlc1JlZl9jdXJyZW50LCBfdG9fY29uc3VtYWJsZV9hcnJheShsb2NhbENoYW5nZXNUb1JlbW92ZSkpO1xuICAgICAgICAoX3Vuc2F2ZWRMb2NhbENoYW5nZXNSZWZfY3VycmVudCA9IHVuc2F2ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudCkucHVzaC5hcHBseShfdW5zYXZlZExvY2FsQ2hhbmdlc1JlZl9jdXJyZW50LCBfdG9fY29uc3VtYWJsZV9hcnJheShhZGRlZENoYW5nZXMpKTtcbiAgICAgICAgbWFya0ZvckxvY2FsU2F2aW5nKCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBhY2tub3dsZWRnZUxvY2FsQ2hhbmdlID0gKDAsIGltcG9ydF9yZWFjdDEwLnVzZUNhbGxiYWNrKShmdW5jdGlvbihhY2tNZXNzYWdlSWQpIHtcbiAgICAgICAgaWYgKCFhdXRvc2F2ZURhdGFiYXNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5zYXZlZExvY2FsQ2hhbmdlSW5kZXggPSB1bnNhdmVkTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQuZmluZEluZGV4KGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByLm1lc3NhZ2VJZCA9PT0gYWNrTWVzc2FnZUlkO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVuc2F2ZWRMb2NhbENoYW5nZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHVuc2F2ZWRMb2NhbENoYW5nZXNSZWYuY3VycmVudC5zcGxpY2UodW5zYXZlZExvY2FsQ2hhbmdlSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGxvY2FsQ2hhbmdlID0gbG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIubWVzc2FnZUlkID09PSBhY2tNZXNzYWdlSWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsb2NhbENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHVucmVtb3ZlZExvY2FsQ2hhbmdlc1JlZi5jdXJyZW50LnB1c2gobG9jYWxDaGFuZ2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZG4ndCBmaW5kIGxvY2FsIGNoYW5nZSBmb3IgYWNrZWQgb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1hcmtGb3JMb2NhbFNhdmluZygpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzYXZlTG9jYWxDaGFuZ2VzOiBzYXZlTG9jYWxDaGFuZ2VzLFxuICAgICAgICBtYXJrRm9yTG9jYWxTYXZpbmc6IG1hcmtGb3JMb2NhbFNhdmluZyxcbiAgICAgICAgZ2V0TG9jYWxDaGFuZ2VzVG9TeW5jOiBnZXRMb2NhbENoYW5nZXNUb1N5bmMsXG4gICAgICAgIHVwZGF0ZUxvY2FsQ2hhbmdlczogdXBkYXRlTG9jYWxDaGFuZ2VzLFxuICAgICAgICBhY2tub3dsZWRnZUxvY2FsQ2hhbmdlOiBhY2tub3dsZWRnZUxvY2FsQ2hhbmdlXG4gICAgfTtcbn07XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvc3RvcmUvdGVzdHMvc3RvcmVFcXVhbC50c1xudmFyIGdldEZvcm1hdHRlZE9iaiA9IGZ1bmN0aW9uKGQpIHtcbiAgICBpZiAoaXNMaXN0KGQpKSB7XG4gICAgICAgIHJldHVybiBkLm1hcChmdW5jdGlvbihkMSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEZvcm1hdHRlZE9iaihkMSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgbmV3T2JqZWN0ID0ge307XG4gICAgT2JqZWN0LmtleXMoZCkuc29ydCgpLmZvckVhY2goZnVuY3Rpb24oa2V5LCBpKSB7XG4gICAgICAgIGlmIChkW2tleV0gPT09IHZvaWQgMCB8fCBkW2tleV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNMaXN0KGRba2V5XSkgfHwgaXNNYXAoZFtrZXldKSkge1xuICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBnZXRGb3JtYXR0ZWRPYmooZFtrZXldKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBuZXdPYmplY3Rba2V5XSA9IGRba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3T2JqZWN0O1xufTtcbnZhciBhcmVTdG9yZXNFcXVhbCA9IGZ1bmN0aW9uKGQxLCBkMikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50c0VxdWFsOiBKU09OLnN0cmluZ2lmeShnZXRGb3JtYXR0ZWRPYmooZDEuZG9jdW1lbnQpKSA9PT0gSlNPTi5zdHJpbmdpZnkoZ2V0Rm9ybWF0dGVkT2JqKGQyLmRvY3VtZW50KSksXG4gICAgICAgIGZyYWdtZW50c0VxdWFsOiBKU09OLnN0cmluZ2lmeShnZXRGb3JtYXR0ZWRPYmooZDEuZnJhZ21lbnQpKSA9PT0gSlNPTi5zdHJpbmdpZnkoZ2V0Rm9ybWF0dGVkT2JqKGQyLmZyYWdtZW50KSksXG4gICAgICAgIGZyYWdtZW50SWRUb1BhdGhzRXF1YWw6IEpTT04uc3RyaW5naWZ5KGdldEZvcm1hdHRlZE9iaihkMS5mcmFnbWVudElkVG9QYXRoKSkgPT09IEpTT04uc3RyaW5naWZ5KGdldEZvcm1hdHRlZE9iaihkMi5mcmFnbWVudElkVG9QYXRoKSlcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC9zdG9yZS91c2VSZWFsdGltZVN0b3JlLnRzXG52YXIgaW1wb3J0X2ltbWVyMyA9IHJlcXVpcmUoXCJpbW1lclwiKTtcbnZhciBpbXBvcnRfcmVhY3QxMSA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbnZhciBpbXBvcnRfenVzdGFuZDMgPSByZXF1aXJlKFwienVzdGFuZFwiKTtcbnZhciBpbXBvcnRfbWlkZGxld2FyZTMgPSByZXF1aXJlKFwienVzdGFuZC9taWRkbGV3YXJlXCIpO1xuLy8gc3JjL2NoYW5uZWxzL2RvY3VtZW50L3N0b3JlL3V0aWxzL2NvbmZsaWN0T3BlcmF0aW9uVXRpbHMudHNcbnZhciBpbXBvcnRfaW1tZXIgPSByZXF1aXJlKFwiaW1tZXJcIik7XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvc3RvcmUvdXRpbHMvcGF0aFV0aWxzLnRzXG52YXIgY3JlYXRlRnJhZ21lbnRJZFRvUGF0aCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gcGFyYW0uZnJhZ21lbnQ7XG4gICAgcmV0dXJuIGFkZEZyYWdtZW50SWRUb1BhdGgoe1xuICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IHt9XG4gICAgfSk7XG59O1xudmFyIGFkZEZyYWdtZW50SWRUb1BhdGggPSBmdW5jdGlvbihwYXJhbSkge1xuICAgIHZhciBmcmFnbWVudCA9IHBhcmFtLmZyYWdtZW50LCBmcmFnbWVudElkVG9QYXRoID0gcGFyYW0uZnJhZ21lbnRJZFRvUGF0aCwgcGF0aCA9IHBhcmFtLnBhdGg7XG4gICAgdmFyIHF1ZXVlID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiBbXVxuICAgICAgICB9XG4gICAgXTtcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBmcmFnbWVudElkVG9QYXRoW2l0ZW0uZnJhZ21lbnQuaWRdID0gaXRlbS5wYXRoO1xuICAgICAgICBpZiAoaXRlbS5mcmFnbWVudC50eXBlID09IDIgLyogTWFwICovICB8fCBpdGVtLmZyYWdtZW50LnR5cGUgPT0gMSAvKiBMaXN0ICovICkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IGl0ZW0uZnJhZ21lbnQudmFsdWU7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKG1hcClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViUGF0aCA9IF90b19jb25zdW1hYmxlX2FycmF5KGl0ZW0ucGF0aCkuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YktleVxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcEl0ZW0gPSBtYXBbc3ViS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogbWFwSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHN1YlBhdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRJZFRvUGF0aDtcbn07XG52YXIgcmVtb3ZlRnJhZ21lbnRJZFRvUGF0aCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gcGFyYW0uZnJhZ21lbnQsIGZyYWdtZW50SWRUb1BhdGggPSBwYXJhbS5mcmFnbWVudElkVG9QYXRoO1xuICAgIHZhciBxdWV1ZSA9IFtcbiAgICAgICAgZnJhZ21lbnRcbiAgICBdO1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApe1xuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudElkVG9QYXRoW2l0ZW0uaWRdO1xuICAgICAgICBpZiAoaXRlbS50eXBlID09IDIgLyogTWFwICovICB8fCBpdGVtLnR5cGUgPT0gMSAvKiBMaXN0ICovICkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IGl0ZW0udmFsdWU7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IE9iamVjdC5rZXlzKG1hcClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YktleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwSXRlbSA9IG1hcFtzdWJLZXldO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG1hcEl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50SWRUb1BhdGg7XG59O1xuLy8gc3JjL2NoYW5uZWxzL2RvY3VtZW50L3N0b3JlL3V0aWxzL2ltbXV0YWJsZUZyYWdtZW50LnRzXG52YXIgY3JlYXRlSW1tdXRhYmxlRnJhZ21lbnQgPSBmdW5jdGlvbihmcmFnbWVudCwgZnJhZ21lbnRJZFRvUGF0aCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbW11dGFibGVGcmFnbWVudChmcmFnbWVudCwgZnJhZ21lbnRJZFRvUGF0aCwgY29uZmlnKTtcbn07XG52YXIgSW1tdXRhYmxlRnJhZ21lbnQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEltbXV0YWJsZUZyYWdtZW50KGZyYWdtZW50LCBmcmFnbWVudElkVG9QYXRoLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX2NsYXNzX2NhbGxfY2hlY2sodGhpcywgSW1tdXRhYmxlRnJhZ21lbnQpO1xuICAgICAgICAvKipcbiAgICAgKiBHZXQgYW4gaW1tdXRhYmxlIHN1YiBmcmFnbWVudHMgbGlzdCBiYXNlZCBvbiBhbiBpbW1lciBwYXRoXG4gICAgICogT25seSBtYWtlIGl0ZW1zIHdoaWNoIGFyZSB3aXRoaW4gaW5kZXggW2l0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXgsIGl0ZW1JbW11dGFiaWxpdHlUb0luZGV4XVxuICAgICAqLyB0aGlzLl9nZXRMaXN0RnJhZ21lbnRzID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciBsaXN0RnJhZ21lbnQgPSBwYXJhbS5saXN0RnJhZ21lbnQsIGxpc3RJbW11dGFibGVQYXRoID0gcGFyYW0ubGlzdEltbXV0YWJsZVBhdGgsIGl0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXggPSBwYXJhbS5pdGVtSW1tdXRhYmlsaXR5RnJvbUluZGV4LCBpdGVtSW1tdXRhYmlsaXR5VG9JbmRleCA9IHBhcmFtLml0ZW1JbW11dGFiaWxpdHlUb0luZGV4O1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMobGlzdEZyYWdtZW50LnZhbHVlKS5tYXAoZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgIHZhciBzdWJJbW11dGFibGVQYXRoID0gX3RoaXMuX2NvbWJpbmVJbW11dGFibGVQYXRocyhsaXN0SW1tdXRhYmxlUGF0aCwgZi5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faXNQYXRoSW1tdXRhYmxlKHN1YkltbXV0YWJsZVBhdGgpICYmIGYucGFyZW50TGlzdEluZGV4ID49IGl0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXggJiYgZi5wYXJlbnRMaXN0SW5kZXggPD0gaXRlbUltbXV0YWJpbGl0eVRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2FkZEltbXV0YWJsZVBhdGgoc3ViSW1tdXRhYmxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGYgPSBfb2JqZWN0X3NwcmVhZCh7fSwgZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnZhbHVlID0gX29iamVjdF9zcHJlYWQoe30sIGYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RGcmFnbWVudC52YWx1ZVtmLmlkXSA9IGY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgIHRoaXMuX2ZyYWdtZW50SWRUb1BhdGggPSBmcmFnbWVudElkVG9QYXRoO1xuICAgICAgICB0aGlzLl9pbW11dGFibGVQYXRocyA9IHt9O1xuICAgICAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoSW1tdXRhYmxlRnJhZ21lbnQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImdldEZyYWdtZW50XCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnJhZ21lbnQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiZ2V0RnJhZ21lbnRJZFRvUGF0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZyYWdtZW50SWRUb1BhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYWdtZW50SWRUb1BhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0cmluZyBmcm9tIGEgcGF0aFxuICAgKi8ga2V5OiBcIl9jcmVhdGVJbW11dGFibGVQYXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUltbXV0YWJsZVBhdGgocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwKS5yZXBsYWNlKC9cXC4vZywgXCJcXFxcLlwiKTtcbiAgICAgICAgICAgICAgICB9KS5qb2luKFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAqIENvbWJpbmUgdHdvIGltbXV0YWJsZSBwYXRoc1xuICAgKi8ga2V5OiBcIl9jb21iaW5lSW1tdXRhYmxlUGF0aHNcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tYmluZUltbXV0YWJsZVBhdGhzKHBhdGgxLCBwYXRoMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwYXRoMSwgXCIuXCIpLmNvbmNhdChwYXRoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBDaGVjayBpZiBwYXRoIGhhcyBiZWVuIG1hZGUgaW1tdXRhYmxlXG4gICAqLyBrZXk6IFwiX2lzUGF0aEltbXV0YWJsZVwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pc1BhdGhJbW11dGFibGUocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2ltbXV0YWJsZVBhdGhzW3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogQWRkIGltbXV0YWJsZSBwYXRoXG4gICAqLyBrZXk6IFwiX2FkZEltbXV0YWJsZVBhdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkSW1tdXRhYmxlUGF0aChwYXRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW1tdXRhYmxlUGF0aHNbcGF0aF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogUmVtb3ZlIGltbXV0YWJsZSBwYXRoXG4gICAqLyBrZXk6IFwiX3JlbW92ZUltbXV0YWJsZVBhdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW1tdXRhYmxlUGF0aChwYXRoKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ltbXV0YWJsZVBhdGhzW3BhdGhdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogR2V0IGZyYWdtZW50IHBhdGggZnJvbSBpbW1lciBwYXRoXG4gICAqLyBrZXk6IFwiX2dldEZyYWdtZW50UGF0aEZyb21JbW1lclBhdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RnJhZ21lbnRQYXRoRnJvbUltbWVyUGF0aChpbW1lclBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLCBfbG9vcCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1YlBhdGggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJGcmFnbWVudC50eXBlID09PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SW5kZXggPSBpbW1lclBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViU3ViRnJhZ21lbnQgPSBPYmplY3QudmFsdWVzKHN1YkZyYWdtZW50LnZhbHVlKS5maW5kKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZi5wYXJlbnRMaXN0SW5kZXggPT09IGxpc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpc19fY29uZmlnID0gX3RoaXMuX2NvbmZpZykgPT09IG51bGwgfHwgX3RoaXNfX2NvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfX2NvbmZpZy5sb2dnaW5nLmxpc3RGcmFnbWVudEluZGV4ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXN1YlN1YkZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIHN1YiBmcmFnbWVudCB3aXRoIGxpc3QgaW5kZXggJ1wiLmNvbmNhdChsaXN0SW5kZXgsIFwiJ1wiKSwgaW1tZXJQYXRoLCBsaXN0SW5kZXgsIGNsb25lKHN1YkZyYWdtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnTGlzdEZyYWdtZW50SW5kZXhlcyhzdWJGcmFnbWVudCwgXCJfZ2V0RnJhZ21lbnRQYXRoRnJvbUltbWVyUGF0aFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlBhdGggPSBzdWJTdWJGcmFnbWVudC5pZDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YlBhdGggPSBpbW1lclBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ViRnJhZ21lbnQgPSBzdWJGcmFnbWVudC52YWx1ZVtzdWJQYXRoXTtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRQYXRoLnB1c2goc3ViUGF0aCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRQYXRoID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHN1YkZyYWdtZW50ID0gdGhpcy5fZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGltbWVyUGF0aC5sZW5ndGg7ICsraSlfbG9vcChpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogR2V0IGFuIGltbXV0YWJsZSBzdWIgZnJhZ21lbnQgYmFzZWQgb24gYSBmcmFnbWVudCBwYXRoXG4gICAqLyBrZXk6IFwiX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGgocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IHBhcmFtLnBhdGg7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5fZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGltbXV0YWJsZVBhdGggPSBcIlwiO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXRoSW1tdXRhYmxlKGltbXV0YWJsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEltbXV0YWJsZVBhdGgoaW1tdXRhYmxlUGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gX29iamVjdF9zcHJlYWQoe30sIGZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC52YWx1ZSA9IF9vYmplY3Rfc3ByZWFkKHt9LCBmcmFnbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN1YkZyYWdtZW50ID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViRnJhZ21lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGltbXV0YWJsZVN1YlBhdGggPSB0aGlzLl9jcmVhdGVJbW11dGFibGVQYXRoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpbW11dGFibGVQYXRoID0gaW1tdXRhYmxlUGF0aCA/IHRoaXMuX2NvbWJpbmVJbW11dGFibGVQYXRocyhpbW11dGFibGVQYXRoLCBpbW11dGFibGVTdWJQYXRoKSA6IGltbXV0YWJsZVN1YlBhdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0T3JNYXAgPSBzdWJGcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTdWJGcmFnbWVudCA9IGxpc3RPck1hcC52YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNQYXRoSW1tdXRhYmxlKGltbXV0YWJsZVBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRJbW11dGFibGVQYXRoKGltbXV0YWJsZVBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN1YkZyYWdtZW50ID0gX29iamVjdF9zcHJlYWQoe30sIG5leHRTdWJGcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN1YkZyYWdtZW50LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTdWJGcmFnbWVudC52YWx1ZSA9IF9vYmplY3Rfc3ByZWFkKHt9LCBuZXh0U3ViRnJhZ21lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdE9yTWFwLnZhbHVlW2luZGV4XSA9IG5leHRTdWJGcmFnbWVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJGcmFnbWVudCA9IG5leHRTdWJGcmFnbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogc3ViRnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZVBhdGg6IGltbXV0YWJsZVBhdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogR2V0IGEgZnJhZ21lbnQgYW5kIGEgcGFyZW50IGZyYWdtZW50IGZyb20gZnJhZ21lbnQgaWRcbiAgICovIGtleTogXCJfZ2V0RnJhZ21lbnRBbmRQYXJlbnRGcmFnbWVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRGcmFnbWVudEFuZFBhcmVudEZyYWdtZW50KHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50UGF0aCA9IHBhcmFtLmZyYWdtZW50UGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aCA9IHRoaXMuX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH0pLCBmcmFnbWVudCA9IF90aGlzX19nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGguZnJhZ21lbnQsIGZyYWdtZW50SW1tdXRhYmxlUGF0aCA9IF90aGlzX19nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGguaW1tdXRhYmxlUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50RnJhZ21lbnRQYXRoID0gdGhpcy5fZnJhZ21lbnRJZFRvUGF0aFtmcmFnbWVudC5wYXJlbnRJZF07XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzX19nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGgxID0gdGhpcy5fZ2V0RnJhZ21lbnRGcm9tRnJhZ21lbnRQYXRoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyZW50RnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSksIHBhcmVudEZyYWdtZW50ID0gX3RoaXNfX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aDEuZnJhZ21lbnQsIHBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aCA9IF90aGlzX19nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGgxLmltbXV0YWJsZVBhdGg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudEltbXV0YWJsZVBhdGg6IGZyYWdtZW50SW1tdXRhYmxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRGcmFnbWVudFBhdGg6IHBhcmVudEZyYWdtZW50UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnRJbW11dGFibGVQYXRoOiBwYXJlbnRGcmFnbWVudEltbXV0YWJsZVBhdGhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgd2l0aCBhbiBpbW1lciBwYXRoXG4gICAqLyBrZXk6IFwiaW5zZXJ0QXRJbW1lclBhdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRBdEltbWVyUGF0aChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRlZEZyYWdtZW50ID0gcGFyYW0uaW5zZXJ0ZWRGcmFnbWVudCwgcGFyZW50SW1tZXJQYXRoID0gcGFyYW0ucGFyZW50SW1tZXJQYXRoLCBpbmRleCA9IHBhcmFtLmluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRGcmFnbWVudFBhdGggPSB0aGlzLl9nZXRGcmFnbWVudFBhdGhGcm9tSW1tZXJQYXRoKHBhcmVudEltbWVyUGF0aCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydEZyYWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudDogaW5zZXJ0ZWRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnRQYXRoOiBwYXJlbnRGcmFnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAvKipcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgaW5zaWRlIGEgc3BlY2lmaWMgcGFyZW50IGZyYWdtZW50IGlkXG4gICAqLyBrZXk6IFwiaW5zZXJ0V2l0aEZyYWdtZW50SWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRXaXRoRnJhZ21lbnRJZChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRlZEZyYWdtZW50ID0gcGFyYW0uaW5zZXJ0ZWRGcmFnbWVudCwgcGFyZW50RnJhZ21lbnRJZCA9IHBhcmFtLnBhcmVudEZyYWdtZW50SWQ7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEZyYWdtZW50UGF0aCA9IHRoaXMuX2ZyYWdtZW50SWRUb1BhdGhbcGFyZW50RnJhZ21lbnRJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRGcmFnbWVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydEZyYWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudDogaW5zZXJ0ZWRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnRQYXRoOiBwYXJlbnRGcmFnbWVudFBhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgZnJhZ21lbnQgcGF0aFxuICAgKi8ga2V5OiBcIl9pbnNlcnRGcmFnbWVudFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRGcmFnbWVudChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRlZEZyYWdtZW50ID0gcGFyYW0uaW5zZXJ0ZWRGcmFnbWVudCwgcGFyZW50RnJhZ21lbnRQYXRoID0gcGFyYW0ucGFyZW50RnJhZ21lbnRQYXRoLCBpbmRleCA9IHBhcmFtLmluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19fY29uZmlnO1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19fZ2V0RnJhZ21lbnRGcm9tRnJhZ21lbnRQYXRoID0gdGhpcy5fZ2V0RnJhZ21lbnRGcm9tRnJhZ21lbnRQYXRoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyZW50RnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSksIHBhcmVudEZyYWdtZW50ID0gX3RoaXNfX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aC5mcmFnbWVudCwgcGFyZW50RnJhZ21lbnRJbW11dGFibGVQYXRoID0gX3RoaXNfX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aC5pbW11dGFibGVQYXRoO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudEluZGV4ID0gcGFyZW50RnJhZ21lbnQudHlwZSA9PT0gMSAvKiBMaXN0ICovICA/IGluc2VydGVkRnJhZ21lbnQuaWQgOiBpbmRleCA/IGluZGV4IDogaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRNYXBLZXk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQudmFsdWVbZnJhZ21lbnRJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGluc2VydGVkSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEZyYWdtZW50LnR5cGUgPT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzX19jb25maWcxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydGVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4ID0gb2xkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0RnJhZ21lbnRzID0gdGhpcy5fZ2V0TGlzdEZyYWdtZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEltbXV0YWJsZVBhdGg6IHBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXg6IGluc2VydGVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUltbXV0YWJpbGl0eVRvSW5kZXg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG9JbmRleCA9IGluc2VydGVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkZWRJbmRleCA9IHRvSW5kZXggPj0gbGlzdEZyYWdtZW50cy5sZW5ndGggPyBsaXN0RnJhZ21lbnRzLmxlbmd0aCA6IHRvSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4ID0gYWRkZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpc19fY29uZmlnMSA9IHRoaXMuX2NvbmZpZykgPT09IG51bGwgfHwgX3RoaXNfX2NvbmZpZzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX19jb25maWcxLmxvZ2dpbmcubGlzdEZyYWdtZW50SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMaXN0RnJhZ21lbnRJbmRleGVzKHBhcmVudEZyYWdtZW50LCBcIkFib3V0IHRvIGluc2VydCBhdCBcIi5jb25jYXQoYWRkZWRJbmRleCwgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW9sZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IGxpc3RGcmFnbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5wYXJlbnRMaXN0SW5kZXggPj0gYWRkZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQucGFyZW50TGlzdEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkSW5kZXggPSBhZGRlZEluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZEZyYWdtZW50LnBhcmVudE1hcEtleSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGVkSW5kZXggPSBpbnNlcnRlZEZyYWdtZW50LnBhcmVudE1hcEtleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyYWdtZW50SWRUb1BhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IG9sZEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogdGhpcy5fZnJhZ21lbnRJZFRvUGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50UGF0aCA9IF90b19jb25zdW1hYmxlX2FycmF5KHBhcmVudEZyYWdtZW50UGF0aCkuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJbmRleFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGFkZEZyYWdtZW50SWRUb1BhdGgoe1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogaW5zZXJ0ZWRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogdGhpcy5fZnJhZ21lbnRJZFRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkSW1tdXRhYmxlUGF0aCh0aGlzLl9jb21iaW5lSW1tdXRhYmxlUGF0aHMocGFyZW50RnJhZ21lbnRJbW11dGFibGVQYXRoLCBmcmFnbWVudEluZGV4KSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRJZCA9IHBhcmVudEZyYWdtZW50LmlkO1xuICAgICAgICAgICAgICAgIHBhcmVudEZyYWdtZW50LnZhbHVlW2ZyYWdtZW50SW5kZXhdID0gaW5zZXJ0ZWRGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoKChfdGhpc19fY29uZmlnID0gdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19fY29uZmlnLmxvZ2dpbmcubGlzdEZyYWdtZW50SW5kZXhlcykgJiYgcGFyZW50RnJhZ21lbnQudHlwZSA9PT0gMSAvKiBMaXN0ICovICkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xpc3RGcmFnbWVudEluZGV4ZXMocGFyZW50RnJhZ21lbnQsIFwiSW5zZXJ0ZWQgYXQgXCIuY29uY2F0KGluc2VydGVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4LCBcIi4gXCIpLmNvbmNhdChvbGRGcmFnbWVudCA/IFwiUmVwbGFjZWQgb2xkIGZyYWdtZW50LCBpdHMgaW5kZXggd2FzIFwiLmNvbmNhdChvbGRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXgpIDogXCJEaWQgbm90IHJlcGxhY2Ugb2xkIGZyYWdtZW50XCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudDogaW5zZXJ0ZWRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRJbmRleDogaW5zZXJ0ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRGcmFnbWVudFBhdGg6IHBhcmVudEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCB3aXRoIGFuIGltbWVyIHBhdGhcbiAgICovIGtleTogXCJkZWxldGVBdEltbWVyUGF0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUF0SW1tZXJQYXRoKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltbWVyUGF0aCA9IHBhcmFtLmltbWVyUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRQYXRoID0gdGhpcy5fZ2V0RnJhZ21lbnRQYXRoRnJvbUltbWVyUGF0aChpbW1lclBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxldGVGcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50UGF0aDogZnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCB3aXRoIGEgc3BlY2lmaWMgZnJhZ21lbnQgaWRcbiAgICovIGtleTogXCJkZWxldGVXaXRoRnJhZ21lbnRJZFwiLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZVdpdGhGcmFnbWVudElkKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50SWQgPSBwYXJhbS5mcmFnbWVudElkO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudFBhdGggPSB0aGlzLl9mcmFnbWVudElkVG9QYXRoW2ZyYWdtZW50SWRdO1xuICAgICAgICAgICAgICAgIGlmICghZnJhZ21lbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWxldGVGcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50UGF0aDogZnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBEZWxldGUgYSBmcmFnbWVudCBhdCBhIGZyYWdtZW50IHBhdGhcbiAgICovIGtleTogXCJfZGVsZXRlRnJhZ21lbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlRnJhZ21lbnQocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRQYXRoID0gcGFyYW0uZnJhZ21lbnRQYXRoO1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudFBhcmVudFJlc3VsdCA9IHRoaXMuX2dldEZyYWdtZW50QW5kUGFyZW50RnJhZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFBhdGg6IGZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciByZW1vdmVkRnJhZ21lbnQgPSBmcmFnbWVudFBhcmVudFJlc3VsdC5mcmFnbWVudCwgZnJhZ21lbnRJbW11dGFibGVQYXRoID0gZnJhZ21lbnRQYXJlbnRSZXN1bHQuZnJhZ21lbnRJbW11dGFibGVQYXRoLCBwYXJlbnRGcmFnbWVudCA9IGZyYWdtZW50UGFyZW50UmVzdWx0LnBhcmVudEZyYWdtZW50LCBwYXJlbnRGcmFnbWVudFBhdGggPSBmcmFnbWVudFBhcmVudFJlc3VsdC5wYXJlbnRGcmFnbWVudFBhdGgsIHBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aCA9IGZyYWdtZW50UGFyZW50UmVzdWx0LnBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aDtcbiAgICAgICAgICAgICAgICByZW1vdmVGcmFnbWVudElkVG9QYXRoKHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IHJlbW92ZWRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogdGhpcy5fZnJhZ21lbnRJZFRvUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUltbXV0YWJsZVBhdGgoZnJhZ21lbnRJbW11dGFibGVQYXRoKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZEluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRGcmFnbWVudC50eXBlID09PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpc19fY29uZmlnLCBfdGhpc19fY29uZmlnMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpc19fY29uZmlnID0gdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19fY29uZmlnLmxvZ2dpbmcubGlzdEZyYWdtZW50SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMaXN0RnJhZ21lbnRJbmRleGVzKHBhcmVudEZyYWdtZW50LCBcIkFib3V0IHRvIGRlbGV0ZSBmcmFnbWVudCBhdCBpbmRleCAnXCIuY29uY2F0KHJlbW92ZWRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXgsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudEZyYWdtZW50LnZhbHVlW3JlbW92ZWRGcmFnbWVudC5pZF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0RnJhZ21lbnRzID0gdGhpcy5fZ2V0TGlzdEZyYWdtZW50cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdEltbXV0YWJsZVBhdGg6IHBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXg6IHJlbW92ZWRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXggKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbUltbXV0YWJpbGl0eVRvSW5kZXg6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSW5kZXggPSByZW1vdmVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBsaXN0RnJhZ21lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWdtZW50LnBhcmVudExpc3RJbmRleCA+IHJlbW92ZWRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5wYXJlbnRMaXN0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChfdGhpc19fY29uZmlnMSA9IHRoaXMuX2NvbmZpZykgPT09IG51bGwgfHwgX3RoaXNfX2NvbmZpZzEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzX19jb25maWcxLmxvZ2dpbmcubGlzdEZyYWdtZW50SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWdMaXN0RnJhZ21lbnRJbmRleGVzKHBhcmVudEZyYWdtZW50LCBcIkRlbGV0ZWQgZnJhZ21lbnQgYXQgaW5kZXggJ1wiLmNvbmNhdChyZW1vdmVkSW5kZXgsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSW5kZXggPSByZW1vdmVkRnJhZ21lbnQucGFyZW50TWFwS2V5O1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyZW50RnJhZ21lbnQudmFsdWVbcmVtb3ZlZEZyYWdtZW50LnBhcmVudE1hcEtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRGcmFnbWVudDogcmVtb3ZlZEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkSW5kZXg6IHJlbW92ZWRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRGcmFnbWVudFBhdGg6IHBhcmVudEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBNb3ZlIGFuIGluZGV4IG9mIGFuIGl0ZW0gaW4gYSBsaXN0IGZyYWdtZW50IGZyb20gYW4gaW1tZXIgcGF0aFxuICAgKi8ga2V5OiBcIm1vdmVJbmRleEF0SW1tZXJQYXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZUluZGV4QXRJbW1lclBhdGgocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdEltbWVyUGF0aCA9IHBhcmFtLmxpc3RJbW1lclBhdGgsIGZyb21JbmRleCA9IHBhcmFtLmZyb21JbmRleCwgdG9JbmRleCA9IHBhcmFtLnRvSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50UGF0aCA9IHRoaXMuX2dldEZyYWdtZW50UGF0aEZyb21JbW1lclBhdGgoX3RvX2NvbnN1bWFibGVfYXJyYXkobGlzdEltbWVyUGF0aCkuY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUluZGV4XG4gICAgICAgICAgICAgICAgXSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb3ZlRnJhZ21lbnQoe1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZEZyYWdtZW50UGF0aDogZnJhZ21lbnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICB0b0luZGV4OiB0b0luZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgKiBNb3ZlIGFuIGluZGV4IGluIGEgbGlzdCBmcm9tIGZyYWdtZW50IGlkXG4gICAqLyBrZXk6IFwibW92ZUluZGV4V2l0aEZyYWdtZW50SWRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlSW5kZXhXaXRoRnJhZ21lbnRJZChwYXJhbSkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudElkID0gcGFyYW0uZnJhZ21lbnRJZCwgdG9JbmRleCA9IHBhcmFtLnRvSW5kZXg7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50UGF0aCA9IHRoaXMuX2ZyYWdtZW50SWRUb1BhdGhbZnJhZ21lbnRJZF07XG4gICAgICAgICAgICAgICAgaWYgKCFmcmFnbWVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVGcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkRnJhZ21lbnRQYXRoOiBmcmFnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAqIE1vdmUgYW4gaW5kZXggb2YgYW4gaXRlbSB3aXRoIGEgZnJhZ21lbnQgcGF0aFxuICAgKi8ga2V5OiBcIl9tb3ZlRnJhZ21lbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUZyYWdtZW50KHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vdmVkRnJhZ21lbnRQYXRoID0gcGFyYW0ubW92ZWRGcmFnbWVudFBhdGgsIHRvSW5kZXggPSBwYXJhbS50b0luZGV4O1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19fY29uZmlnLCBfdGhpc19fY29uZmlnMTtcbiAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRQYXJlbnRSZXN1bHQgPSB0aGlzLl9nZXRGcmFnbWVudEFuZFBhcmVudEZyYWdtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRQYXRoOiBtb3ZlZEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlZEZyYWdtZW50ID0gZnJhZ21lbnRQYXJlbnRSZXN1bHQuZnJhZ21lbnQsIGxpc3RGcmFnbWVudCA9IGZyYWdtZW50UGFyZW50UmVzdWx0LnBhcmVudEZyYWdtZW50LCBsaXN0RnJhZ21lbnRQYXRoID0gZnJhZ21lbnRQYXJlbnRSZXN1bHQucGFyZW50RnJhZ21lbnRQYXRoLCBsaXN0SW1tdXRhYmxlUGF0aCA9IGZyYWdtZW50UGFyZW50UmVzdWx0LnBhcmVudEZyYWdtZW50SW1tdXRhYmxlUGF0aDtcbiAgICAgICAgICAgICAgICBpZiAobGlzdEZyYWdtZW50LnR5cGUgIT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFyZW50IG9mIGEgbW92ZWQgaXRlbSBtdXN0IGJlIGEgXCIuY29uY2F0KDEgLyogTGlzdCAqLyAsIFwiLCB3YXMgXCIpLmNvbmNhdChsaXN0RnJhZ21lbnQudHlwZSwgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IG1vdmVkRnJhZ21lbnQucGFyZW50TGlzdEluZGV4O1xuICAgICAgICAgICAgICAgIHZhciBsaXN0RnJhZ21lbnRzID0gdGhpcy5fZ2V0TGlzdEZyYWdtZW50cyh7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RGcmFnbWVudDogbGlzdEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBsaXN0SW1tdXRhYmxlUGF0aDogbGlzdEltbXV0YWJsZVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1JbW11dGFiaWxpdHlGcm9tSW5kZXg6IHRvSW5kZXggPiBmcm9tSW5kZXggPyBmcm9tSW5kZXggOiB0b0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBpdGVtSW1tdXRhYmlsaXR5VG9JbmRleDogdG9JbmRleCA+IGZyb21JbmRleCA/IHRvSW5kZXggOiBmcm9tSW5kZXhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0b0luZGV4ID0gdG9JbmRleCA+PSBsaXN0RnJhZ21lbnRzLmxlbmd0aCA/IGxpc3RGcmFnbWVudHMubGVuZ3RoIC0gMSA6IHRvSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKChfdGhpc19fY29uZmlnID0gdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpc19fY29uZmlnLmxvZ2dpbmcubGlzdEZyYWdtZW50SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1Z0xpc3RGcmFnbWVudEluZGV4ZXMobGlzdEZyYWdtZW50LCBcIkFib3V0IHRvIG1vdmUgZnJhZ21lbnQgZnJvbSAnXCIuY29uY2F0KGZyb21JbmRleCwgXCInIHRvICdcIikuY29uY2F0KHRvSW5kZXgsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPCB0b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IGxpc3RGcmFnbWVudHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SW5kZXggPSBpdGVtLnBhcmVudExpc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGlzdEluZGV4ID4gZnJvbUluZGV4ICYmIGxpc3RJbmRleCA8PSB0b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ucGFyZW50TGlzdEluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsaXN0SW5kZXggPT09IGZyb21JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnBhcmVudExpc3RJbmRleCA9IHRvSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tSW5kZXggPiB0b0luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yMSA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvcjEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBsaXN0RnJhZ21lbnRzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXAxOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xID0gKF9zdGVwMSA9IF9pdGVyYXRvcjEubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEgPSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbTEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RJbmRleDEgPSBpdGVtMS5wYXJlbnRMaXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RJbmRleDEgPj0gdG9JbmRleCAmJiBsaXN0SW5kZXgxIDwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0xLnBhcmVudExpc3RJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGlzdEluZGV4MSA9PT0gZnJvbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0xLnBhcmVudExpc3RJbmRleCA9IHRvSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjEgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSAmJiBfaXRlcmF0b3IxLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvcjEucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKF90aGlzX19jb25maWcxID0gdGhpcy5fY29uZmlnKSA9PT0gbnVsbCB8fCBfdGhpc19fY29uZmlnMSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXNfX2NvbmZpZzEubG9nZ2luZy5saXN0RnJhZ21lbnRJbmRleGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnTGlzdEZyYWdtZW50SW5kZXhlcyhsaXN0RnJhZ21lbnQsIFwiTW92ZWQgZnJhZ21lbnQgZnJvbSAnXCIuY29uY2F0KGZyb21JbmRleCwgXCInIHRvICdcIikuY29uY2F0KHRvSW5kZXgsIFwiJ1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkRnJhZ21lbnQ6IG1vdmVkRnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RGcmFnbWVudFBhdGg6IGxpc3RGcmFnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0b0luZGV4OiB0b0luZGV4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAqIFJlcGxhY2UgYSBmcmFnbWVudCB3aXRoIGFub3RoZXJcbiAgICovIGtleTogXCJyZXBsYWNlRnJhZ21lbnRcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlRnJhZ21lbnQocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRnJhZ21lbnQgPSBwYXJhbS5vbGRGcmFnbWVudCwgbmV3RnJhZ21lbnQgPSBwYXJhbS5uZXdGcmFnbWVudCwgbmV3RnJhZ21lbnRQYXRoID0gcGFyYW0ubmV3RnJhZ21lbnRQYXRoLCBwYXJlbnRJZCA9IHBhcmFtLnBhcmVudElkO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRGcmFnbWVudFBhdGggPSB0aGlzLl9mcmFnbWVudElkVG9QYXRoW3BhcmVudElkXTtcbiAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aCA9IHRoaXMuX2dldEZyYWdtZW50RnJvbUZyYWdtZW50UGF0aCh7XG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhcmVudEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH0pLCBwYXJlbnRGcmFnbWVudCA9IF90aGlzX19nZXRGcmFnbWVudEZyb21GcmFnbWVudFBhdGguZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50SW5kZXggPSBwYXJlbnRGcmFnbWVudC50eXBlID09PSAxIC8qIExpc3QgKi8gID8gb2xkRnJhZ21lbnQuaWQgOiBvbGRGcmFnbWVudC5wYXJlbnRNYXBLZXk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlRnJhZ21lbnRJZFRvUGF0aCh7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBvbGRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogdGhpcy5fZnJhZ21lbnRJZFRvUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkZEZyYWdtZW50SWRUb1BhdGgoe1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogbmV3RnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IHRoaXMuX2ZyYWdtZW50SWRUb1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IG5ld0ZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhcmVudEZyYWdtZW50LnZhbHVlW2ZyYWdtZW50SW5kZXhdID0gbmV3RnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnQ6IHBhcmVudEZyYWdtZW50XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAqIEdldCBhIHN1YiBkb2N1bWVudCBiYXNlZCBvbiBhIGZyYWdtZW50IHBhdGhcbiAgICovIGtleTogXCJnZXRTdWJEb2N1bWVudEZyb21GcmFnbWVudFBhdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdWJEb2N1bWVudEZyb21GcmFnbWVudFBhdGgoZG9jdW1lbnQsIHBhdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ViRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgICB2YXIgc3ViRnJhZ21lbnQgPSB0aGlzLl9mcmFnbWVudDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJGcmFnbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJGcmFnbWVudCA9IHN1YkZyYWdtZW50LnZhbHVlW3BhdGhbaV1dO1xuICAgICAgICAgICAgICAgICAgICBzdWJEb2N1bWVudCA9IHN1YkRvY3VtZW50W3N1YkZyYWdtZW50LnBhcmVudExpc3RJbmRleCAhPT0gdm9pZCAwID8gc3ViRnJhZ21lbnQucGFyZW50TGlzdEluZGV4IDogc3ViRnJhZ21lbnQucGFyZW50TWFwS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YkRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIEltbXV0YWJsZUZyYWdtZW50O1xufSgpO1xudmFyIGRlYnVnTGlzdEZyYWdtZW50SW5kZXhlcyA9IGZ1bmN0aW9uKGxpc3RGcmFnbWVudCwgZXh0cmFJbmZvKSB7XG4gICAgdmFyIGFsbExpc3RJdGVtcyA9IE9iamVjdC52YWx1ZXMobGlzdEZyYWdtZW50LnZhbHVlKTtcbiAgICB2YXIgYWxsTGlzdEl0ZW1zSW5kZXhlcyA9IGFsbExpc3RJdGVtcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbS5wYXJlbnRMaXN0SW5kZXg7XG4gICAgfSk7XG4gICAgaWYgKGFsbExpc3RJdGVtc0luZGV4ZXMubGVuZ3RoICE9PSBuZXcgU2V0KGFsbExpc3RJdGVtc0luZGV4ZXMpLnNpemUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTGlzdCBmcmFnbWVudCBpbmRleGVzIGFyZSBub3QgdW5pcXVlLiBcIi5jb25jYXQoYWxsTGlzdEl0ZW1zSW5kZXhlcyksIGV4dHJhSW5mbyk7XG4gICAgfVxuICAgIHZhciBleHBlY3RlZEluZGV4ZXMgPSBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBhbGxMaXN0SXRlbXMubGVuZ3RoXG4gICAgfSwgZnVuY3Rpb24oXywgaSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICB9KTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gZXhwZWN0ZWRJbmRleGVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICB2YXIgZXhwZWN0ZWRJbmRleCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCFhbGxMaXN0SXRlbXNJbmRleGVzLmluY2x1ZGVzKGV4cGVjdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiTGlzdCBmcmFnbWVudCBpbmRleGVzIGFyZSBub3QgY29ycmVjdC4gTWlzc2luZyBpbmRleDogXCIuY29uY2F0KGV4cGVjdGVkSW5kZXgsIFwiLlwiKSwgZXh0cmFJbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC9zdG9yZS91dGlscy9jb25mbGljdE9wZXJhdGlvblV0aWxzLnRzXG52YXIgX2dldEZyb21GcmFnbWVudFBhdGggPSBmdW5jdGlvbihkb2N1bWVudCwgZnJhZ21lbnQsIHBhdGgpIHtcbiAgICB2YXIgc3ViRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB2YXIgc3ViRnJhZ21lbnQgPSBmcmFnbWVudDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmIChzdWJGcmFnbWVudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdWJGcmFnbWVudCA9IHN1YkZyYWdtZW50LnZhbHVlW3BhdGhbaV1dO1xuICAgICAgICBzdWJEb2N1bWVudCA9IHN1YkRvY3VtZW50W3N1YkZyYWdtZW50LnBhcmVudExpc3RJbmRleCAhPT0gdm9pZCAwID8gc3ViRnJhZ21lbnQucGFyZW50TGlzdEluZGV4IDogc3ViRnJhZ21lbnQucGFyZW50TWFwS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3ViRG9jdW1lbnQ6IHN1YkRvY3VtZW50LFxuICAgICAgICBzdWJGcmFnbWVudDogc3ViRnJhZ21lbnRcbiAgICB9O1xufTtcbnZhciBfcmVwbGFjZUNvbmZsaWN0V2l0aFRydXRoID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgY29uZmxpY3RGcmFnbWVudCA9IHBhcmFtLmNvbmZsaWN0RnJhZ21lbnQsIGRyYWZ0RG9jdW1lbnQgPSBwYXJhbS5kcmFmdERvY3VtZW50LCBpbW11dGFibGVGcmFnbWVudCA9IHBhcmFtLmltbXV0YWJsZUZyYWdtZW50LCB0cnV0aERvY3VtZW50ID0gcGFyYW0udHJ1dGhEb2N1bWVudCwgdHJ1dGhGcmFnbWVudCA9IHBhcmFtLnRydXRoRnJhZ21lbnQsIHRydXRoRnJhZ21lbnRQYXRoID0gcGFyYW0udHJ1dGhGcmFnbWVudFBhdGg7XG4gICAgdmFyIHBhcmVudEZyYWdtZW50UGF0aCA9IGltbXV0YWJsZUZyYWdtZW50LmdldEZyYWdtZW50SWRUb1BhdGgoKVtjb25mbGljdEZyYWdtZW50LnBhcmVudElkXTtcbiAgICB2YXIgcGFyZW50RG9jdW1lbnQgPSBpbW11dGFibGVGcmFnbWVudC5nZXRTdWJEb2N1bWVudEZyb21GcmFnbWVudFBhdGgoZHJhZnREb2N1bWVudCwgcGFyZW50RnJhZ21lbnRQYXRoKTtcbiAgICB2YXIgcGFyZW50RnJhZ21lbnQgPSBpbW11dGFibGVGcmFnbWVudC5yZXBsYWNlRnJhZ21lbnQoe1xuICAgICAgICBvbGRGcmFnbWVudDogY29uZmxpY3RGcmFnbWVudCxcbiAgICAgICAgbmV3RnJhZ21lbnQ6IHRydXRoRnJhZ21lbnQsXG4gICAgICAgIG5ld0ZyYWdtZW50UGF0aDogdHJ1dGhGcmFnbWVudFBhdGgsXG4gICAgICAgIHBhcmVudElkOiBjb25mbGljdEZyYWdtZW50LnBhcmVudElkXG4gICAgfSkucGFyZW50RnJhZ21lbnQ7XG4gICAgaWYgKHBhcmVudEZyYWdtZW50LnR5cGUgPT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgO1xuICAgICAgICBwYXJlbnREb2N1bWVudC5zcGxpY2UoY29uZmxpY3RGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXgsIDEsIHRydXRoRG9jdW1lbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYXJlbnRGcmFnbWVudC50eXBlID09PSAyIC8qIE1hcCAqLyApIHtcbiAgICAgICAgcGFyZW50RG9jdW1lbnRbY29uZmxpY3RGcmFnbWVudC5wYXJlbnRNYXBLZXldID0gdHJ1dGhEb2N1bWVudDtcbiAgICB9XG59O1xudmFyIHJlc29sdmVDb25mbGljdHNJblN0b3JlID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgY29uZmxpY3RGcmFnbWVudElkcyA9IHBhcmFtLmNvbmZsaWN0RnJhZ21lbnRJZHMsIGNvbmZsaWN0U3RvcmUgPSBwYXJhbS5jb25mbGljdFN0b3JlLCB0cnV0aFN0b3JlID0gcGFyYW0udHJ1dGhTdG9yZSwgY29uZmlnID0gcGFyYW0uY29uZmlnO1xuICAgIGNvbmZsaWN0RnJhZ21lbnRJZHMgPSBjb25mbGljdEZyYWdtZW50SWRzLmZpbHRlcihmdW5jdGlvbih2LCBpLCBhKSB7XG4gICAgICAgIHJldHVybiBhLmluZGV4T2YodikgPT09IGk7XG4gICAgfSk7XG4gICAgdmFyIGltbXV0YWJsZUZyYWdtZW50ID0gY3JlYXRlSW1tdXRhYmxlRnJhZ21lbnQoY29uZmxpY3RTdG9yZS5mcmFnbWVudCwgY29uZmxpY3RTdG9yZS5mcmFnbWVudElkVG9QYXRoLCBjb25maWcpO1xuICAgIHZhciBuZXdEb2N1bWVudCA9ICgwLCBpbXBvcnRfaW1tZXIucHJvZHVjZSkoY29uZmxpY3RTdG9yZS5kb2N1bWVudCwgZnVuY3Rpb24oZHJhZnREb2N1bWVudCkge1xuICAgICAgICB2YXIgcmVwbGFjZWRQYXRocyA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHRydXRoRnJhZ21lbnRQYXRoID0gdHJ1dGhTdG9yZS5mcmFnbWVudElkVG9QYXRoW2lkXTtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmxpY3RGcmFnbWVudFBhdGggPSBpbW11dGFibGVGcmFnbWVudC5nZXRGcmFnbWVudElkVG9QYXRoKClbaWRdO1xuICAgICAgICAgICAgICAgIGlmICghdHJ1dGhGcmFnbWVudFBhdGggfHwgIWNvbmZsaWN0RnJhZ21lbnRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbGlzdHNTaGFsbG93RXF1YWwodHJ1dGhGcmFnbWVudFBhdGgsIGNvbmZsaWN0RnJhZ21lbnRQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZWRQYXRocy5maW5kKGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RzU2hhbGxvd1N0YXJ0c1dpdGgocGF0aCwgY29uZmxpY3RGcmFnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBfZ2V0RnJvbUZyYWdtZW50UGF0aDEgPSBfZ2V0RnJvbUZyYWdtZW50UGF0aCh0cnV0aFN0b3JlLmRvY3VtZW50LCB0cnV0aFN0b3JlLmZyYWdtZW50LCB0cnV0aEZyYWdtZW50UGF0aCksIHRydXRoRG9jdW1lbnQgPSBfZ2V0RnJvbUZyYWdtZW50UGF0aDEuc3ViRG9jdW1lbnQsIHRydXRoRnJhZ21lbnQgPSBfZ2V0RnJvbUZyYWdtZW50UGF0aDEuc3ViRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRGcm9tRnJhZ21lbnRQYXRoMiA9IF9nZXRGcm9tRnJhZ21lbnRQYXRoKGNvbmZsaWN0U3RvcmUuZG9jdW1lbnQsIGNvbmZsaWN0U3RvcmUuZnJhZ21lbnQsIGNvbmZsaWN0RnJhZ21lbnRQYXRoKSwgY29uZmxpY3REb2N1bWVudCA9IF9nZXRGcm9tRnJhZ21lbnRQYXRoMi5zdWJEb2N1bWVudCwgY29uZmxpY3RGcmFnbWVudCA9IF9nZXRGcm9tRnJhZ21lbnRQYXRoMi5zdWJGcmFnbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoIXRydXRoRnJhZ21lbnQgfHwgIWNvbmZsaWN0RnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0RnJhZ21lbnQudHlwZSAhPT0gdHJ1dGhGcmFnbWVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXBsYWNlQ29uZmxpY3RXaXRoVHJ1dGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RGcmFnbWVudDogY29uZmxpY3RGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWZ0RG9jdW1lbnQ6IGRyYWZ0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW11dGFibGVGcmFnbWVudDogaW1tdXRhYmxlRnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnV0aERvY3VtZW50OiB0cnV0aERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudDogdHJ1dGhGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXRoRnJhZ21lbnRQYXRoOiB0cnV0aEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWRQYXRocy5wdXNoKGNvbmZsaWN0RnJhZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRydXRoRnJhZ21lbnQudHlwZSA9PT0gMiAvKiBNYXAgKi8gICYmIGNvbmZsaWN0RnJhZ21lbnQudHlwZSA9PT0gMiAvKiBNYXAgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudEtleXMgPSBPYmplY3Qua2V5cyhjb25mbGljdEZyYWdtZW50LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRydXRoRnJhZ21lbnRLZXlzID0gT2JqZWN0LmtleXModHJ1dGhGcmFnbWVudC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlTWFwID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudEtleXMubGVuZ3RoICE9PSB0cnV0aEZyYWdtZW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VNYXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZU1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSB0cnV0aEZyYWdtZW50S2V5c1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMTsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwMSA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0cnV0aFN1YkZyYWdtZW50ID0gdHJ1dGhGcmFnbWVudC52YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViRnJhZ21lbnQgPSBjb25mbGljdEZyYWdtZW50LnZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cnV0aFN1YkZyYWdtZW50LmlkICE9PSBzdWJGcmFnbWVudC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZU1hcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF9yZXBsYWNlQ29uZmxpY3RXaXRoVHJ1dGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RGcmFnbWVudDogY29uZmxpY3RGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWZ0RG9jdW1lbnQ6IGRyYWZ0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbW11dGFibGVGcmFnbWVudDogaW1tdXRhYmxlRnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnV0aERvY3VtZW50OiB0cnV0aERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudDogdHJ1dGhGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXRoRnJhZ21lbnRQYXRoOiB0cnV0aEZyYWdtZW50UGF0aFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZWRQYXRocy5wdXNoKGNvbmZsaWN0RnJhZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRydXRoRnJhZ21lbnQudHlwZSAhPT0gMSAvKiBMaXN0ICovICB8fCBjb25mbGljdEZyYWdtZW50LnR5cGUgIT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydXRoRG9jdW1lbnQgPT09IGNvbmZsaWN0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3JlcGxhY2VDb25mbGljdFdpdGhUcnV0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdEZyYWdtZW50OiBjb25mbGljdEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZnREb2N1bWVudDogZHJhZnREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZUZyYWdtZW50OiBpbW11dGFibGVGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXRoRG9jdW1lbnQ6IHRydXRoRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnV0aEZyYWdtZW50OiB0cnV0aEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudFBhdGg6IHRydXRoRnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlZFBhdGhzLnB1c2goY29uZmxpY3RGcmFnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdHJ1dGhTdWJGcmFnbWVudElkcyA9IE9iamVjdC5rZXlzKHRydXRoRnJhZ21lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJGcmFnbWVudElkcyA9IE9iamVjdC5rZXlzKGNvbmZsaWN0RnJhZ21lbnQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciByZXBsYWNlTGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWJGcmFnbWVudElkcy5sZW5ndGggIT09IHRydXRoU3ViRnJhZ21lbnRJZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VMaXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlTGlzdCA9ICEhdHJ1dGhTdWJGcmFnbWVudElkcy5maW5kKGZ1bmN0aW9uKGlkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFjb25mbGljdEZyYWdtZW50LnZhbHVlW2lkMl07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVwbGFjZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlcGxhY2VDb25mbGljdFdpdGhUcnV0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdEZyYWdtZW50OiBjb25mbGljdEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhZnREb2N1bWVudDogZHJhZnREb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZUZyYWdtZW50OiBpbW11dGFibGVGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRydXRoRG9jdW1lbnQ6IHRydXRoRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnV0aEZyYWdtZW50OiB0cnV0aEZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudFBhdGg6IHRydXRoRnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlZFBhdGhzLnB1c2goY29uZmxpY3RGcmFnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVvcmdhbml6ZUxpc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEgPSB0cnVlLCBfZGlkSXRlcmF0b3JFcnJvcjEgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IxID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IHRydXRoU3ViRnJhZ21lbnRJZHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDI7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEgPSAoX3N0ZXAyID0gX2l0ZXJhdG9yMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSA9IHRydWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YkZyYWdtZW50SWQgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJ1dGhTdWJGcmFnbWVudDEgPSB0cnV0aEZyYWdtZW50LnZhbHVlW3N1YkZyYWdtZW50SWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1YkZyYWdtZW50MSA9IGNvbmZsaWN0RnJhZ21lbnQudmFsdWVbc3ViRnJhZ21lbnRJZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ1dGhTdWJGcmFnbWVudDEucGFyZW50TGlzdEluZGV4ID09PSBzdWJGcmFnbWVudDEucGFyZW50TGlzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZW9yZ2FuaXplTGlzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJGcmFnbWVudDEucGFyZW50TGlzdEluZGV4ID0gdHJ1dGhTdWJGcmFnbWVudDEucGFyZW50TGlzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yMSA9IGVycjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24xICYmIF9pdGVyYXRvcjEucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3IxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVvcmdhbml6ZUxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3JlcGxhY2VDb25mbGljdFdpdGhUcnV0aCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0RnJhZ21lbnQ6IGNvbmZsaWN0RnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWZ0RG9jdW1lbnQ6IGRyYWZ0RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGltbXV0YWJsZUZyYWdtZW50OiBpbW11dGFibGVGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1dGhEb2N1bWVudDogdHJ1dGhEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudDogdHJ1dGhGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1dGhGcmFnbWVudFBhdGg6IHRydXRoRnJhZ21lbnRQYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVwbGFjZWRQYXRocy5wdXNoKGNvbmZsaWN0RnJhZ21lbnRQYXRoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IGNvbmZsaWN0RnJhZ21lbnRJZHNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKV9sb29wKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXdEb2N1bWVudDogbmV3RG9jdW1lbnQsXG4gICAgICAgIG5ld0ZyYWdtZW50OiBpbW11dGFibGVGcmFnbWVudC5nZXRGcmFnbWVudCgpLFxuICAgICAgICBuZXdGcmFnbWVudElkVG9QYXRoOiBpbW11dGFibGVGcmFnbWVudC5nZXRGcmFnbWVudElkVG9QYXRoKClcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC9zdG9yZS91dGlscy9mcmFnbWVudFV0aWxzLnRzXG52YXIgZ2V0RnJhZ21lbnRUeXBlID0gZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICBzd2l0Y2godHJ1ZSl7XG4gICAgICAgIGNhc2UgZnJhZ21lbnQgPT0gbnVsbDpcbiAgICAgICAgICAgIHJldHVybiAwIC8qIE51bGwgKi8gO1xuICAgICAgICBjYXNlIGlzTGlzdChmcmFnbWVudCk6XG4gICAgICAgICAgICByZXR1cm4gMSAvKiBMaXN0ICovIDtcbiAgICAgICAgY2FzZSBpc01hcChmcmFnbWVudCk6XG4gICAgICAgICAgICByZXR1cm4gMiAvKiBNYXAgKi8gO1xuICAgICAgICBjYXNlIGlzTnVtYmVyKGZyYWdtZW50KTpcbiAgICAgICAgICAgIHJldHVybiAzIC8qIE51bWJlciAqLyA7XG4gICAgICAgIGNhc2UgaXNCb29sZWFuKGZyYWdtZW50KTpcbiAgICAgICAgICAgIHJldHVybiA0IC8qIEJvb2xlYW4gKi8gO1xuICAgICAgICBjYXNlIGlzU3RyaW5nKGZyYWdtZW50KTpcbiAgICAgICAgICAgIHJldHVybiA1IC8qIFN0cmluZyAqLyA7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGV2YWx1YXRpbmcgZnJhZ21lbnQgdHlwZSBmb3IgdmFsdWUgJ1wiLmNvbmNhdChmcmFnbWVudCwgXCInLlwiKSk7XG59O1xudmFyIGZyYWdtZW50VG9Eb2N1bWVudCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcXVldWVfc2hpZnQgPSBxdWV1ZS5zaGlmdCgpLCBkb2N1bWVudEZyYWdtZW50ID0gX3F1ZXVlX3NoaWZ0LmRvY3VtZW50RnJhZ21lbnQsIGRvY3VtZW50ID0gX3F1ZXVlX3NoaWZ0LmRvY3VtZW50O1xuICAgICAgICBpZiAoZG9jdW1lbnRGcmFnbWVudC50eXBlID09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgIHZhciBsaXN0ID0gT2JqZWN0LnZhbHVlcyhkb2N1bWVudEZyYWdtZW50LnZhbHVlKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5wYXJlbnRMaXN0SW5kZXggLSBiLnBhcmVudExpc3RJbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGxpc3REb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBsaXN0W1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0SXRlbSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdEl0ZW1Eb2N1bWVudCA9IGxpc3RJdGVtLnR5cGUgPT0gMiAvKiBNYXAgKi8gID8ge30gOiBsaXN0SXRlbS50eXBlID09IDEgLyogTGlzdCAqLyAgPyBbXSA6IGNsb25lKGxpc3RJdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdERvY3VtZW50LnB1c2gobGlzdEl0ZW1Eb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0SXRlbS50eXBlID09PSAyIC8qIE1hcCAqLyAgfHwgbGlzdEl0ZW0udHlwZSA9PT0gMSAvKiBMaXN0ICovICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRGcmFnbWVudDogbGlzdEl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IGxpc3RJdGVtRG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnRGcmFnbWVudC50eXBlID09IDIgLyogTWFwICovICkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IGRvY3VtZW50RnJhZ21lbnQudmFsdWU7XG4gICAgICAgICAgICB2YXIgbWFwRG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yMSA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvcjEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IE9iamVjdC5rZXlzKG1hcClbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDE7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjEgPSAoX3N0ZXAxID0gX2l0ZXJhdG9yMS5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSA9IHRydWUpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ViS2V5ID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwSXRlbSA9IG1hcFtzdWJLZXldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwSXRlbURvY3VtZW50ID0gbWFwSXRlbS50eXBlID09IDIgLyogTWFwICovICA/IHt9IDogbWFwSXRlbS50eXBlID09IDEgLyogTGlzdCAqLyAgPyBbXSA6IGNsb25lKG1hcEl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBtYXBEb2N1bWVudFtzdWJLZXldID0gbWFwSXRlbURvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFwSXRlbS50eXBlID09PSAyIC8qIE1hcCAqLyAgfHwgbWFwSXRlbS50eXBlID09PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudEZyYWdtZW50OiBtYXBJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBtYXBJdGVtRG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3JFcnJvcjEgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMSAmJiBfaXRlcmF0b3IxLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IxLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBmcmFnbWVudCA9IHBhcmFtLmZyYWdtZW50O1xuICAgIHZhciByb290RG9jdW1lbnQgPSBmcmFnbWVudC50eXBlID09IDIgLyogTWFwICovICA/IHt9IDogZnJhZ21lbnQudHlwZSA9PSAxIC8qIExpc3QgKi8gID8gW10gOiBjbG9uZShmcmFnbWVudC52YWx1ZSk7XG4gICAgaWYgKGZyYWdtZW50LnR5cGUgIT09IDIgLyogTWFwICovICAmJiBmcmFnbWVudC50eXBlICE9PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgIHJldHVybiByb290RG9jdW1lbnQ7XG4gICAgfVxuICAgIHZhciBxdWV1ZSA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgZG9jdW1lbnRGcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBkb2N1bWVudDogcm9vdERvY3VtZW50XG4gICAgICAgIH1cbiAgICBdO1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCA+IDApX2xvb3AoKTtcbiAgICByZXR1cm4gcm9vdERvY3VtZW50O1xufTtcbnZhciBnZXRGcmFnbWVudFN1Ykl0ZW1zID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgcmF3RG9jdW1lbnQgPSBwYXJhbS5yYXdEb2N1bWVudCwgZnJhZ21lbnQgPSBwYXJhbS5mcmFnbWVudDtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICBpZiAoZnJhZ21lbnQudHlwZSA9PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgIHZhciBsaXN0ID0gcmF3RG9jdW1lbnQ7XG4gICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihsaXN0SXRlbSwgaSkge1xuICAgICAgICAgICAgcXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgcmF3RG9jdW1lbnQ6IGxpc3RJdGVtLFxuICAgICAgICAgICAgICAgIHBhcmVudEZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgICAgICBwYXJlbnRMaXN0SW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGZyYWdtZW50LnR5cGUgPT0gMiAvKiBNYXAgKi8gKSB7XG4gICAgICAgIHZhciBtYXAgPSByYXdEb2N1bWVudDtcbiAgICAgICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlLCBfaXRlcmF0b3JFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMobWFwKVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpe1xuICAgICAgICAgICAgICAgIHZhciBzdWJLZXkgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmF3RG9jdW1lbnQ6IG1hcFtzdWJLZXldLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRGcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE1hcEtleTogc3ViS2V5XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHF1ZXVlO1xufTtcbnZhciBkb2N1bWVudFRvRnJhZ21lbnQgPSBmdW5jdGlvbihkb2N1bWVudCwgcm9vdEZyYWdtZW50SWQpIHtcbiAgICBkb2N1bWVudCA9IGNsb25lKGRvY3VtZW50KTtcbiAgICB2YXIgcm9vdFR5cGUgPSBnZXRGcmFnbWVudFR5cGUoZG9jdW1lbnQpO1xuICAgIHZhciByb290RnJhZ21lbnQgPSB7XG4gICAgICAgIGlkOiByb290RnJhZ21lbnRJZCAhPT0gbnVsbCAmJiByb290RnJhZ21lbnRJZCAhPT0gdm9pZCAwID8gcm9vdEZyYWdtZW50SWQgOiB1bmlxdWVJZCgpLFxuICAgICAgICB0eXBlOiByb290VHlwZSxcbiAgICAgICAgdmFsdWU6IHJvb3RUeXBlID09IDIgLyogTWFwICovICB8fCByb290VHlwZSA9PSAxIC8qIExpc3QgKi8gID8ge30gOiBkb2N1bWVudFxuICAgIH07XG4gICAgdmFyIHF1ZXVlID0gX3RvX2NvbnN1bWFibGVfYXJyYXkoZ2V0RnJhZ21lbnRTdWJJdGVtcyh7XG4gICAgICAgIHJhd0RvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgZnJhZ21lbnQ6IHJvb3RGcmFnbWVudFxuICAgIH0pKTtcbiAgICB3aGlsZShxdWV1ZS5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIF9xdWV1ZTtcbiAgICAgICAgdmFyIF9xdWV1ZV9zaGlmdCA9IHF1ZXVlLnNoaWZ0KCksIHJhd0RvY3VtZW50ID0gX3F1ZXVlX3NoaWZ0LnJhd0RvY3VtZW50LCBwYXJlbnRGcmFnbWVudCA9IF9xdWV1ZV9zaGlmdC5wYXJlbnRGcmFnbWVudCwgcGFyZW50TWFwS2V5ID0gX3F1ZXVlX3NoaWZ0LnBhcmVudE1hcEtleSwgcGFyZW50TGlzdEluZGV4ID0gX3F1ZXVlX3NoaWZ0LnBhcmVudExpc3RJbmRleDtcbiAgICAgICAgdmFyIGlkID0gdW5pcXVlSWQoKTtcbiAgICAgICAgdmFyIHR5cGUgPSBnZXRGcmFnbWVudFR5cGUocmF3RG9jdW1lbnQpO1xuICAgICAgICB2YXIgZG9jdW1lbnQyID0gdHlwZSA9PSAyIC8qIE1hcCAqLyAgfHwgdHlwZSA9PSAxIC8qIExpc3QgKi8gID8ge30gOiByYXdEb2N1bWVudDtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0ge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGFyZW50SWQ6IHBhcmVudEZyYWdtZW50LmlkLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiBkb2N1bWVudDJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhcmVudE1hcEtleSkge1xuICAgICAgICAgICAgZnJhZ21lbnQucGFyZW50TWFwS2V5ID0gcGFyZW50TWFwS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnRMaXN0SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZnJhZ21lbnQucGFyZW50TGlzdEluZGV4ID0gcGFyZW50TGlzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaChwYXJlbnRGcmFnbWVudC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBMaXN0ICovIDpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnQudmFsdWVbZnJhZ21lbnQuaWRdID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovIDpcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50TWFwS2V5KSBwYXJlbnRGcmFnbWVudC52YWx1ZVtwYXJlbnRNYXBLZXldID0gZnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgKF9xdWV1ZSA9IHF1ZXVlKS5wdXNoLmFwcGx5KF9xdWV1ZSwgX3RvX2NvbnN1bWFibGVfYXJyYXkoZ2V0RnJhZ21lbnRTdWJJdGVtcyh7XG4gICAgICAgICAgICByYXdEb2N1bWVudDogcmF3RG9jdW1lbnQsXG4gICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnRcbiAgICAgICAgfSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RGcmFnbWVudDtcbn07XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvc3RvcmUvdXRpbHMvbG9jYWxPcGVyYXRpb25VdGlscy50c1xudmFyIF9nZXRTdWJEb2N1bWVudCA9IGZ1bmN0aW9uKGRvY3VtZW50LCBwYXRoKSB7XG4gICAgdmFyIHN1YkRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZiAoc3ViRG9jdW1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3ViRG9jdW1lbnQgPSBzdWJEb2N1bWVudFtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHN1YkRvY3VtZW50O1xufTtcbnZhciBfZ2V0TGlzdE9wZXJhdGlvbnMgPSBmdW5jdGlvbihwYXRoLCBsaXN0UGF0Y2hlcywgb2xkTGlzdCwgbmV3TGlzdCkge1xuICAgIG9sZExpc3QgPSBfdG9fY29uc3VtYWJsZV9hcnJheShvbGRMaXN0KTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IFtdO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbiA9IHZvaWQgMDtcbiAgICB3aGlsZShpIDwgb2xkTGlzdC5sZW5ndGggJiYgaiA8IG5ld0xpc3QubGVuZ3RoKXtcbiAgICAgICAgaWYgKG9sZExpc3RbaV0gPT09IG5ld0xpc3Rbal0pIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbiA9IHZvaWQgMDtcbiAgICAgICAgfSBlbHNlIGlmIChuZXdMaXN0LmluZGV4T2Yob2xkTGlzdFtpXSkgPT09IC0xKSB7XG4gICAgICAgICAgICB2YXIgZGVsZXRlT3AgPSB7XG4gICAgICAgICAgICAgICAgb3A6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbiA9IGRlbGV0ZU9wO1xuICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGRlbGV0ZU9wKTtcbiAgICAgICAgICAgIG9sZExpc3Quc3BsaWNlKGksIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG9sZExpc3QuaW5kZXhPZihuZXdMaXN0W2pdKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0RlbGV0ZWRPcGVyYXRpb24gJiYgcHJldmlvdXNEZWxldGVkT3BlcmF0aW9uLmluZGV4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0ZWRPcHIgPSBvcGVyYXRpb25zLnNwbGljZSgtMSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZWRPcHIgIT09IHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWxldGVkIG9wZXJhdGlvbiBpcyBub3QgdGhlIGxhc3Qgb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZU9wID0ge1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3TGlzdFtqXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHJlcGxhY2VPcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnNlcnRPcCA9IHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IFwiaW5zZXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3TGlzdFtqXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGluc2VydE9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9sZExpc3Quc3BsaWNlKGksIDAsIG5ld0xpc3Rbal0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgcHJldmlvdXNEZWxldGVkT3BlcmF0aW9uID0gdm9pZCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGsgPSBvbGRMaXN0LmluZGV4T2YobmV3TGlzdFtqXSwgaSk7XG4gICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIG9wOiBcIm1vdmVcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIG9sZEluZGV4OiBrIDwgMCA/IG9sZExpc3QubGVuZ3RoIC0gMSA6IGssXG4gICAgICAgICAgICAgICAgbmV3SW5kZXg6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBvbGRMaXN0W2tdO1xuICAgICAgICAgICAgZm9yKHZhciBsID0gazsgbCA+IGk7IGwtLSl7XG4gICAgICAgICAgICAgICAgb2xkTGlzdFtsXSA9IG9sZExpc3RbbCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2xkTGlzdFtpXSA9IHRlbXA7XG4gICAgICAgICAgICBwcmV2aW91c0RlbGV0ZWRPcGVyYXRpb24gPSB2b2lkIDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUoaSA8IG9sZExpc3QubGVuZ3RoKXtcbiAgICAgICAgdmFyIGRlbGV0ZU9wMSA9IHtcbiAgICAgICAgICAgIG9wOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgIH07XG4gICAgICAgIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbiA9IGRlbGV0ZU9wMTtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGRlbGV0ZU9wMSk7XG4gICAgICAgIG9sZExpc3Quc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICB3aGlsZShqIDwgbmV3TGlzdC5sZW5ndGgpe1xuICAgICAgICBpZiAocHJldmlvdXNEZWxldGVkT3BlcmF0aW9uICYmIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbi5pbmRleCA9PT0gaSkge1xuICAgICAgICAgICAgdmFyIGRlbGV0ZWRPcHIxID0gb3BlcmF0aW9ucy5zcGxpY2UoLTEpWzBdO1xuICAgICAgICAgICAgaWYgKGRlbGV0ZWRPcHIxICE9PSBwcmV2aW91c0RlbGV0ZWRPcGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWxldGVkIG9wZXJhdGlvbiBpcyBub3QgdGhlIGxhc3Qgb3BlcmF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcGxhY2VPcDEgPSB7XG4gICAgICAgICAgICAgICAgb3A6IFwicmVwbGFjZVwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgaW5kZXg6IGkrKyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbmV3TGlzdFtqKytdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHJlcGxhY2VPcDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluc2VydE9wMSA9IHtcbiAgICAgICAgICAgICAgICBvcDogXCJpbnNlcnRcIixcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpKyssXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld0xpc3RbaisrXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChpbnNlcnRPcDEpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRGVsZXRlZE9wZXJhdGlvbiA9IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIGZpbmFsT3BlcmF0aW9ucyA9IFtdO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wICE9PSBcImRlbGV0ZVwiICYmIG9wZXJhdGlvbi5vcCAhPT0gXCJpbnNlcnRcIiAmJiBvcGVyYXRpb24ub3AgIT09IFwicmVwbGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RQYXRjaCA9IGxpc3RQYXRjaGVzLmZpbmQoZnVuY3Rpb24ob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3AucGF0aC5sZW5ndGggPiAwICYmIG9wLnBhdGhbb3AucGF0aC5sZW5ndGggLSAxXSA9PT0gb3BlcmF0aW9uLmluZGV4O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWxpc3RQYXRjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbE9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IG9wZXJhdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKV9sb29wKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5e1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsT3BlcmF0aW9ucztcbn07XG52YXIgaW1tZXJQYXRjaGVzVG9PcGVyYXRpb25zID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgcGF0Y2hlcyA9IHBhcmFtLnBhdGNoZXMsIG9sZERvY3VtZW50ID0gcGFyYW0ub2xkRG9jdW1lbnQsIG5ld0RvY3VtZW50ID0gcGFyYW0ubmV3RG9jdW1lbnQ7XG4gICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlKHBhdGNoZXMubGVuZ3RoID4gaW5kZXgpe1xuICAgICAgICB2YXIgY3VycmVudFBhdGNoID0gcGF0Y2hlc1tpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50UGF0Y2gucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3A6IFwicm9vdFwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50UGF0Y2gudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXRoID0gY3VycmVudFBhdGNoLnBhdGg7XG4gICAgICAgIHZhciBwYXJlbnRQYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgICAgIHZhciBwYXJlbnREb2N1bWVudCA9IF9nZXRTdWJEb2N1bWVudChuZXdEb2N1bWVudCwgcGFyZW50UGF0aCk7XG4gICAgICAgIGlmIChwYXJlbnREb2N1bWVudCAmJiBpc0xpc3QocGFyZW50RG9jdW1lbnQpKSB7XG4gICAgICAgICAgICB2YXIgX29wZXJhdGlvbnM7XG4gICAgICAgICAgICB2YXIgbGlzdFBhdGNoZXMgPSBbXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGNoXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgd2hpbGUoKytpbmRleCl7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoZXMubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbmV4dExpc3RQYXRjaCA9IHBhdGNoZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0TGlzdFBhdGNoLnBhdGgubGVuZ3RoICE9PSBwYXRoLmxlbmd0aCB8fCAhbGlzdHNTaGFsbG93RXF1YWwocGFyZW50UGF0aCwgbmV4dExpc3RQYXRjaC5wYXRoLnNsaWNlKDAsIC0xKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxpc3RQYXRjaGVzLnB1c2gobmV4dExpc3RQYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkUGFyZW50RG9jdW1lbnQgPSBfZ2V0U3ViRG9jdW1lbnQob2xkRG9jdW1lbnQsIHBhcmVudFBhdGgpO1xuICAgICAgICAgICAgKF9vcGVyYXRpb25zID0gb3BlcmF0aW9ucykucHVzaC5hcHBseShfb3BlcmF0aW9ucywgX3RvX2NvbnN1bWFibGVfYXJyYXkoX2dldExpc3RPcGVyYXRpb25zKHBhcmVudFBhdGgsIGxpc3RQYXRjaGVzLCBvbGRQYXJlbnREb2N1bWVudCwgcGFyZW50RG9jdW1lbnQpKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3BlcmF0aW9uSW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHN3aXRjaChjdXJyZW50UGF0Y2gub3Ape1xuICAgICAgICAgICAgY2FzZSBcInJlcGxhY2VcIjpcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJyZXBsYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IHBhcmVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBvcGVyYXRpb25JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGN1cnJlbnRQYXRjaC52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG9wOiBcImluc2VydFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXJlbnRQYXRoLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogb3BlcmF0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50UGF0Y2gudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG9wZXJhdGlvbkluZGV4XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvbnM7XG59O1xudmFyIGFwcGx5UGF0Y2hPcGVyYXRpb25zVG9GcmFnbWVudCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGZyYWdtZW50ID0gcGFyYW0uZnJhZ21lbnQsIGZyYWdtZW50SWRUb1BhdGggPSBwYXJhbS5mcmFnbWVudElkVG9QYXRoLCBvcGVyYXRpb25zID0gcGFyYW0ub3BlcmF0aW9ucywgY29uZmlnID0gcGFyYW0uY29uZmlnO1xuICAgIHZhciByZXF1ZXN0cyA9IFtdO1xuICAgIHZhciBpbW11dGFibGVGcmFnbWVudCA9IGNyZWF0ZUltbXV0YWJsZUZyYWdtZW50KGZyYWdtZW50LCBmcmFnbWVudElkVG9QYXRoLCBjb25maWcpO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBvcGVyYXRpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGhhdmUgbW9yZSB0aGFuIG9uZSBvcGVyYXRpb24gd2l0aCBzZXQgcm9vdC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXdGcmFnbWVudCA9IGRvY3VtZW50VG9GcmFnbWVudChvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGcmFnbWVudElkVG9QYXRoID0gY3JlYXRlRnJhZ21lbnRJZFRvUGF0aCh7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBuZXdGcmFnbWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGltbXV0YWJsZUZyYWdtZW50ID0gY3JlYXRlSW1tdXRhYmxlRnJhZ21lbnQobmV3RnJhZ21lbnQsIG5ld0ZyYWdtZW50SWRUb1BhdGgpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogXCJyb290XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjbG9uZShuZXdGcmFnbWVudClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaChvcGVyYXRpb24ub3Ape1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLmxvY2FsT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0xvY2FsIG9wZXJhdGlvbl0gSW5zZXJ0aW5nIGZyYWdtZW50XCIsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24uaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydGVkRnJhZ21lbnQgPSBpbW11dGFibGVGcmFnbWVudC5pbnNlcnRBdEltbWVyUGF0aCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudDogZG9jdW1lbnRUb0ZyYWdtZW50KG9wZXJhdGlvbi52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SW1tZXJQYXRoOiBvcGVyYXRpb24ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogb3BlcmF0aW9uLmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5pbnNlcnRlZEZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLmxvY2FsT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0xvY2FsIG9wZXJhdGlvbl0gSW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5IGZyYWdtZW50IFwiLmNvbmNhdChpbnNlcnRlZEZyYWdtZW50LmlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJpbnNlcnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRNYXBLZXk6IGluc2VydGVkRnJhZ21lbnQucGFyZW50TWFwS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudExpc3RJbmRleDogaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lKGluc2VydGVkRnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5sb2NhbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltMb2NhbCBvcGVyYXRpb25dIFJlbW92aW5nIGZyYWdtZW50XCIsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24uaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGltbWVyUGF0aCA9IF90b19jb25zdW1hYmxlX2FycmF5KG9wZXJhdGlvbi5wYXRoKS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5pbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZEZyYWdtZW50ID0gaW1tdXRhYmxlRnJhZ21lbnQuZGVsZXRlQXRJbW1lclBhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVyUGF0aDogaW1tZXJQYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5yZW1vdmVkRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcubG9jYWxPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbTG9jYWwgb3BlcmF0aW9uXSBSZW1vdmVkIGZyYWdtZW50IHN1Y2Nlc3NmdWxseSBcIi5jb25jYXQocmVtb3ZlZEZyYWdtZW50LmlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcDogXCJkZWxldGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVtb3ZlZEZyYWdtZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiByZW1vdmVkRnJhZ21lbnQucGFyZW50SWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5sb2NhbE9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltMb2NhbCBvcGVyYXRpb24gc3RhcnRdIFJlcGxhY2luZyBmcmFnbWVudFwiLCBvcGVyYXRpb24ucGF0aCwgb3BlcmF0aW9uLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbW1lclBhdGgxID0gX3RvX2NvbnN1bWFibGVfYXJyYXkob3BlcmF0aW9uLnBhdGgpLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uLmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkRnJhZ21lbnQxID0gaW1tdXRhYmxlRnJhZ21lbnQuZGVsZXRlQXRJbW1lclBhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltbWVyUGF0aDogaW1tZXJQYXRoMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkucmVtb3ZlZEZyYWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLmxvY2FsT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0xvY2FsIG9wZXJhdGlvbl0gUmVtb3ZlZCBmcmFnbWVudCBcIi5jb25jYXQocmVtb3ZlZEZyYWdtZW50MS5pZCwgXCIgXCIpLmNvbmNhdChyZW1vdmVkRnJhZ21lbnQxLnBhcmVudExpc3RJbmRleCwgXCIgKHJlcGxhY2UpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnRlZEZyYWdtZW50MSA9IGltbXV0YWJsZUZyYWdtZW50Lmluc2VydEF0SW1tZXJQYXRoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZEZyYWdtZW50OiBkb2N1bWVudFRvRnJhZ21lbnQob3BlcmF0aW9uLnZhbHVlLCByZW1vdmVkRnJhZ21lbnQxLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJbW1lclBhdGg6IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBvcGVyYXRpb24uaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLmluc2VydGVkRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcubG9jYWxPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbTG9jYWwgb3BlcmF0aW9uXSBJbnNlcnRlZCBmcmFnbWVudCBcIi5jb25jYXQoaW5zZXJ0ZWRGcmFnbWVudDEuaWQsIFwiIChyZXBsYWNlKSAtIGZpbmlzaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaW5zZXJ0ZWRGcmFnbWVudDEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNsb25lKGluc2VydGVkRnJhZ21lbnQxKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLmxvY2FsT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0xvY2FsIG9wZXJhdGlvbl0gTW92aW5nIGZyYWdtZW50XCIsIG9wZXJhdGlvbi5wYXRoLCBvcGVyYXRpb24ub2xkSW5kZXgsIG9wZXJhdGlvbi5uZXdJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2ltbXV0YWJsZUZyYWdtZW50X21vdmVJbmRleEF0SW1tZXJQYXRoID0gaW1tdXRhYmxlRnJhZ21lbnQubW92ZUluZGV4QXRJbW1lclBhdGgoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RJbW1lclBhdGg6IG9wZXJhdGlvbi5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb21JbmRleDogb3BlcmF0aW9uLm9sZEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvSW5kZXg6IG9wZXJhdGlvbi5uZXdJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksIG1vdmVkRnJhZ21lbnQgPSBfaW1tdXRhYmxlRnJhZ21lbnRfbW92ZUluZGV4QXRJbW1lclBhdGgubW92ZWRGcmFnbWVudCwgdG9JbmRleCA9IF9pbW11dGFibGVGcmFnbWVudF9tb3ZlSW5kZXhBdEltbWVyUGF0aC50b0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLmxvY2FsT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW0xvY2FsIG9wZXJhdGlvbl0gTW92ZWQgZnJhZ21lbnQgc3VjY2Vzc2Z1bGx5IFwiLCBtb3ZlZEZyYWdtZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wOiBcIm1vdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbW92ZWRGcmFnbWVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogdG9JbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbW92ZWRGcmFnbWVudC5wYXJlbnRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVW5oYW5kbGVkIG9wZXJhdGlvbiAnXCIuY29uY2F0KG9wZXJhdGlvbi5vcCwgXCInIGluIGxvY2FsIG9wZXJhdGlvbnMuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICB9IGZpbmFsbHl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuZXdGcmFnbWVudDogaW1tdXRhYmxlRnJhZ21lbnQuZ2V0RnJhZ21lbnQoKSxcbiAgICAgICAgbmV3RnJhZ21lbnRJZFRvUGF0aDogaW1tdXRhYmxlRnJhZ21lbnQuZ2V0RnJhZ21lbnRJZFRvUGF0aCgpLFxuICAgICAgICByZXF1ZXN0czogcmVxdWVzdHNcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC9zdG9yZS91dGlscy9yZW1vdGVPcGVyYXRpb25VdGlscy50c1xudmFyIGltcG9ydF9pbW1lcjIgPSByZXF1aXJlKFwiaW1tZXJcIik7XG4vLyBzcmMvY2hhbm5lbHMvZG9jdW1lbnQvc3RvcmUvdXRpbHMvbWluaWZ5T3BlcmF0aW9ucy50c1xudmFyIG1pbmlmeU9wZXJhdGlvbnMgPSBmdW5jdGlvbihvcGVyYXRpb25zKSB7XG4gICAgdmFyIG1pbmlmaWVkT3BlcmF0aW9ucyA9IFtdO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZSwgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9uID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBzd2l0Y2gob3BlcmF0aW9uLm9wKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgICAgICAgICBtaW5pZmllZE9wZXJhdGlvbnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImluc2VydFwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pZmllZE9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlmaWVkT3BlcmF0aW9ucyA9IG1pbmlmaWVkT3BlcmF0aW9ucy5maWx0ZXIoZnVuY3Rpb24ob3ByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEob3ByLm9wID09PSBEb2N1bWVudE9wZXJhdGlvblJlcGxhY2UgJiYgb3ByLmlkID09PSBvcGVyYXRpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pZmllZE9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RJbnNlcnRJbmRleCA9IG1pbmlmaWVkT3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24ob3ByKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wci5vcCA9PT0gRG9jdW1lbnRPcGVyYXRpb25JbnNlcnQgJiYgb3ByLnZhbHVlLmlkID09PSBvcGVyYXRpb24uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5sYXN0SW5kZXhPZih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5zZXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRJbnNlcnQgPSBtaW5pZmllZE9wZXJhdGlvbnNbbGFzdEluc2VydEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZEluc2VydC5wYXJlbnRMaXN0SW5kZXggIT09IHZvaWQgMCAmJiBsYXN0SW5zZXJ0SW5kZXggIT09IG1pbmlmaWVkT3BlcmF0aW9ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmlmaWVkT3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaWZpZWRPcGVyYXRpb25zLnNwbGljZShsYXN0SW5zZXJ0SW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaWZpZWRPcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluaWZpZWRPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdE9wID0gbWluaWZpZWRPcGVyYXRpb25zW21pbmlmaWVkT3BlcmF0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE9wLm9wID09PSBEb2N1bWVudE9wZXJhdGlvbk1vdmUgJiYgbGFzdE9wLmlkID09PSBvcGVyYXRpb24uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaWZpZWRPcGVyYXRpb25zW21pbmlmaWVkT3BlcmF0aW9ucy5sZW5ndGggLSAxXSA9IG9wZXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaWZpZWRPcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBvcGVyYXRpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSlfbG9vcCgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtaW5pZmllZE9wZXJhdGlvbnM7XG59O1xuLy8gc3JjL2NoYW5uZWxzL2RvY3VtZW50L3N0b3JlL3V0aWxzL3JlbW90ZU9wZXJhdGlvblV0aWxzLnRzXG52YXIgYXBwbHlSZW1vdGVPcGVyYXRpb25zVG9TdG9yZXMgPSBmdW5jdGlvbihtZXNzYWdlcywgc3RvcmVzKSB7XG4gICAgdmFyIF9pbnN0YW5jZTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IChfaW5zdGFuY2UgPSBbXSkuY29uY2F0LmFwcGx5KF9pbnN0YW5jZSwgX3RvX2NvbnN1bWFibGVfYXJyYXkobWVzc2FnZXMubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ub3BlcmF0aW9ucztcbiAgICB9KSkpO1xuICAgIHZhciBtaW5pZmllZE9wZXJhdGlvbnMgPSBtaW5pZnlPcGVyYXRpb25zKG9wZXJhdGlvbnMpO1xuICAgIHZhciBuZXdNZXNzYWdlcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbWVzc2FnZUlkOiBcIlwiLFxuICAgICAgICAgICAgdHlwZTogXCJvcHNcIixcbiAgICAgICAgICAgIGRvY0lkOiBcIlwiLFxuICAgICAgICAgICAgY2xpZW50SWQ6IFwiXCIsXG4gICAgICAgICAgICBjbGllbnRTdWJJZDogXCJcIixcbiAgICAgICAgICAgIG9wZXJhdGlvbnM6IG1pbmlmaWVkT3BlcmF0aW9uc1xuICAgICAgICB9XG4gICAgXTtcbiAgICBzdG9yZXMuZm9yRWFjaChmdW5jdGlvbihzdG9yZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RvcmUuYXBwbHlSZW1vdGVPcGVyYXRpb25zKG5ld01lc3NhZ2VzKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aXRoIHN0b3JlIFwiLmNvbmNhdChzdG9yZS5nZXROYW1lKCkpLCBlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbnZhciBhcHBseVJlbW90ZU9wZXJhdGlvbnNNZXNzYWdlcyA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIGRvY3VtZW50ID0gcGFyYW0uZG9jdW1lbnQsIGZyYWdtZW50ID0gcGFyYW0uZnJhZ21lbnQsIGZyYWdtZW50SWRUb1BhdGggPSBwYXJhbS5mcmFnbWVudElkVG9QYXRoLCBtZXNzYWdlcyA9IHBhcmFtLm1lc3NhZ2VzLCBjb25maWcgPSBwYXJhbS5jb25maWcsIHN0b3JlTmFtZSA9IHBhcmFtLnN0b3JlTmFtZTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IG1lc3NhZ2VzLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgIHJldHVybiBtLm9wZXJhdGlvbnM7XG4gICAgfSkucmVkdWNlKGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgbGFzdFJvb3RJbmRleCA9IG9wZXJhdGlvbnMubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIG8ub3AgPT09IFwicm9vdFwiO1xuICAgIH0pLmxhc3RJbmRleE9mKHRydWUpO1xuICAgIGlmIChsYXN0Um9vdEluZGV4ID49IDApIHtcbiAgICAgICAgdmFyIHJvb3RPcGVyYXRpb24gPSBvcGVyYXRpb25zW2xhc3RSb290SW5kZXhdO1xuICAgICAgICBmcmFnbWVudCA9IGNsb25lKHJvb3RPcGVyYXRpb24udmFsdWUpO1xuICAgICAgICBkb2N1bWVudCA9IGZyYWdtZW50VG9Eb2N1bWVudCh7XG4gICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGZyYWdtZW50SWRUb1BhdGggPSBjcmVhdGVGcmFnbWVudElkVG9QYXRoKHtcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbnMuc2xpY2UobGFzdFJvb3RJbmRleCArIDEpO1xuICAgIH1cbiAgICB2YXIgaW1tdXRhYmxlRnJhZ21lbnQgPSBjcmVhdGVJbW11dGFibGVGcmFnbWVudChmcmFnbWVudCwgZnJhZ21lbnRJZFRvUGF0aCwgY29uZmlnKTtcbiAgICB2YXIgbmV3RG9jdW1lbnQgPSAoMCwgaW1wb3J0X2ltbWVyMi5wcm9kdWNlKShkb2N1bWVudCwgZnVuY3Rpb24oZHJhZnREb2N1bWVudCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBvcGVyYXRpb25zW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIHN3aXRjaChvcGVyYXRpb24ub3Ape1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW5zZXJ0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gSW5zZXJ0IHN0YXJ0ZWQgb24gZnJhZ21lbnQgXCIpLmNvbmNhdChvcGVyYXRpb24udmFsdWUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydFdpdGhGcmFnbWVudElkUmVzdWx0ID0gaW1tdXRhYmxlRnJhZ21lbnQuaW5zZXJ0V2l0aEZyYWdtZW50SWQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRlZEZyYWdtZW50OiBjbG9uZShvcGVyYXRpb24udmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRGcmFnbWVudElkOiBvcGVyYXRpb24ucGFyZW50SWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluc2VydFdpdGhGcmFnbWVudElkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltSZW1vdGUgb3BlcmF0aW9uIGluIHN0b3JlIFwiLmNvbmNhdChzdG9yZU5hbWUsIFwiXSBJbnNlcnQgZGlkIG5vdCBmaW5pc2ggb24gZnJhZ21lbnQgXCIpLmNvbmNhdChvcGVyYXRpb24udmFsdWUuaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydGVkRnJhZ21lbnQgPSBpbnNlcnRXaXRoRnJhZ21lbnRJZFJlc3VsdC5pbnNlcnRlZEZyYWdtZW50LCBwYXJlbnRGcmFnbWVudCA9IGluc2VydFdpdGhGcmFnbWVudElkUmVzdWx0LnBhcmVudEZyYWdtZW50LCBwYXJlbnRGcmFnbWVudFBhdGggPSBpbnNlcnRXaXRoRnJhZ21lbnRJZFJlc3VsdC5wYXJlbnRGcmFnbWVudFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydGVkRG9jdW1lbnQgPSBmcmFnbWVudFRvRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogaW5zZXJ0ZWRGcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnREb2N1bWVudCA9IGltbXV0YWJsZUZyYWdtZW50LmdldFN1YkRvY3VtZW50RnJvbUZyYWdtZW50UGF0aChkcmFmdERvY3VtZW50LCBwYXJlbnRGcmFnbWVudFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRGcmFnbWVudC50eXBlID09PSAxIC8qIExpc3QgKi8gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ID0gcGFyZW50RG9jdW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb2N1bWVudEluZGV4ID0gaW5zZXJ0ZWRGcmFnbWVudC5wYXJlbnRMaXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGRvY3VtZW50SW5kZXgsIDAsIGluc2VydGVkRG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluc2VydGVkRnJhZ21lbnQucGFyZW50TWFwS2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREb2N1bWVudFtpbmRleF0gPSBpbnNlcnRlZERvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcucmVtb3RlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltSZW1vdGUgb3BlcmF0aW9uIGluIHN0b3JlIFwiLmNvbmNhdChzdG9yZU5hbWUsIFwiXSBJbnNlcnQgY29tcGxldGVkIG9uIGZyYWdtZW50IFwiKS5jb25jYXQob3BlcmF0aW9uLnZhbHVlLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBsYWNlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gUmVwbGFjaW5nIGZyYWdtZW50IFwiKS5jb25jYXQob3BlcmF0aW9uLmlkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVXaXRoRnJhZ21lbnRJZFJlc3VsdCA9IGltbXV0YWJsZUZyYWdtZW50LmRlbGV0ZVdpdGhGcmFnbWVudElkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZDogb3BlcmF0aW9uLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWxldGVXaXRoRnJhZ21lbnRJZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcucmVtb3RlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gRmFpbGVkIHRvIGRlbGV0ZSBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCwgXCIgKHJlcGxhY2UpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gRGVsZXRlZCBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCwgXCIgKHJlcGxhY2UpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRJbmRleCA9IGRlbGV0ZVdpdGhGcmFnbWVudElkUmVzdWx0LnJlbW92ZWRJbmRleCwgcGFyZW50RnJhZ21lbnQxID0gZGVsZXRlV2l0aEZyYWdtZW50SWRSZXN1bHQucGFyZW50RnJhZ21lbnQsIHBhcmVudEZyYWdtZW50UGF0aDEgPSBkZWxldGVXaXRoRnJhZ21lbnRJZFJlc3VsdC5wYXJlbnRGcmFnbWVudFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50VG9JbnNlcnQgPSBjbG9uZShvcGVyYXRpb24udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRGcmFnbWVudDEudHlwZSA9PT0gMSAvKiBMaXN0ICovICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudFRvSW5zZXJ0LnBhcmVudExpc3RJbmRleCA9IHJlbW92ZWRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydFdpdGhGcmFnbWVudElkUmVzdWx0MSA9IGltbXV0YWJsZUZyYWdtZW50Lmluc2VydFdpdGhGcmFnbWVudElkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0ZWRGcmFnbWVudDogZnJhZ21lbnRUb0luc2VydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50RnJhZ21lbnRJZDogZnJhZ21lbnRUb0luc2VydC5wYXJlbnRJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5zZXJ0V2l0aEZyYWdtZW50SWRSZXN1bHQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltSZW1vdGUgb3BlcmF0aW9uIGluIHN0b3JlIFwiLmNvbmNhdChzdG9yZU5hbWUsIFwiXSBGYWlsZWQgdG8gaW5zZXJ0IFwiKS5jb25jYXQob3BlcmF0aW9uLmlkLCBcIiAocmVwbGFjZSlcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcucmVtb3RlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIltSZW1vdGUgb3BlcmF0aW9uIGluIHN0b3JlIFwiLmNvbmNhdChzdG9yZU5hbWUsIFwiXSBJbnNlcnRlZCBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCwgXCIgKHJlcGxhY2UpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydGVkRnJhZ21lbnQxID0gaW5zZXJ0V2l0aEZyYWdtZW50SWRSZXN1bHQxLmluc2VydGVkRnJhZ21lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc2VydGVkRG9jdW1lbnQxID0gZnJhZ21lbnRUb0RvY3VtZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IGluc2VydGVkRnJhZ21lbnQxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudERvY3VtZW50MSA9IGltbXV0YWJsZUZyYWdtZW50LmdldFN1YkRvY3VtZW50RnJvbUZyYWdtZW50UGF0aChkcmFmdERvY3VtZW50LCBwYXJlbnRGcmFnbWVudFBhdGgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50RnJhZ21lbnQxLnR5cGUgPT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QxID0gcGFyZW50RG9jdW1lbnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9jdW1lbnRJbmRleDEgPSBpbnNlcnRlZEZyYWdtZW50MS5wYXJlbnRMaXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QxW2RvY3VtZW50SW5kZXgxXSA9IGluc2VydGVkRG9jdW1lbnQxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleDEgPSBpbnNlcnRlZEZyYWdtZW50MS5wYXJlbnRNYXBLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudERvY3VtZW50MVtpbmRleDFdID0gaW5zZXJ0ZWREb2N1bWVudDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlbW90ZSBvcGVyYXRpb24gaW4gc3RvcmUgXCIuY29uY2F0KHN0b3JlTmFtZSwgXCJdIFJlcGxhY2VkIHN1Y2Nlc3NmdWxseSBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gRGVsZXRlIHN0YXJ0ZWQgb24gZnJhZ21lbnQgXCIpLmNvbmNhdChvcGVyYXRpb24uaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0ZVdpdGhGcmFnbWVudElkUmVzdWx0MSA9IGltbXV0YWJsZUZyYWdtZW50LmRlbGV0ZVdpdGhGcmFnbWVudElkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZDogb3BlcmF0aW9uLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWxldGVXaXRoRnJhZ21lbnRJZFJlc3VsdDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlbW90ZSBvcGVyYXRpb24gaW4gc3RvcmUgXCIuY29uY2F0KHN0b3JlTmFtZSwgXCJdIERlbGV0ZSBkaWQgbm90IGZpbmlzaCBvbiBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZEluZGV4MSA9IGRlbGV0ZVdpdGhGcmFnbWVudElkUmVzdWx0MS5yZW1vdmVkSW5kZXgsIHBhcmVudEZyYWdtZW50MiA9IGRlbGV0ZVdpdGhGcmFnbWVudElkUmVzdWx0MS5wYXJlbnRGcmFnbWVudCwgcGFyZW50RnJhZ21lbnRQYXRoMiA9IGRlbGV0ZVdpdGhGcmFnbWVudElkUmVzdWx0MS5wYXJlbnRGcmFnbWVudFBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudERvY3VtZW50MiA9IGltbXV0YWJsZUZyYWdtZW50LmdldFN1YkRvY3VtZW50RnJvbUZyYWdtZW50UGF0aChkcmFmdERvY3VtZW50LCBwYXJlbnRGcmFnbWVudFBhdGgyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50RnJhZ21lbnQyLnR5cGUgPT09IDEgLyogTGlzdCAqLyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QyID0gcGFyZW50RG9jdW1lbnQyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0Mi5zcGxpY2UocmVtb3ZlZEluZGV4MSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmVudERvY3VtZW50MltyZW1vdmVkSW5kZXgxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZy5sb2dnaW5nLnJlbW90ZU9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gRGVsZXRlIHN1Y2Nlc3NmdWxseSBvbiBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibW92ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlbW90ZSBvcGVyYXRpb24gaW4gc3RvcmUgXCIuY29uY2F0KHN0b3JlTmFtZSwgXCJdIE1vdmluZyBmcmFnbWVudCBcIikuY29uY2F0KG9wZXJhdGlvbi5pZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZUluZGV4V2l0aEZyYWdtZW50SWRSZXN1bHQgPSBpbW11dGFibGVGcmFnbWVudC5tb3ZlSW5kZXhXaXRoRnJhZ21lbnRJZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50SWQ6IG9wZXJhdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9JbmRleDogb3BlcmF0aW9uLmluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb3ZlSW5kZXhXaXRoRnJhZ21lbnRJZFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcucmVtb3RlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUmVtb3RlIG9wZXJhdGlvbiBpbiBzdG9yZSBcIi5jb25jYXQoc3RvcmVOYW1lLCBcIl0gTW92aW5nIGZhaWxlZCBmb3IgZnJhZ21lbnQgXCIpLmNvbmNhdChvcGVyYXRpb24uaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IG1vdmVJbmRleFdpdGhGcmFnbWVudElkUmVzdWx0LmZyb21JbmRleCwgdG9JbmRleCA9IG1vdmVJbmRleFdpdGhGcmFnbWVudElkUmVzdWx0LnRvSW5kZXgsIGxpc3RGcmFnbWVudFBhdGggPSBtb3ZlSW5kZXhXaXRoRnJhZ21lbnRJZFJlc3VsdC5saXN0RnJhZ21lbnRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0MyA9IGltbXV0YWJsZUZyYWdtZW50LmdldFN1YkRvY3VtZW50RnJvbUZyYWdtZW50UGF0aChkcmFmdERvY3VtZW50LCBsaXN0RnJhZ21lbnRQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0My5zcGxpY2UodG9JbmRleCwgMCwgbGlzdDMuc3BsaWNlKGZyb21JbmRleCwgMSlbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5yZW1vdGVPcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiW1JlbW90ZSBvcGVyYXRpb24gaW4gc3RvcmUgXCIuY29uY2F0KHN0b3JlTmFtZSwgXCJdIE1vdmluZyB3YXMgc3VjY2Vzc2Z1bCBmb3IgZnJhZ21lbnQgXCIpLmNvbmNhdChvcGVyYXRpb24uaWQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuaGFuZGxlZCBvcGVyYXRpb24gbWVzc2FnZSAnXCIuY29uY2F0KG9wZXJhdGlvbi5vcCwgXCInIGZvciBhIFwiKS5jb25jYXQoZnJhZ21lbnQudHlwZSwgXCIgZnJhZ21lbnQuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9pdGVyYXRvci5yZXR1cm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5ld0RvY3VtZW50OiBuZXdEb2N1bWVudCxcbiAgICAgICAgbmV3RnJhZ21lbnQ6IGltbXV0YWJsZUZyYWdtZW50LmdldEZyYWdtZW50KCksXG4gICAgICAgIG5ld0ZyYWdtZW50SWRUb1BhdGg6IGltbXV0YWJsZUZyYWdtZW50LmdldEZyYWdtZW50SWRUb1BhdGgoKVxuICAgIH07XG59O1xuLy8gc3JjL2NoYW5uZWxzL2RvY3VtZW50L3N0b3JlL3VzZVJlYWx0aW1lU3RvcmUudHNcbigwLCBpbXBvcnRfaW1tZXIzLmVuYWJsZVBhdGNoZXMpKCk7XG52YXIgdXNlUmVhbHRpbWVTdG9yZSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIG9uUGF0Y2hPcGVyYXRpb25zID0gcGFyYW0ub25QYXRjaE9wZXJhdGlvbnMsIGNvbmZpZyA9IHBhcmFtLmNvbmZpZywgbmFtZSA9IHBhcmFtLm5hbWU7XG4gICAgdmFyIG9uUGF0Y2hPcGVyYXRpb25zUmVmID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZVJlZikoKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0MTEudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgb25QYXRjaE9wZXJhdGlvbnNSZWYuY3VycmVudCA9IG9uUGF0Y2hPcGVyYXRpb25zO1xuICAgIH0sIFtcbiAgICAgICAgb25QYXRjaE9wZXJhdGlvbnNcbiAgICBdKTtcbiAgICB2YXIgdXNlU3RvcmVXaXRoUGF0Y2hSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlUmVmKSgoMCwgaW1wb3J0X3p1c3RhbmQzLmNyZWF0ZSkoKSgoMCwgaW1wb3J0X21pZGRsZXdhcmUzLnN1YnNjcmliZVdpdGhTZWxlY3RvcikoZnVuY3Rpb24oc2V0LCBnZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvY3VtZW50OiB2b2lkIDAsXG4gICAgICAgICAgICBmcmFnbWVudDogdm9pZCAwLFxuICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogdm9pZCAwLFxuICAgICAgICAgICAgZ2V0Um9vdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFJvb3Q6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50ID0gcGFyYW0uZG9jdW1lbnQsIGZyYWdtZW50ID0gcGFyYW0uZnJhZ21lbnQsIGZyYWdtZW50SWRUb1BhdGggPSBwYXJhbS5mcmFnbWVudElkVG9QYXRoO1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudCAmJiBmcmFnbWVudCAmJiBmcmFnbWVudElkVG9QYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogKDAsIGltcG9ydF9pbW1lcjMuZnJlZXplKShkb2N1bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBmcmFnbWVudElkVG9QYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBmcmFnbWVudElkVG9QYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRjaDogZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRG9jdW1lbnQgPSBnZXQoKS5kb2N1bWVudDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRnJhZ21lbnQgPSBnZXQoKS5mcmFnbWVudDtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRnJhZ21lbnRJZFRvUGF0aCA9IGdldCgpLmZyYWdtZW50SWRUb1BhdGg7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYgPSBfc2xpY2VkX3RvX2FycmF5KCgwLCBpbXBvcnRfaW1tZXIzLnByb2R1Y2VXaXRoUGF0Y2hlcykob2xkRG9jdW1lbnQsIGZuKSwgMyksIG5ld0RvY3VtZW50ID0gX3JlZlswXSwgcGF0Y2hlcyA9IF9yZWZbMV0sIGludmVydFBhdGNoZXMgPSBfcmVmWzJdO1xuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb25zID0gaW1tZXJQYXRjaGVzVG9PcGVyYXRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0Y2hlczogcGF0Y2hlcyxcbiAgICAgICAgICAgICAgICAgICAgb2xkRG9jdW1lbnQ6IG9sZERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBuZXdEb2N1bWVudDogbmV3RG9jdW1lbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB2YXIgX2FwcGx5UGF0Y2hPcGVyYXRpb25zVG9GcmFnbWVudCA9IGFwcGx5UGF0Y2hPcGVyYXRpb25zVG9GcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBvbGRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogb2xkRnJhZ21lbnRJZFRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogb3BlcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcbiAgICAgICAgICAgICAgICB9KSwgbmV3RnJhZ21lbnQgPSBfYXBwbHlQYXRjaE9wZXJhdGlvbnNUb0ZyYWdtZW50Lm5ld0ZyYWdtZW50LCBuZXdGcmFnbWVudElkVG9QYXRoID0gX2FwcGx5UGF0Y2hPcGVyYXRpb25zVG9GcmFnbWVudC5uZXdGcmFnbWVudElkVG9QYXRoLCByZXF1ZXN0cyA9IF9hcHBseVBhdGNoT3BlcmF0aW9uc1RvRnJhZ21lbnQucmVxdWVzdHM7XG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ6IG5ld0RvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogbmV3RnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IG5ld0ZyYWdtZW50SWRUb1BhdGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAob25QYXRjaE9wZXJhdGlvbnNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvblBhdGNoT3BlcmF0aW9uc1JlZi5jdXJyZW50KHJlcXVlc3RzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHlSZW1vdGVPcGVyYXRpb25zOiBmdW5jdGlvbihtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIHZhciBvbGREb2N1bWVudCA9IGdldCgpLmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIHZhciBvbGRGcmFnbWVudCA9IGdldCgpLmZyYWdtZW50O1xuICAgICAgICAgICAgICAgIHZhciBvbGRGcmFnbWVudElkVG9QYXRoID0gZ2V0KCkuZnJhZ21lbnRJZFRvUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgX2FwcGx5UmVtb3RlT3BlcmF0aW9uc01lc3NhZ2VzID0gYXBwbHlSZW1vdGVPcGVyYXRpb25zTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogb2xkRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBvbGRGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogb2xkRnJhZ21lbnRJZFRvUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgICAgICAgICAgICAgfSksIG5ld0RvY3VtZW50ID0gX2FwcGx5UmVtb3RlT3BlcmF0aW9uc01lc3NhZ2VzLm5ld0RvY3VtZW50LCBuZXdGcmFnbWVudCA9IF9hcHBseVJlbW90ZU9wZXJhdGlvbnNNZXNzYWdlcy5uZXdGcmFnbWVudCwgbmV3RnJhZ21lbnRJZFRvUGF0aCA9IF9hcHBseVJlbW90ZU9wZXJhdGlvbnNNZXNzYWdlcy5uZXdGcmFnbWVudElkVG9QYXRoO1xuICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBuZXdEb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IG5ld0ZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBuZXdGcmFnbWVudElkVG9QYXRoXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzb2x2ZUNvbmZsaWN0czogZnVuY3Rpb24oY29uZmxpY3RGcmFnbWVudElkcywgdHJ1dGhTdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGREb2N1bWVudCA9IGdldCgpLmRvY3VtZW50O1xuICAgICAgICAgICAgICAgIHZhciBvbGRGcmFnbWVudCA9IGdldCgpLmZyYWdtZW50O1xuICAgICAgICAgICAgICAgIHZhciBvbGRGcmFnbWVudElkVG9QYXRoID0gZ2V0KCkuZnJhZ21lbnRJZFRvUGF0aDtcbiAgICAgICAgICAgICAgICB2YXIgdHJ1dGhTdG9yZVJvb3QgPSB0cnV0aFN0b3JlLmdldFJvb3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc29sdmVDb25mbGljdHNJblN0b3JlID0gcmVzb2x2ZUNvbmZsaWN0c0luU3RvcmUoe1xuICAgICAgICAgICAgICAgICAgICBjb25mbGljdEZyYWdtZW50SWRzOiBjb25mbGljdEZyYWdtZW50SWRzLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdFN0b3JlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogb2xkRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogb2xkRnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBvbGRGcmFnbWVudElkVG9QYXRoXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRydXRoU3RvcmU6IHRydXRoU3RvcmVSb290LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgIH0pLCBuZXdEb2N1bWVudCA9IF9yZXNvbHZlQ29uZmxpY3RzSW5TdG9yZS5uZXdEb2N1bWVudCwgbmV3RnJhZ21lbnQgPSBfcmVzb2x2ZUNvbmZsaWN0c0luU3RvcmUubmV3RnJhZ21lbnQsIG5ld0ZyYWdtZW50SWRUb1BhdGggPSBfcmVzb2x2ZUNvbmZsaWN0c0luU3RvcmUubmV3RnJhZ21lbnRJZFRvUGF0aDtcbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogbmV3RG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBuZXdGcmFnbWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogbmV3RnJhZ21lbnRJZFRvUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKSk7XG4gICAgdmFyIGdldE5hbWUgPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGdldFJvb3QgPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZVdpdGhQYXRjaFJlZi5jdXJyZW50LmdldFN0YXRlKCkuZ2V0Um9vdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2V0Um9vdCA9ICgwLCBpbXBvcnRfcmVhY3QxMS51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3BzKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnNldFJvb3QocHJvcHMpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgdXNlU3RvcmUgPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgICAgICAgICAgcmV0dXJuIHVzZVN0b3JlV2l0aFBhdGNoUmVmLmN1cnJlbnQoZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LmZyYWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RvciA/IHNlbGVjdG9yKHJvb3QuZG9jdW1lbnQpIDogcm9vdC5kb2N1bWVudDtcbiAgICAgICAgICAgIH0sIGVxdWFsaXR5Rm4pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc3Vic2NyaWJlID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudC5zdWJzY3JpYmUoZnVuY3Rpb24ocm9vdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByb290LmZyYWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RvciA/IHNlbGVjdG9yKHJvb3QuZG9jdW1lbnQpIDogcm9vdC5kb2N1bWVudDtcbiAgICAgICAgICAgIH0sIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHBhdGNoID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZVdpdGhQYXRjaFJlZi5jdXJyZW50LmdldFN0YXRlKCkucGF0Y2goZm4pO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICB2YXIgYXBwbHlSZW1vdGVPcGVyYXRpb25zID0gKDAsIGltcG9ydF9yZWFjdDExLnVzZU1lbW8pKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obWVzc2FnZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB1c2VTdG9yZVdpdGhQYXRjaFJlZi5jdXJyZW50LmdldFN0YXRlKCkuYXBwbHlSZW1vdGVPcGVyYXRpb25zKG1lc3NhZ2VzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlc29sdmVDb25mbGljdHMgPSAoMCwgaW1wb3J0X3JlYWN0MTEudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjb25mbGljdEZyYWdtZW50SWRzLCB0cnV0aFN0b3JlKSB7XG4gICAgICAgICAgICByZXR1cm4gdXNlU3RvcmVXaXRoUGF0Y2hSZWYuY3VycmVudC5nZXRTdGF0ZSgpLnJlc29sdmVDb25mbGljdHMoY29uZmxpY3RGcmFnbWVudElkcywgdHJ1dGhTdG9yZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldE5hbWU6IGdldE5hbWUsXG4gICAgICAgIGdldFJvb3Q6IGdldFJvb3QsXG4gICAgICAgIHNldFJvb3Q6IHNldFJvb3QsXG4gICAgICAgIHVzZVN0b3JlOiB1c2VTdG9yZSxcbiAgICAgICAgcGF0Y2g6IHBhdGNoLFxuICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICAgICAgYXBwbHlSZW1vdGVPcGVyYXRpb25zOiBhcHBseVJlbW90ZU9wZXJhdGlvbnMsXG4gICAgICAgIHJlc29sdmVDb25mbGljdHM6IHJlc29sdmVDb25mbGljdHNcbiAgICB9O1xufTtcbi8vIHNyYy9jaGFubmVscy9kb2N1bWVudC91c2VEb2N1bWVudC50c1xudmFyIE9wc01lc3NhZ2VUeXBlID0gXCJvcHNcIjtcbnZhciBNYXhPcHNQZXJNZXNzYWdlID0gMzA7XG52YXIgdXNlRG9jdW1lbnRDaGFubmVsID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICB2YXIgY29uZmlnID0gcGFyYW0uY29uZmlnLCBjb25uZWN0aW9uU3RhdHVzID0gcGFyYW0uY29ubmVjdGlvblN0YXR1cywgY29ubmVjdGlvblN0YXR1c1JlZiA9IHBhcmFtLmNvbm5lY3Rpb25TdGF0dXNSZWYsIHVzZUNoYW5uZWwgPSBwYXJhbS51c2VDaGFubmVsLCBkb2N1bWVudElkID0gcGFyYW0uZG9jdW1lbnRJZCwgcmVxdWVzdGVkVGhyb3R0bGUgPSBwYXJhbS50aHJvdHRsZTtcbiAgICB2YXIgX3JlZiA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdDEyLnVzZVN0YXRlKShcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovICksIDIpLCBzdWJzY3JpcHRpb25TdGF0dXMgPSBfcmVmWzBdLCBzZXRTdWJzY3JpcHRpb25TdGF0dXMgPSBfcmVmWzFdO1xuICAgIHZhciBzdWJzY3JpcHRpb25TdGF0dXNSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlUmVmKShcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovICk7XG4gICAgdmFyIF9yZWYxID0gX3NsaWNlZF90b19hcnJheSgoMCwgaW1wb3J0X3JlYWN0MTIudXNlU3RhdGUpKFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKSwgMiksIGF2YWlsYWJpbGl0eVN0YXR1cyA9IF9yZWYxWzBdLCBzZXRBdmFpbGFiaWxpdHlTdGF0dXMgPSBfcmVmMVsxXTtcbiAgICB2YXIgYXZhaWxhYmlsaXR5U3RhdHVzUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoXCJVbnJlYWR5XCIgLyogVW5yZWFkeSAqLyApO1xuICAgIHZhciBfcmVmMiA9IF9zbGljZWRfdG9fYXJyYXkoKDAsIGltcG9ydF9yZWFjdDEyLnVzZVN0YXRlKSgwKSwgMiksIHRocm90dGxlID0gX3JlZjJbMF0sIHNldFRocm90dGxlID0gX3JlZjJbMV07XG4gICAgdmFyIHNlbmRNZXNzYWdlUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoKTtcbiAgICB2YXIgZG9jdW1lbnRJZFJlZiA9ICgwLCBpbXBvcnRfcmVhY3QxMi51c2VSZWYpKGRvY3VtZW50SWQpO1xuICAgIHZhciBwcmVTeW5jUmVjZWl2ZWRPcGVyYXRpb25zUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoW10pO1xuICAgIHZhciBjb25mbGljdHNJZHNSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlUmVmKShbXSk7XG4gICAgdmFyIHVuYWNrZWRPcGVyYXRpb25zUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoW10pO1xuICAgIHZhciBzYXZlTG9jYWxDaGFuZ2VzUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9uSWRSZWYgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlUmVmKSgpO1xuICAgIHZhciBzdWJzY3JpYmVkVG9Eb2N1bWVudElkUmVmID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZVJlZikoKTtcbiAgICB2YXIgc2VuZE9wZXJhdGlvbnMgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF9jb25mbGljdHNJZHNSZWZfY3VycmVudDtcbiAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSByZXF1ZXN0Lm9wZXJhdGlvbnNbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKXtcbiAgICAgICAgICAgICAgICB2YXIgb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2gob3Aub3Ape1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicm9vdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gob3AudmFsdWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJpbnNlcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKG9wLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gob3AudmFsdWUucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gob3AudmFsdWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtb3ZlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHMucHVzaChvcC5wYXJlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2gob3AucGFyZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9kaWRJdGVyYXRvckVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIChfY29uZmxpY3RzSWRzUmVmX2N1cnJlbnQgPSBjb25mbGljdHNJZHNSZWYuY3VycmVudCkucHVzaC5hcHBseShfY29uZmxpY3RzSWRzUmVmX2N1cnJlbnQsIF90b19jb25zdW1hYmxlX2FycmF5KGNvbmZsaWN0cykpO1xuICAgICAgICB1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50LnB1c2gocmVxdWVzdCk7XG4gICAgICAgIHNlbmRNZXNzYWdlUmVmLmN1cnJlbnQocmVxdWVzdCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBvbkxvY2FsUGF0Y2hPcGVyYXRpb25zID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZUNhbGxiYWNrKShmdW5jdGlvbihyZXF1ZXN0cykge1xuICAgICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXNzYWdlSWQ6IHVuaXF1ZUlkKCksXG4gICAgICAgICAgICBzdWJJZDogc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudCxcbiAgICAgICAgICAgIHR5cGU6IE9wc01lc3NhZ2VUeXBlLFxuICAgICAgICAgICAgb3BlcmF0aW9uczogcmVxdWVzdHNcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNhdmVMb2NhbENoYW5nZXNSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgc2F2ZUxvY2FsQ2hhbmdlc1JlZi5jdXJyZW50KHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0dXNSZWYuY3VycmVudCAhPT0gXCJSZWFkeVwiIC8qIFJlYWR5ICovICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbmRPcGVyYXRpb25zKHJlcXVlc3QpO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgbG9jYWxTdG9yZSA9IHVzZVJlYWx0aW1lU3RvcmUoe1xuICAgICAgICBvblBhdGNoT3BlcmF0aW9uczogb25Mb2NhbFBhdGNoT3BlcmF0aW9ucyxcbiAgICAgICAgbmFtZTogXCJsb2NhbFwiLFxuICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgIH0pO1xuICAgIHZhciByZW1vdGVTdG9yZSA9IHVzZVJlYWx0aW1lU3RvcmUoe1xuICAgICAgICBuYW1lOiBcImxvY2FsXCIsXG4gICAgICAgIGNvbmZpZzogY29uZmlnXG4gICAgfSk7XG4gICAgdmFyIF91c2VEb2N1bWVudEF1dG9zYXZlID0gdXNlRG9jdW1lbnRBdXRvc2F2ZSh7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkLFxuICAgICAgICBzdWJzY3JpcHRpb25JZFJlZjogc3Vic2NyaXB0aW9uSWRSZWYsXG4gICAgICAgIGxvY2FsU3RvcmU6IGxvY2FsU3RvcmUsXG4gICAgICAgIG9uTG9jYWxEYXRhOiAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgPT09IFwiUmVhZHlcIiAvKiBSZWFkeSAqLyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQudHlwZSAhPT0gMSAvKiBMaXN0ICovICAmJiBmcmFnbWVudC50eXBlICE9PSAyIC8qIE1hcCAqLyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZG9jdW1lbnQgPSBmcmFnbWVudFRvRG9jdW1lbnQoe1xuICAgICAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRJZFRvUGF0aCA9IGNyZWF0ZUZyYWdtZW50SWRUb1BhdGgoe1xuICAgICAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2NhbFN0b3JlLnNldFJvb3Qoe1xuICAgICAgICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICAgICAgZnJhZ21lbnRJZFRvUGF0aDogX29iamVjdF9zcHJlYWQoe30sIGZyYWdtZW50SWRUb1BhdGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZsaWN0c0lkc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICB1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICBzZXRBdmFpbGFiaWxpdHlTdGF0dXMoXCJSZWFkeUxvY2FsXCIgLyogUmVhZHlMb2NhbCAqLyApO1xuICAgICAgICAgICAgYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgPSBcIlJlYWR5TG9jYWxcIiAvKiBSZWFkeUxvY2FsICovIDtcbiAgICAgICAgfSwgW10pLFxuICAgICAgICBvbk5vTG9jYWxEYXRhOiAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGF2YWlsYWJpbGl0eVN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmxpY3RzSWRzUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgIHVuYWNrZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgICAgIHNldEF2YWlsYWJpbGl0eVN0YXR1cyhcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovICk7XG4gICAgICAgICAgICBhdmFpbGFiaWxpdHlTdGF0dXNSZWYuY3VycmVudCA9IFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gO1xuICAgICAgICB9LCBbXSlcbiAgICB9KSwgc2F2ZUxvY2FsQ2hhbmdlcyA9IF91c2VEb2N1bWVudEF1dG9zYXZlLnNhdmVMb2NhbENoYW5nZXMsIG1hcmtGb3JMb2NhbFNhdmluZyA9IF91c2VEb2N1bWVudEF1dG9zYXZlLm1hcmtGb3JMb2NhbFNhdmluZywgdXBkYXRlTG9jYWxDaGFuZ2VzID0gX3VzZURvY3VtZW50QXV0b3NhdmUudXBkYXRlTG9jYWxDaGFuZ2VzLCBnZXRMb2NhbENoYW5nZXNUb1N5bmMgPSBfdXNlRG9jdW1lbnRBdXRvc2F2ZS5nZXRMb2NhbENoYW5nZXNUb1N5bmMsIGFja25vd2xlZGdlTG9jYWxDaGFuZ2UgPSBfdXNlRG9jdW1lbnRBdXRvc2F2ZS5hY2tub3dsZWRnZUxvY2FsQ2hhbmdlO1xuICAgICgwLCBpbXBvcnRfcmVhY3QxMi51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBzYXZlTG9jYWxDaGFuZ2VzUmVmLmN1cnJlbnQgPSBzYXZlTG9jYWxDaGFuZ2VzO1xuICAgIH0sIFtcbiAgICAgICAgc2F2ZUxvY2FsQ2hhbmdlc1xuICAgIF0pO1xuICAgICgwLCBpbXBvcnRfcmVhY3QxMi51c2VFZmZlY3QpKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdHVzICE9PSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gKSB7XG4gICAgICAgICAgICBzZXRUaHJvdHRsZSgwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRUaHJvdHRsZShyZXF1ZXN0ZWRUaHJvdHRsZSk7XG4gICAgfSwgW1xuICAgICAgICBzdWJzY3JpcHRpb25TdGF0dXMsXG4gICAgICAgIHJlcXVlc3RlZFRocm90dGxlXG4gICAgXSk7XG4gICAgdmFyIG9uU3luY01lc3NhZ2UgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKGZyYWdtZW50KSB7XG4gICAgICAgIHZhciBsb2NhbENoYW5nZXMgPSBnZXRMb2NhbENoYW5nZXNUb1N5bmMoKTtcbiAgICAgICAgdmFyIGRvY3VtZW50ID0gZnJhZ21lbnRUb0RvY3VtZW50KHtcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZyYWdtZW50SWRUb1BhdGggPSBjcmVhdGVGcmFnbWVudElkVG9QYXRoKHtcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICB9KTtcbiAgICAgICAgbG9jYWxTdG9yZS5zZXRSb290KHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudCxcbiAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IF9vYmplY3Rfc3ByZWFkKHt9LCBmcmFnbWVudElkVG9QYXRoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3RlU3RvcmUuc2V0Um9vdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogZG9jdW1lbnQsXG4gICAgICAgICAgICBmcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBfb2JqZWN0X3NwcmVhZCh7fSwgZnJhZ21lbnRJZFRvUGF0aClcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbmZsaWN0c0lkc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgIHVuYWNrZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQgPSBbXTtcbiAgICAgICAgaWYgKHByZVN5bmNSZWNlaXZlZE9wZXJhdGlvbnNSZWYuY3VycmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhcHBseVJlbW90ZU9wZXJhdGlvbnNUb1N0b3JlcyhwcmVTeW5jUmVjZWl2ZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQsIFtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JlLFxuICAgICAgICAgICAgICAgIHJlbW90ZVN0b3JlXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHByZVN5bmNSZWNlaXZlZE9wZXJhdGlvbnNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbENoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgYXBwbHlSZW1vdGVPcGVyYXRpb25zVG9TdG9yZXMobG9jYWxDaGFuZ2VzLCBbXG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yZVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2UsIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IGxvY2FsQ2hhbmdlc1tTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzZW5kT3BlcmF0aW9ucyhyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNldFN1YnNjcmlwdGlvblN0YXR1cyhcIlJlYWR5XCIgLyogUmVhZHkgKi8gKTtcbiAgICAgICAgc3Vic2NyaXB0aW9uU3RhdHVzUmVmLmN1cnJlbnQgPSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gO1xuICAgICAgICBzZXRBdmFpbGFiaWxpdHlTdGF0dXMoXCJSZWFkeVwiIC8qIFJlYWR5ICovICk7XG4gICAgICAgIGF2YWlsYWJpbGl0eVN0YXR1c1JlZi5jdXJyZW50ID0gXCJSZWFkeVwiIC8qIFJlYWR5ICovIDtcbiAgICAgICAgbWFya0ZvckxvY2FsU2F2aW5nKCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBvbkFja01lc3NhZ2UgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKGFjaykge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiUmVhZHlcIiAvKiBSZWFkeSAqLyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdCA9IHVuYWNrZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQuZmluZChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICByZXR1cm4gci5tZXNzYWdlSWQgPT09IGFjay5hY2tNZXNzYWdlSWQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IodmFyIG9wSW5kZXggPSAwOyBvcEluZGV4IDwgcmVxdWVzdC5vcGVyYXRpb25zLmxlbmd0aDsgKytvcEluZGV4KXtcbiAgICAgICAgICAgIHZhciBfYWNrX29wc01ldGFkYXRhO1xuICAgICAgICAgICAgdmFyIG9wTWV0YWRhdGEgPSAoX2Fja19vcHNNZXRhZGF0YSA9IGFjay5vcHNNZXRhZGF0YSkgPT09IG51bGwgfHwgX2Fja19vcHNNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Fja19vcHNNZXRhZGF0YVtvcEluZGV4XTtcbiAgICAgICAgICAgIGlmICghb3BNZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHJlcXVlc3Qub3BlcmF0aW9uc1tvcEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IFwiaW5zZXJ0XCIgJiYgb3BNZXRhZGF0YS5wYXJlbnRMaXN0SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5wYXJlbnRMaXN0SW5kZXggPSBvcE1ldGFkYXRhLnBhcmVudExpc3RJbmRleDtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmFsdWUucGFyZW50TGlzdEluZGV4ID0gb3BNZXRhZGF0YS5wYXJlbnRMaXN0SW5kZXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbi5vcCA9PT0gXCJyZXBsYWNlXCIgJiYgb3BNZXRhZGF0YS5wYXJlbnRMaXN0SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi52YWx1ZS5wYXJlbnRMaXN0SW5kZXggPSBvcE1ldGFkYXRhLnBhcmVudExpc3RJbmRleDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLm9wID09PSBcIm1vdmVcIiAmJiBvcE1ldGFkYXRhLmluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24uaW5kZXggPSBvcE1ldGFkYXRhLmluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wTWV0YWRhdGEuaWdub3JlZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlcmF0aW9uc1tvcEluZGV4XSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0Lm9wZXJhdGlvbnMgPSByZXF1ZXN0Lm9wZXJhdGlvbnMuZmlsdGVyKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgIHJldHVybiAhIW87XG4gICAgICAgIH0pO1xuICAgICAgICB1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50LnNwbGljZSh1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50LmluZGV4T2YocmVxdWVzdCksIDEpO1xuICAgICAgICBhcHBseVJlbW90ZU9wZXJhdGlvbnNUb1N0b3JlcyhbXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIHJlbW90ZVN0b3JlXG4gICAgICAgIF0pO1xuICAgICAgICBhY2tub3dsZWRnZUxvY2FsQ2hhbmdlKGFjay5hY2tNZXNzYWdlSWQpO1xuICAgICAgICBpZiAodW5hY2tlZE9wZXJhdGlvbnNSZWYuY3VycmVudC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmIChjb25maWcubG9nZ2luZy5jb25mbGljdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJlc29sdmluZyBjb25mbGljdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2NhbFN0b3JlLnJlc29sdmVDb25mbGljdHMoY29uZmxpY3RzSWRzUmVmLmN1cnJlbnQsIHJlbW90ZVN0b3JlKTtcbiAgICAgICAgICAgIGNvbmZsaWN0c0lkc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgICAgICBpZiAoY29uZmlnLmxvZ2dpbmcuY29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsID0gbG9jYWxTdG9yZS5nZXRSb290KCk7XG4gICAgICAgICAgICAgICAgdmFyIHJlbW90ZSA9IHJlbW90ZVN0b3JlLmdldFJvb3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVzRXF1YWwgPSBhcmVTdG9yZXNFcXVhbCh7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50OiBsb2NhbC5kb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQ6IGxvY2FsLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiBsb2NhbC5mcmFnbWVudElkVG9QYXRoXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudDogcmVtb3RlLmRvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogcmVtb3RlLmZyYWdtZW50LFxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudElkVG9QYXRoOiByZW1vdGUuZnJhZ21lbnRJZFRvUGF0aFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghc3RvcmVzRXF1YWwuZG9jdW1lbnRzRXF1YWwgfHwgIXN0b3Jlc0VxdWFsLmZyYWdtZW50c0VxdWFsIHx8ICFzdG9yZXNFcXVhbC5mcmFnbWVudElkVG9QYXRoc0VxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvbmZsaWN0cyBub3QgcmVzb2x2ZWQuIFJlbW90ZSBhbmQgbG9jYWwgYXJlIE5PVCBlcXVhbCFcIiwgXCJQcmV2aW91cyByZXF1ZXN0IC0+IFwiLCByZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9yZXNFcXVhbC5kb2N1bWVudHNFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRG9jdW1lbnRzIG5vdCBlcXVhbFwiLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxvY2FsLmRvY3VtZW50KSksIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVtb3RlLmRvY3VtZW50KSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RvcmVzRXF1YWwuZnJhZ21lbnRzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZyYWdtZW50cyBub3QgZXF1YWxcIiwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShsb2NhbC5mcmFnbWVudCkpLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlbW90ZS5mcmFnbWVudCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3Jlc0VxdWFsLmZyYWdtZW50SWRUb1BhdGhzRXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkZyYWdtZW50IGlkIHRvIHBhdGhzIG5vdCBlcXVhbFwiLCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxvY2FsLmZyYWdtZW50SWRUb1BhdGgpKSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZW1vdGUuZnJhZ21lbnRJZFRvUGF0aCkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29uZmxpY3RzIHJlc29sdmVkLCByZW1vdGUgYW5kIGxvY2FsIGFyZSBlcXVhbC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHZhciBvbk9wc01lc3NhZ2UgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlN1YnNjcmliaW5nXCIgLyogU3Vic2NyaWJpbmcgKi8gKSB7XG4gICAgICAgICAgICBwcmVTeW5jUmVjZWl2ZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uU3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiUmVhZHlcIiAvKiBSZWFkeSAqLyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVJlbW90ZU9wZXJhdGlvbnNUb1N0b3JlcyhbXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIF0sIFtcbiAgICAgICAgICAgIGxvY2FsU3RvcmUsXG4gICAgICAgICAgICByZW1vdGVTdG9yZVxuICAgICAgICBdKTtcbiAgICAgICAgbWFya0ZvckxvY2FsU2F2aW5nKCk7XG4gICAgfSwgW10pO1xuICAgIHZhciBvbkRvY3VtZW50TWVzc2FnZSA9ICgwLCBpbXBvcnRfcmVhY3QxMi51c2VDYWxsYmFjaykoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZS5kb2NJZCAhPT0gZG9jdW1lbnRJZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlIFwic3luY1wiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkUmVmLmN1cnJlbnQgIT09IG1lc3NhZ2Uuc3ViSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblN5bmNNZXNzYWdlKG1lc3NhZ2UuZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhY2tcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY2tNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkUmVmLmN1cnJlbnQgIT09IGFja01lc3NhZ2Uuc3ViSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvbkFja01lc3NhZ2UoYWNrTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wc1wiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50T3BzTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb25JZFJlZi5jdXJyZW50ID09PSBkb2N1bWVudE9wc01lc3NhZ2UuY2xpZW50U3ViSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvbk9wc01lc3NhZ2UoZG9jdW1lbnRPcHNNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkRvY3VtZW50IG1lc3NhZ2Ugd2l0aCB0eXBlICdcIi5jb25jYXQobWVzc2FnZS50eXBlLCBcIicgdW5oYW5kbGVkLlwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIG9uU3luY01lc3NhZ2UsXG4gICAgICAgIG9uQWNrTWVzc2FnZSxcbiAgICAgICAgb25PcHNNZXNzYWdlXG4gICAgXSk7XG4gICAgdmFyIHBhdGNoID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZUNhbGxiYWNrKShmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAoYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiUmVhZHlcIiAvKiBSZWFkeSAqLyAgJiYgYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgIT09IFwiUmVhZHlMb2NhbFwiIC8qIFJlYWR5TG9jYWwgKi8gKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3QgcGF0Y2ggZG9jdW1lbnQgd2hlbiBkb2N1bWVudCBlZGl0IHN0YXR1cyBpcyBcIi5jb25jYXQoYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQsIFwiLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxTdG9yZS5wYXRjaChmbik7XG4gICAgfSwgW1xuICAgICAgICBsb2NhbFN0b3JlXG4gICAgXSk7XG4gICAgdmFyIGdyb3VwTWVzc2FnZXNPblNlbmQgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBub3RPcHNNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS50eXBlICE9PSBPcHNNZXNzYWdlVHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvcHNNZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS50eXBlID09PSBPcHNNZXNzYWdlVHlwZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvcHNNZXNzYWdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBub3RPcHNNZXNzYWdlcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JvdXBlZE1lc3NhZ2VzID0gW107XG4gICAgICAgIHZhciBvcHNNZXNzYWdlc0J5U3ViSWRNYXAgPSBncm91cEJ5KG9wc01lc3NhZ2VzLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5zdWJJZDtcbiAgICAgICAgfSk7XG4gICAgICAgIG9wc01lc3NhZ2VzQnlTdWJJZE1hcC5mb3JFYWNoKGZ1bmN0aW9uKG9wc01lc3NhZ2VzQnlTdWJJZCwgc3ViSWQpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoc3ViSWQgIT09IHN1YnNjcmlwdGlvbklkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvcHNNZXNzYWdlc0J5U3ViSWQgPSBvcHNNZXNzYWdlc0J5U3ViSWQuZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0udHlwZSAhPT0gT3BzTWVzc2FnZVR5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IChfaW5zdGFuY2UgPSBbXSkuY29uY2F0LmFwcGx5KF9pbnN0YW5jZSwgX3RvX2NvbnN1bWFibGVfYXJyYXkob3BzTWVzc2FnZXNCeVN1YklkLm1hcChmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0ub3BlcmF0aW9ucztcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB2YXIgbWluaWZpZWRPcGVyYXRpb25zID0gbWluaWZ5T3BlcmF0aW9ucyhvcGVyYXRpb25zKTtcbiAgICAgICAgICAgIGlmIChtaW5pZmllZE9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1pbmlmaWVkT3BlcmF0aW9ucy5sZW5ndGg7IGkgKz0gTWF4T3BzUGVyTWVzc2FnZSl7XG4gICAgICAgICAgICAgICAgdmFyIGNodW5rID0gbWluaWZpZWRPcGVyYXRpb25zLnNsaWNlKGksIGkgKyBNYXhPcHNQZXJNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBncm91cGVkTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3BzTWVzc2FnZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHN1YklkOiBzdWJJZCxcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uczogY2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChncm91cGVkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIF91bmFja2VkT3BlcmF0aW9uc1JlZl9jdXJyZW50O1xuICAgICAgICAgICAgdmFyIG9wc0luZGV4ID0gdW5hY2tlZE9wZXJhdGlvbnNSZWYuY3VycmVudC5pbmRleE9mKG9wc01lc3NhZ2VzWzBdKTtcbiAgICAgICAgICAgIChfdW5hY2tlZE9wZXJhdGlvbnNSZWZfY3VycmVudCA9IHVuYWNrZWRPcGVyYXRpb25zUmVmLmN1cnJlbnQpLnNwbGljZS5hcHBseShfdW5hY2tlZE9wZXJhdGlvbnNSZWZfY3VycmVudCwgW1xuICAgICAgICAgICAgICAgIG9wc0luZGV4IDwgMCA/IDAgOiBvcHNJbmRleCxcbiAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICBdLmNvbmNhdChfdG9fY29uc3VtYWJsZV9hcnJheShncm91cGVkTWVzc2FnZXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTG9jYWxDaGFuZ2VzKHtcbiAgICAgICAgICAgIHJlbW92ZWRDaGFuZ2VzOiBvcHNNZXNzYWdlcyxcbiAgICAgICAgICAgIGFkZGVkQ2hhbmdlczogZ3JvdXBlZE1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICB1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50ID0gdW5hY2tlZE9wZXJhdGlvbnNSZWYuY3VycmVudC5maWx0ZXIoZnVuY3Rpb24ob3BNZXNzYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gIW9wc01lc3NhZ2VzLmluY2x1ZGVzKG9wTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZ3JvdXBlZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBfdG9fY29uc3VtYWJsZV9hcnJheShub3RPcHNNZXNzYWdlcykuY29uY2F0KF90b19jb25zdW1hYmxlX2FycmF5KGdyb3VwZWRNZXNzYWdlcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3RPcHNNZXNzYWdlcztcbiAgICB9LCBbXSk7XG4gICAgdmFyIHNlbmRNZXNzYWdlID0gdXNlQ2hhbm5lbCh7XG4gICAgICAgIGNoYW5uZWw6IFwiZG9jdW1lbnRcIixcbiAgICAgICAgb25NZXNzYWdlOiBvbkRvY3VtZW50TWVzc2FnZSxcbiAgICAgICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgICAgICBncm91cE1lc3NhZ2VzT25TZW5kOiBncm91cE1lc3NhZ2VzT25TZW5kXG4gICAgfSkuc2VuZE1lc3NhZ2U7XG4gICAgKDAsIGltcG9ydF9yZWFjdDEyLnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbmRNZXNzYWdlUmVmLmN1cnJlbnQgPSBzZW5kTWVzc2FnZTtcbiAgICB9LCBbXG4gICAgICAgIHNlbmRNZXNzYWdlXG4gICAgXSk7XG4gICAgdmFyIGlzT2ZmbGluZUNhcGFibGUgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmF1dG9zYXZlLmVuYWJsZWQgJiYgKGF2YWlsYWJpbGl0eVN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gIHx8IGF2YWlsYWJpbGl0eVN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlJlYWR5TG9jYWxcIiAvKiBSZWFkeUxvY2FsICovICk7XG4gICAgfSwgW10pO1xuICAgIHZhciByZXNldFN0b3Jlc1RvVW5hdmFpbGFibGUgPSAoMCwgaW1wb3J0X3JlYWN0MTIudXNlQ2FsbGJhY2spKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25mbGljdHNJZHNSZWYuY3VycmVudCA9IFtdO1xuICAgICAgICB1bmFja2VkT3BlcmF0aW9uc1JlZi5jdXJyZW50ID0gW107XG4gICAgICAgIGxvY2FsU3RvcmUuc2V0Um9vdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogdm9pZCAwLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgcmVtb3RlU3RvcmUuc2V0Um9vdCh7XG4gICAgICAgICAgICBkb2N1bWVudDogdm9pZCAwLFxuICAgICAgICAgICAgZnJhZ21lbnQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGZyYWdtZW50SWRUb1BhdGg6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0QXZhaWxhYmlsaXR5U3RhdHVzKFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKTtcbiAgICAgICAgYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgPSBcIlVucmVhZHlcIiAvKiBVbnJlYWR5ICovIDtcbiAgICAgICAgc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgc3Vic2NyaWJlZFRvRG9jdW1lbnRJZFJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgc2V0U3RvcmVMb2NhbGx5QXZhaWxhYmxlID0gKDAsIGltcG9ydF9yZWFjdDEyLnVzZUNhbGxiYWNrKShmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0QXZhaWxhYmlsaXR5U3RhdHVzKFwiUmVhZHlMb2NhbFwiIC8qIFJlYWR5TG9jYWwgKi8gKTtcbiAgICAgICAgYXZhaWxhYmlsaXR5U3RhdHVzUmVmLmN1cnJlbnQgPSBcIlJlYWR5TG9jYWxcIiAvKiBSZWFkeUxvY2FsICovIDtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHN1YnNjcmliZSA9ICgwLCBpbXBvcnRfcmVhY3QxMi51c2VDYWxsYmFjaykoZnVuY3Rpb24oZG9jSWQpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudCA9IHVuaXF1ZUlkKDUpO1xuICAgICAgICBzdWJzY3JpYmVkVG9Eb2N1bWVudElkUmVmLmN1cnJlbnQgPSBkb2NJZDtcbiAgICAgICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgbWVzc2FnZUlkOiB1bmlxdWVJZCgpLFxuICAgICAgICAgICAgdHlwZTogXCJzdWJzY3JpYmVcIixcbiAgICAgICAgICAgIGRvY0lkOiBzdWJzY3JpYmVkVG9Eb2N1bWVudElkUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICBzdWJJZDogc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDEyLnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzICE9PSBcIk9wZW5cIiAvKiBPcGVuICovICkge1xuICAgICAgICAgICAgc2V0U3Vic2NyaXB0aW9uU3RhdHVzKFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXR1c1JlZi5jdXJyZW50ID0gXCJVbnJlYWR5XCIgLyogVW5yZWFkeSAqLyA7XG4gICAgICAgICAgICBpZiAoIWlzT2ZmbGluZUNhcGFibGUoKSkge1xuICAgICAgICAgICAgICAgIHJlc2V0U3RvcmVzVG9VbmF2YWlsYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRTdG9yZUxvY2FsbHlBdmFpbGFibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTdWJzY3JpcHRpb25TdGF0dXMoXCJTdWJzY3JpYmluZ1wiIC8qIFN1YnNjcmliaW5nICovICk7XG4gICAgICAgIHN1YnNjcmlwdGlvblN0YXR1c1JlZi5jdXJyZW50ID0gXCJTdWJzY3JpYmluZ1wiIC8qIFN1YnNjcmliaW5nICovIDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgIHN1YnNjcmliZWRUb0RvY3VtZW50SWRSZWYuY3VycmVudCA9IHZvaWQgMDtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXNcbiAgICBdKTtcbiAgICAoMCwgaW1wb3J0X3JlYWN0MTIudXNlRWZmZWN0KShmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnRJZFJlZi5jdXJyZW50ID0gZG9jdW1lbnRJZDtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbklkUmVmLmN1cnJlbnQgJiYgY29ubmVjdGlvblN0YXR1c1JlZi5jdXJyZW50ID09PSBcIk9wZW5cIiAvKiBPcGVuICovICkge1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VJZDogdW5pcXVlSWQoKSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVuc3Vic2NyaWJlXCIsXG4gICAgICAgICAgICAgICAgc3ViSWQ6IHN1YnNjcmlwdGlvbklkUmVmLmN1cnJlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc2V0U3RvcmVzVG9VbmF2YWlsYWJsZSgpO1xuICAgICAgICBpZiAoIWRvY3VtZW50SWQgfHwgY29ubmVjdGlvblN0YXR1c1JlZi5jdXJyZW50ICE9PSBcIk9wZW5cIiAvKiBPcGVuICovICkge1xuICAgICAgICAgICAgc2V0U3Vic2NyaXB0aW9uU3RhdHVzKFwiVW5yZWFkeVwiIC8qIFVucmVhZHkgKi8gKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvblN0YXR1c1JlZi5jdXJyZW50ID0gXCJVbnJlYWR5XCIgLyogVW5yZWFkeSAqLyA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvblN0YXR1c1JlZi5jdXJyZW50ID09PSBcIlN1YnNjcmliaW5nXCIgLyogU3Vic2NyaWJpbmcgKi8gKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUoZG9jdW1lbnRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3Vic2NyaXB0aW9uU3RhdHVzKFwiU3Vic2NyaWJpbmdcIiAvKiBTdWJzY3JpYmluZyAqLyApO1xuICAgICAgICBzdWJzY3JpcHRpb25TdGF0dXNSZWYuY3VycmVudCA9IFwiU3Vic2NyaWJpbmdcIiAvKiBTdWJzY3JpYmluZyAqLyA7XG4gICAgfSwgW1xuICAgICAgICBkb2N1bWVudElkXG4gICAgXSk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDEyLnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25TdGF0dXMgIT09IFwiU3Vic2NyaWJpbmdcIiAvKiBTdWJzY3JpYmluZyAqLyAgfHwgc3Vic2NyaXB0aW9uSWRSZWYuY3VycmVudCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKGRvY3VtZW50SWRSZWYuY3VycmVudCk7XG4gICAgfSwgW1xuICAgICAgICBzdWJzY3JpcHRpb25TdGF0dXNcbiAgICBdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzY3JpcHRpb25TdGF0dXM6IHN1YnNjcmlwdGlvblN0YXR1cyxcbiAgICAgICAgYXZhaWxhYmlsaXR5U3RhdHVzOiBhdmFpbGFiaWxpdHlTdGF0dXMsXG4gICAgICAgIHVzZVN0b3JlOiBsb2NhbFN0b3JlLnVzZVN0b3JlLFxuICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgIHN1YnNjcmliZTogbG9jYWxTdG9yZS5zdWJzY3JpYmVcbiAgICB9O1xufTtcbnZhciBncm91cEJ5ID0gZnVuY3Rpb24obGlzdCwga2V5R2V0dGVyKSB7XG4gICAgdmFyIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGtleSA9IGtleUdldHRlcihpdGVtKTtcbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgICAgbWFwLnNldChrZXksIFtcbiAgICAgICAgICAgICAgICBpdGVtXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXA7XG59O1xuLy8gc3JjL3VzZVJlYWx0aW1lRG9jdW1lbnQudHNcbnZhciBSZWFsdGltZURvY3VtZW50U3RhdHVzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFJlYWx0aW1lRG9jdW1lbnRTdGF0dXMzKSB7XG4gICAgUmVhbHRpbWVEb2N1bWVudFN0YXR1czNbXCJVbnJlYWR5XCJdID0gXCJVbnJlYWR5XCI7XG4gICAgUmVhbHRpbWVEb2N1bWVudFN0YXR1czNbXCJSZWFkeVwiXSA9IFwiUmVhZHlcIjtcbiAgICByZXR1cm4gUmVhbHRpbWVEb2N1bWVudFN0YXR1czM7XG59KFJlYWx0aW1lRG9jdW1lbnRTdGF0dXMgfHwge30pO1xudmFyIHVzZVJlYWx0aW1lRG9jdW1lbnQgPSBmdW5jdGlvbihwYXJhbSkge1xuICAgIHZhciBjb25maWcgPSBwYXJhbS5jb25maWcsIGNvbm5lY3Rpb25TdGF0dXMgPSBwYXJhbS5jb25uZWN0aW9uU3RhdHVzLCBjb25uZWN0aW9uU3RhdHVzUmVmID0gcGFyYW0uY29ubmVjdGlvblN0YXR1c1JlZiwgdXNlQ2hhbm5lbCA9IHBhcmFtLnVzZUNoYW5uZWwsIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkLCB0aHJvdHRsZU9wdGlvbiA9IHBhcmFtLnRocm90dGxlO1xuICAgIHZhciB0aHJvdHRsZSA9ICgwLCBpbXBvcnRfcmVhY3QxMy51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldFRocm90dGxlKHRocm90dGxlT3B0aW9uKTtcbiAgICB9LCBbXG4gICAgICAgIHRocm90dGxlT3B0aW9uXG4gICAgXSk7XG4gICAgdmFyIF91c2VEb2N1bWVudENoYW5uZWwgPSB1c2VEb2N1bWVudENoYW5uZWwoe1xuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgY29ubmVjdGlvblN0YXR1c1JlZjogY29ubmVjdGlvblN0YXR1c1JlZixcbiAgICAgICAgdXNlQ2hhbm5lbDogdXNlQ2hhbm5lbCxcbiAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCxcbiAgICAgICAgdGhyb3R0bGU6IHRocm90dGxlXG4gICAgfSksIGF2YWlsYWJpbGl0eVN0YXR1cyA9IF91c2VEb2N1bWVudENoYW5uZWwuYXZhaWxhYmlsaXR5U3RhdHVzLCBzdWJzY3JpcHRpb25TdGF0dXMgPSBfdXNlRG9jdW1lbnRDaGFubmVsLnN1YnNjcmlwdGlvblN0YXR1cywgdXNlU3RvcmUgPSBfdXNlRG9jdW1lbnRDaGFubmVsLnVzZVN0b3JlLCBwYXRjaCA9IF91c2VEb2N1bWVudENoYW5uZWwucGF0Y2gsIHN1YnNjcmliZSA9IF91c2VEb2N1bWVudENoYW5uZWwuc3Vic2NyaWJlO1xuICAgIHZhciBkb2N1bWVudFN0YXR1cyA9ICgwLCBpbXBvcnRfcmVhY3QxMy51c2VNZW1vKShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGF2YWlsYWJpbGl0eVN0YXR1cyA9PT0gXCJSZWFkeVwiIC8qIFJlYWR5ICovICB8fCBhdmFpbGFiaWxpdHlTdGF0dXMgPT09IFwiUmVhZHlMb2NhbFwiIC8qIFJlYWR5TG9jYWwgKi8gIHx8IHN1YnNjcmlwdGlvblN0YXR1cyA9PSBcIlJlYWR5XCIgLyogUmVhZHkgKi8gKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJSZWFkeVwiIC8qIFJlYWR5ICovIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJVbnJlYWR5XCIgLyogVW5yZWFkeSAqLyA7XG4gICAgfSwgW1xuICAgICAgICBhdmFpbGFiaWxpdHlTdGF0dXMsXG4gICAgICAgIHN1YnNjcmlwdGlvblN0YXR1c1xuICAgIF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50U3RhdHVzOiBkb2N1bWVudFN0YXR1cyxcbiAgICAgICAgdXNlU3RvcmU6IHVzZVN0b3JlLFxuICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlXG4gICAgfTtcbn07XG4vLyBzcmMvdXNlUmVhbHRpbWUudHNcbnZhciB1c2VSZWFsdGltZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgX3VzZVJlYWx0aW1lQ29ubmVjdGlvbiA9IHVzZVJlYWx0aW1lQ29ubmVjdGlvbihvcHRpb25zKSwgY29ubmVjdGlvblN0YXR1cyA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXR1cywgY29ubmVjdGlvblN0YXR1c1JlZiA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24uY29ubmVjdGlvblN0YXR1c1JlZiwgcHJlc2VuY2VTdGF0dXMgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnByZXNlbmNlU3RhdHVzLCBjb25maWcgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLmNvbmZpZywgdXNlQ2hhbm5lbCA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24udXNlQ2hhbm5lbCwgdXNlTWUgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnVzZU1lLCB1c2VDb2xsYWJvcmF0b3JzID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi51c2VDb2xsYWJvcmF0b3JzLCB1c2VCcm9hZGNhc3RMaXN0ZW5lciA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24udXNlQnJvYWRjYXN0TGlzdGVuZXIsIHBhdGNoTWUgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnBhdGNoTWUsIHN1YnNjcmliZUNvbGxhYm9yYXRvcnMgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnN1YnNjcmliZUNvbGxhYm9yYXRvcnMsIHN1YnNjcmliZU1lID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5zdWJzY3JpYmVNZSwgYnJvYWRjYXN0ID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5icm9hZGNhc3Q7XG4gICAgdmFyIF91c2VSZWFsdGltZURvY3VtZW50ID0gdXNlUmVhbHRpbWVEb2N1bWVudCh7XG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiBjb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICBjb25uZWN0aW9uU3RhdHVzUmVmOiBjb25uZWN0aW9uU3RhdHVzUmVmLFxuICAgICAgICB1c2VDaGFubmVsOiB1c2VDaGFubmVsLFxuICAgICAgICBkb2N1bWVudElkOiBvcHRpb25zLmRvY3VtZW50SWQsXG4gICAgICAgIHRocm90dGxlOiBvcHRpb25zLnRocm90dGxlXG4gICAgfSksIGRvY3VtZW50U3RhdHVzID0gX3VzZVJlYWx0aW1lRG9jdW1lbnQuZG9jdW1lbnRTdGF0dXMsIHVzZVN0b3JlID0gX3VzZVJlYWx0aW1lRG9jdW1lbnQudXNlU3RvcmUsIHBhdGNoID0gX3VzZVJlYWx0aW1lRG9jdW1lbnQucGF0Y2gsIHN1YnNjcmliZSA9IF91c2VSZWFsdGltZURvY3VtZW50LnN1YnNjcmliZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkb2N1bWVudFN0YXR1czogZG9jdW1lbnRTdGF0dXMsXG4gICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgIHByZXNlbmNlU3RhdHVzOiBwcmVzZW5jZVN0YXR1cyxcbiAgICAgICAgdXNlU3RvcmU6IHVzZVN0b3JlLFxuICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgICAgICB1c2VDb2xsYWJvcmF0b3JzOiB1c2VDb2xsYWJvcmF0b3JzLFxuICAgICAgICBzdWJzY3JpYmVDb2xsYWJvcmF0b3JzOiBzdWJzY3JpYmVDb2xsYWJvcmF0b3JzLFxuICAgICAgICB1c2VNZTogdXNlTWUsXG4gICAgICAgIHBhdGNoTWU6IHBhdGNoTWUsXG4gICAgICAgIHN1YnNjcmliZU1lOiBzdWJzY3JpYmVNZSxcbiAgICAgICAgYnJvYWRjYXN0OiBicm9hZGNhc3QsXG4gICAgICAgIHVzZUJyb2FkY2FzdExpc3RlbmVyOiB1c2VCcm9hZGNhc3RMaXN0ZW5lclxuICAgIH07XG59O1xuLy8gc3JjL2NyZWF0ZVJlYWx0aW1lQ29udGV4dC50c3hcbnZhciBjcmVhdGVSZWFsdGltZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgUmVhbHRpbWVDb250ZXh0ID0gaW1wb3J0X3JlYWN0MTQuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuICAgIHZhciBSZWFsdGltZVByb3ZpZGVyID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW4sIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkLCBnZXRBdXRoVG9rZW4gPSBwYXJhbS5nZXRBdXRoVG9rZW4sIHB1YmxpY0F1dGhLZXkgPSBwYXJhbS5wdWJsaWNBdXRoS2V5LCBhdXRvc2F2ZSA9IHBhcmFtLmF1dG9zYXZlLCB0aHJvdHRsZSA9IHBhcmFtLnRocm90dGxlLCBfcGFja2FnZSA9IHBhcmFtLl9wYWNrYWdlO1xuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lID0gdXNlUmVhbHRpbWUoe1xuICAgICAgICAgICAgZG9jdW1lbnRJZDogZG9jdW1lbnRJZCxcbiAgICAgICAgICAgIGdldEF1dGhUb2tlbjogZ2V0QXV0aFRva2VuLFxuICAgICAgICAgICAgcHVibGljQXV0aEtleTogcHVibGljQXV0aEtleSxcbiAgICAgICAgICAgIGF1dG9zYXZlOiBhdXRvc2F2ZSxcbiAgICAgICAgICAgIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgICAgICAgICAgIF9wYWNrYWdlOiBfcGFja2FnZVxuICAgICAgICB9KSwgY29ubmVjdGlvblN0YXR1cyA9IF91c2VSZWFsdGltZS5jb25uZWN0aW9uU3RhdHVzLCBwcmVzZW5jZVN0YXR1cyA9IF91c2VSZWFsdGltZS5wcmVzZW5jZVN0YXR1cywgZG9jdW1lbnRTdGF0dXMgPSBfdXNlUmVhbHRpbWUuZG9jdW1lbnRTdGF0dXMsIHVzZVN0b3JlMiA9IF91c2VSZWFsdGltZS51c2VTdG9yZSwgcGF0Y2ggPSBfdXNlUmVhbHRpbWUucGF0Y2gsIHN1YnNjcmliZSA9IF91c2VSZWFsdGltZS5zdWJzY3JpYmUsIHVzZUNvbGxhYm9yYXRvcnMyID0gX3VzZVJlYWx0aW1lLnVzZUNvbGxhYm9yYXRvcnMsIHN1YnNjcmliZUNvbGxhYm9yYXRvcnMgPSBfdXNlUmVhbHRpbWUuc3Vic2NyaWJlQ29sbGFib3JhdG9ycywgdXNlTWUyID0gX3VzZVJlYWx0aW1lLnVzZU1lLCBwYXRjaE1lID0gX3VzZVJlYWx0aW1lLnBhdGNoTWUsIHN1YnNjcmliZU1lID0gX3VzZVJlYWx0aW1lLnN1YnNjcmliZU1lLCBicm9hZGNhc3QgPSBfdXNlUmVhbHRpbWUuYnJvYWRjYXN0LCB1c2VCcm9hZGNhc3RMaXN0ZW5lcjIgPSBfdXNlUmVhbHRpbWUudXNlQnJvYWRjYXN0TGlzdGVuZXI7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTQuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWx0aW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uU3RhdHVzOiBjb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50U3RhdHVzOiBkb2N1bWVudFN0YXR1cyxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZVN0YXR1czogcHJlc2VuY2VTdGF0dXMsXG4gICAgICAgICAgICAgICAgdXNlU3RvcmU6IHVzZVN0b3JlMixcbiAgICAgICAgICAgICAgICBwYXRjaDogcGF0Y2gsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgICAgICAgICAgICAgdXNlQ29sbGFib3JhdG9yczogdXNlQ29sbGFib3JhdG9yczIsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlQ29sbGFib3JhdG9yczogc3Vic2NyaWJlQ29sbGFib3JhdG9ycyxcbiAgICAgICAgICAgICAgICB1c2VNZTogdXNlTWUyLFxuICAgICAgICAgICAgICAgIHBhdGNoTWU6IHBhdGNoTWUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlTWU6IHN1YnNjcmliZU1lLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogYnJvYWRjYXN0LFxuICAgICAgICAgICAgICAgIHVzZUJyb2FkY2FzdExpc3RlbmVyOiB1c2VCcm9hZGNhc3RMaXN0ZW5lcjJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgY2hpbGRyZW4pO1xuICAgIH07XG4gICAgdmFyIHVzZVJlYWx0aW1lQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0X3JlYWN0MTQuZGVmYXVsdC51c2VDb250ZXh0KFJlYWx0aW1lQ29udGV4dCk7XG4gICAgfTtcbiAgICB2YXIgdXNlQ29ubmVjdGlvblN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29ubmVjdGlvblN0YXR1cyA9IHVzZVJlYWx0aW1lQ29udGV4dCgpLmNvbm5lY3Rpb25TdGF0dXM7XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdHVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uU3RhdHVzO1xuICAgIH07XG4gICAgdmFyIHVzZVByZXNlbmNlU3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmVzZW5jZVN0YXR1cyA9IHVzZVJlYWx0aW1lQ29udGV4dCgpLnByZXNlbmNlU3RhdHVzO1xuICAgICAgICBpZiAocHJlc2VuY2VTdGF0dXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXNlbmNlU3RhdHVzO1xuICAgIH07XG4gICAgdmFyIHVzZURvY3VtZW50U3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb2N1bWVudFN0YXR1cyA9IHVzZVJlYWx0aW1lQ29udGV4dCgpLmRvY3VtZW50U3RhdHVzO1xuICAgICAgICBpZiAoZG9jdW1lbnRTdGF0dXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50U3RhdHVzO1xuICAgIH07XG4gICAgdmFyIHVzZVN0b3JlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICAgICAgdmFyIF91c2VSZWFsdGltZUNvbnRleHQgPSB1c2VSZWFsdGltZUNvbnRleHQoKSwgdXNlU3RvcmUyID0gX3VzZVJlYWx0aW1lQ29udGV4dC51c2VTdG9yZTtcbiAgICAgICAgaWYgKHVzZVN0b3JlMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3IgPyB1c2VTdG9yZTIoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIDogdXNlU3RvcmUyKCk7XG4gICAgfTtcbiAgICB2YXIgdXNlUGF0Y2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGNoID0gdXNlUmVhbHRpbWVDb250ZXh0KCkucGF0Y2g7XG4gICAgICAgIGlmIChwYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2g7XG4gICAgfTtcbiAgICB2YXIgdXNlU3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmUgPSB1c2VSZWFsdGltZUNvbnRleHQoKS5zdWJzY3JpYmU7XG4gICAgICAgIGlmIChzdWJzY3JpYmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZTtcbiAgICB9O1xuICAgIHZhciB1c2VDb2xsYWJvcmF0b3JzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4pIHtcbiAgICAgICAgdmFyIF91c2VSZWFsdGltZUNvbnRleHQgPSB1c2VSZWFsdGltZUNvbnRleHQoKSwgdXNlQ29sbGFib3JhdG9yczIgPSBfdXNlUmVhbHRpbWVDb250ZXh0LnVzZUNvbGxhYm9yYXRvcnM7XG4gICAgICAgIGlmICh1c2VDb2xsYWJvcmF0b3JzMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3IgPyB1c2VDb2xsYWJvcmF0b3JzMihzZWxlY3RvciwgZXF1YWxpdHlGbikgOiB1c2VDb2xsYWJvcmF0b3JzMigpO1xuICAgIH07XG4gICAgdmFyIHVzZVN1YnNjcmliZUNvbGxhYm9yYXRvcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN1YnNjcmliZUNvbGxhYm9yYXRvcnMgPSB1c2VSZWFsdGltZUNvbnRleHQoKS5zdWJzY3JpYmVDb2xsYWJvcmF0b3JzO1xuICAgICAgICBpZiAoc3Vic2NyaWJlQ29sbGFib3JhdG9ycyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlQ29sbGFib3JhdG9ycztcbiAgICB9O1xuICAgIHZhciB1c2VNZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgICAgIHZhciBfdXNlUmVhbHRpbWVDb250ZXh0ID0gdXNlUmVhbHRpbWVDb250ZXh0KCksIHVzZU1lMiA9IF91c2VSZWFsdGltZUNvbnRleHQudXNlTWU7XG4gICAgICAgIGlmICh1c2VNZTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yID8gdXNlTWUyKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA6IHVzZU1lMigpO1xuICAgIH07XG4gICAgdmFyIHVzZVBhdGNoTWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhdGNoTWUgPSB1c2VSZWFsdGltZUNvbnRleHQoKS5wYXRjaE1lO1xuICAgICAgICBpZiAocGF0Y2hNZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hNZTtcbiAgICB9O1xuICAgIHZhciB1c2VTdWJzY3JpYmVNZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlTWUgPSB1c2VSZWFsdGltZUNvbnRleHQoKS5zdWJzY3JpYmVNZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZU1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzY3JpYmVNZTtcbiAgICB9O1xuICAgIHZhciB1c2VCcm9hZGNhc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJyb2FkY2FzdCA9IHVzZVJlYWx0aW1lQ29udGV4dCgpLmJyb2FkY2FzdDtcbiAgICAgICAgaWYgKGJyb2FkY2FzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnJvYWRjYXN0O1xuICAgIH07XG4gICAgdmFyIHVzZUJyb2FkY2FzdExpc3RlbmVyID0gZnVuY3Rpb24ob25FdmVudCkge1xuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lQ29udGV4dCA9IHVzZVJlYWx0aW1lQ29udGV4dCgpLCB1c2VCcm9hZGNhc3RMaXN0ZW5lcjIgPSBfdXNlUmVhbHRpbWVDb250ZXh0LnVzZUJyb2FkY2FzdExpc3RlbmVyO1xuICAgICAgICBpZiAodXNlQnJvYWRjYXN0TGlzdGVuZXIyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VCcm9hZGNhc3RMaXN0ZW5lcjIob25FdmVudCk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBSZWFsdGltZVByb3ZpZGVyOiBSZWFsdGltZVByb3ZpZGVyLFxuICAgICAgICB1c2VSZWFsdGltZUNvbnRleHQ6IHVzZVJlYWx0aW1lQ29udGV4dCxcbiAgICAgICAgdXNlQ29ubmVjdGlvblN0YXR1czogdXNlQ29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgdXNlUHJlc2VuY2VTdGF0dXM6IHVzZVByZXNlbmNlU3RhdHVzLFxuICAgICAgICB1c2VEb2N1bWVudFN0YXR1czogdXNlRG9jdW1lbnRTdGF0dXMsXG4gICAgICAgIHVzZVN0b3JlOiB1c2VTdG9yZSxcbiAgICAgICAgdXNlUGF0Y2g6IHVzZVBhdGNoLFxuICAgICAgICB1c2VTdWJzY3JpYmU6IHVzZVN1YnNjcmliZSxcbiAgICAgICAgdXNlQ29sbGFib3JhdG9yczogdXNlQ29sbGFib3JhdG9ycyxcbiAgICAgICAgdXNlU3Vic2NyaWJlQ29sbGFib3JhdG9yczogdXNlU3Vic2NyaWJlQ29sbGFib3JhdG9ycyxcbiAgICAgICAgdXNlTWU6IHVzZU1lLFxuICAgICAgICB1c2VQYXRjaE1lOiB1c2VQYXRjaE1lLFxuICAgICAgICB1c2VTdWJzY3JpYmVNZTogdXNlU3Vic2NyaWJlTWUsXG4gICAgICAgIHVzZUJyb2FkY2FzdDogdXNlQnJvYWRjYXN0LFxuICAgICAgICB1c2VCcm9hZGNhc3RMaXN0ZW5lcjogdXNlQnJvYWRjYXN0TGlzdGVuZXJcbiAgICB9O1xufTtcbi8vIHNyYy9jcmVhdGVSZWFsdGltZURvY3VtZW50Q29udGV4dC50c3hcbnZhciBpbXBvcnRfcmVhY3QxNSA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBjcmVhdGVSZWFsdGltZURvY3VtZW50Q29udGV4dCA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgdmFyIHVzZVJlYWx0aW1lR3JvdXBDb250ZXh0ID0gcGFyYW0udXNlUmVhbHRpbWVHcm91cENvbnRleHQ7XG4gICAgdmFyIFJlYWx0aW1lRG9jdW1lbnRDb250ZXh0ID0gaW1wb3J0X3JlYWN0MTUuZGVmYXVsdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuICAgIHZhciBSZWFsdGltZURvY3VtZW50UHJvdmlkZXIgPSBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJhbS5jaGlsZHJlbiwgZG9jdW1lbnRJZCA9IHBhcmFtLmRvY3VtZW50SWQ7XG4gICAgICAgIHZhciBfdXNlUmVhbHRpbWVHcm91cENvbnRleHQgPSB1c2VSZWFsdGltZUdyb3VwQ29udGV4dCgpLCBjb25uZWN0aW9uU3RhdHVzID0gX3VzZVJlYWx0aW1lR3JvdXBDb250ZXh0LmNvbm5lY3Rpb25TdGF0dXMsIF9wYWNrYWdlID0gX3VzZVJlYWx0aW1lR3JvdXBDb250ZXh0Ll9wYWNrYWdlO1xuICAgICAgICBpZiAoX3BhY2thZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lR3JvdXBQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lRG9jdW1lbnQgPSB1c2VSZWFsdGltZURvY3VtZW50KF9vYmplY3Rfc3ByZWFkKHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkXG4gICAgICAgIH0sIF9wYWNrYWdlKSksIGRvY3VtZW50U3RhdHVzID0gX3VzZVJlYWx0aW1lRG9jdW1lbnQuZG9jdW1lbnRTdGF0dXMsIHVzZVN0b3JlMiA9IF91c2VSZWFsdGltZURvY3VtZW50LnVzZVN0b3JlLCBwYXRjaCA9IF91c2VSZWFsdGltZURvY3VtZW50LnBhdGNoLCBzdWJzY3JpYmUgPSBfdXNlUmVhbHRpbWVEb2N1bWVudC5zdWJzY3JpYmU7XG4gICAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gaW1wb3J0X3JlYWN0MTUuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWx0aW1lRG9jdW1lbnRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50U3RhdHVzOiBkb2N1bWVudFN0YXR1cyxcbiAgICAgICAgICAgICAgICB1c2VTdG9yZTogdXNlU3RvcmUyLFxuICAgICAgICAgICAgICAgIHBhdGNoOiBwYXRjaCxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmU6IHN1YnNjcmliZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjaGlsZHJlbik7XG4gICAgfTtcbiAgICB2YXIgdXNlUmVhbHRpbWVEb2N1bWVudENvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGltcG9ydF9yZWFjdDE1LmRlZmF1bHQudXNlQ29udGV4dChSZWFsdGltZURvY3VtZW50Q29udGV4dCk7XG4gICAgfTtcbiAgICB2YXIgdXNlRG9jdW1lbnRTdGF0dXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRvY3VtZW50U3RhdHVzID0gdXNlUmVhbHRpbWVEb2N1bWVudENvbnRleHQoKS5kb2N1bWVudFN0YXR1cztcbiAgICAgICAgaWYgKGRvY3VtZW50U3RhdHVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudFN0YXR1cztcbiAgICB9O1xuICAgIHZhciB1c2VTdG9yZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSB7XG4gICAgICAgIHZhciBfdXNlUmVhbHRpbWVEb2N1bWVudENvbnRleHQgPSB1c2VSZWFsdGltZURvY3VtZW50Q29udGV4dCgpLCB1c2VTdG9yZTIgPSBfdXNlUmVhbHRpbWVEb2N1bWVudENvbnRleHQudXNlU3RvcmU7XG4gICAgICAgIGlmICh1c2VTdG9yZTIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yID8gdXNlU3RvcmUyKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA6IHVzZVN0b3JlMigpO1xuICAgIH07XG4gICAgdmFyIHVzZVBhdGNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRjaCA9IHVzZVJlYWx0aW1lRG9jdW1lbnRDb250ZXh0KCkucGF0Y2g7XG4gICAgICAgIGlmIChwYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2g7XG4gICAgfTtcbiAgICB2YXIgdXNlU3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdWJzY3JpYmUgPSB1c2VSZWFsdGltZURvY3VtZW50Q29udGV4dCgpLnN1YnNjcmliZTtcbiAgICAgICAgaWYgKHN1YnNjcmliZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgUmVhbHRpbWVEb2N1bWVudFByb3ZpZGVyOiBSZWFsdGltZURvY3VtZW50UHJvdmlkZXIsXG4gICAgICAgIHVzZVJlYWx0aW1lRG9jdW1lbnRDb250ZXh0OiB1c2VSZWFsdGltZURvY3VtZW50Q29udGV4dCxcbiAgICAgICAgdXNlRG9jdW1lbnRTdGF0dXM6IHVzZURvY3VtZW50U3RhdHVzLFxuICAgICAgICB1c2VTdG9yZTogdXNlU3RvcmUsXG4gICAgICAgIHVzZVBhdGNoOiB1c2VQYXRjaCxcbiAgICAgICAgdXNlU3Vic2NyaWJlOiB1c2VTdWJzY3JpYmVcbiAgICB9O1xufTtcbi8vIHNyYy9jcmVhdGVSZWFsdGltZUdyb3VwQ29udGV4dC50c3hcbnZhciBpbXBvcnRfcmVhY3QxNiA9IF9fdG9FU00ocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBjcmVhdGVSZWFsdGltZUdyb3VwQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBSZWFsdGltZUdyb3VwQ29udGV4dCA9IGltcG9ydF9yZWFjdDE2LmRlZmF1bHQuY3JlYXRlQ29udGV4dChudWxsKTtcbiAgICB2YXIgUmVhbHRpbWVHcm91cFByb3ZpZGVyID0gZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gcGFyYW0uY2hpbGRyZW4sIGdyb3VwSWQgPSBwYXJhbS5ncm91cElkLCBnZXRBdXRoVG9rZW4gPSBwYXJhbS5nZXRBdXRoVG9rZW4sIHB1YmxpY0F1dGhLZXkgPSBwYXJhbS5wdWJsaWNBdXRoS2V5LCBhdXRvc2F2ZSA9IHBhcmFtLmF1dG9zYXZlLCB0aHJvdHRsZSA9IHBhcmFtLnRocm90dGxlLCBfcGFja2FnZSA9IHBhcmFtLl9wYWNrYWdlO1xuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lQ29ubmVjdGlvbiA9IHVzZVJlYWx0aW1lQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBncm91cElkOiBncm91cElkLFxuICAgICAgICAgICAgZ2V0QXV0aFRva2VuOiBnZXRBdXRoVG9rZW4sXG4gICAgICAgICAgICBwdWJsaWNBdXRoS2V5OiBwdWJsaWNBdXRoS2V5LFxuICAgICAgICAgICAgYXV0b3NhdmU6IGF1dG9zYXZlLFxuICAgICAgICAgICAgdGhyb3R0bGU6IHRocm90dGxlLFxuICAgICAgICAgICAgX3BhY2thZ2U6IF9wYWNrYWdlXG4gICAgICAgIH0pLCBjb25uZWN0aW9uU3RhdHVzID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdHVzLCBjb25uZWN0aW9uU3RhdHVzUmVmID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5jb25uZWN0aW9uU3RhdHVzUmVmLCBwcmVzZW5jZVN0YXR1cyA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24ucHJlc2VuY2VTdGF0dXMsIHVzZUNvbGxhYm9yYXRvcnMyID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi51c2VDb2xsYWJvcmF0b3JzLCBzdWJzY3JpYmVDb2xsYWJvcmF0b3JzID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5zdWJzY3JpYmVDb2xsYWJvcmF0b3JzLCB1c2VNZTIgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnVzZU1lLCBwYXRjaE1lID0gX3VzZVJlYWx0aW1lQ29ubmVjdGlvbi5wYXRjaE1lLCBzdWJzY3JpYmVNZSA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24uc3Vic2NyaWJlTWUsIGJyb2FkY2FzdCA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24uYnJvYWRjYXN0LCB1c2VCcm9hZGNhc3RMaXN0ZW5lcjIgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLnVzZUJyb2FkY2FzdExpc3RlbmVyLCBjb25maWcgPSBfdXNlUmVhbHRpbWVDb25uZWN0aW9uLmNvbmZpZywgdXNlQ2hhbm5lbCA9IF91c2VSZWFsdGltZUNvbm5lY3Rpb24udXNlQ2hhbm5lbDtcbiAgICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBpbXBvcnRfcmVhY3QxNi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoUmVhbHRpbWVHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXR1czogY29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZVN0YXR1czogcHJlc2VuY2VTdGF0dXMsXG4gICAgICAgICAgICAgICAgdXNlQ29sbGFib3JhdG9yczogdXNlQ29sbGFib3JhdG9yczIsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlQ29sbGFib3JhdG9yczogc3Vic2NyaWJlQ29sbGFib3JhdG9ycyxcbiAgICAgICAgICAgICAgICB1c2VNZTogdXNlTWUyLFxuICAgICAgICAgICAgICAgIHBhdGNoTWU6IHBhdGNoTWUsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlTWU6IHN1YnNjcmliZU1lLFxuICAgICAgICAgICAgICAgIGJyb2FkY2FzdDogYnJvYWRjYXN0LFxuICAgICAgICAgICAgICAgIHVzZUJyb2FkY2FzdExpc3RlbmVyOiB1c2VCcm9hZGNhc3RMaXN0ZW5lcjIsXG4gICAgICAgICAgICAgICAgX3BhY2thZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHVzZUNoYW5uZWw6IHVzZUNoYW5uZWwsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXNSZWY6IGNvbm5lY3Rpb25TdGF0dXNSZWZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNoaWxkcmVuKTtcbiAgICB9O1xuICAgIHZhciB1c2VSZWFsdGltZUdyb3VwQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1wb3J0X3JlYWN0MTYuZGVmYXVsdC51c2VDb250ZXh0KFJlYWx0aW1lR3JvdXBDb250ZXh0KTtcbiAgICB9O1xuICAgIHZhciB1c2VDb25uZWN0aW9uU3RhdHVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uU3RhdHVzID0gdXNlUmVhbHRpbWVHcm91cENvbnRleHQoKS5jb25uZWN0aW9uU3RhdHVzO1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXR1cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvblN0YXR1cztcbiAgICB9O1xuICAgIHZhciB1c2VQcmVzZW5jZVN0YXR1cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJlc2VuY2VTdGF0dXMgPSB1c2VSZWFsdGltZUdyb3VwQ29udGV4dCgpLnByZXNlbmNlU3RhdHVzO1xuICAgICAgICBpZiAocHJlc2VuY2VTdGF0dXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXNlbmNlU3RhdHVzO1xuICAgIH07XG4gICAgdmFyIHVzZUNvbGxhYm9yYXRvcnMgPSBmdW5jdGlvbihzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lR3JvdXBDb250ZXh0ID0gdXNlUmVhbHRpbWVHcm91cENvbnRleHQoKSwgdXNlQ29sbGFib3JhdG9yczIgPSBfdXNlUmVhbHRpbWVHcm91cENvbnRleHQudXNlQ29sbGFib3JhdG9ycztcbiAgICAgICAgaWYgKHVzZUNvbGxhYm9yYXRvcnMyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RvciA/IHVzZUNvbGxhYm9yYXRvcnMyKHNlbGVjdG9yLCBlcXVhbGl0eUZuKSA6IHVzZUNvbGxhYm9yYXRvcnMyKCk7XG4gICAgfTtcbiAgICB2YXIgdXNlU3Vic2NyaWJlQ29sbGFib3JhdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlQ29sbGFib3JhdG9ycyA9IHVzZVJlYWx0aW1lR3JvdXBDb250ZXh0KCkuc3Vic2NyaWJlQ29sbGFib3JhdG9ycztcbiAgICAgICAgaWYgKHN1YnNjcmliZUNvbGxhYm9yYXRvcnMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZUNvbGxhYm9yYXRvcnM7XG4gICAgfTtcbiAgICB2YXIgdXNlTWUgPSBmdW5jdGlvbihzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgICAgICB2YXIgX3VzZVJlYWx0aW1lR3JvdXBDb250ZXh0ID0gdXNlUmVhbHRpbWVHcm91cENvbnRleHQoKSwgdXNlTWUyID0gX3VzZVJlYWx0aW1lR3JvdXBDb250ZXh0LnVzZU1lO1xuICAgICAgICBpZiAodXNlTWUyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBSZWFsdGltZVByb3ZpZGVyIHByb3ZpZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxlY3RvciA/IHVzZU1lMihzZWxlY3RvciwgZXF1YWxpdHlGbikgOiB1c2VNZTIoKTtcbiAgICB9O1xuICAgIHZhciB1c2VQYXRjaE1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXRjaE1lID0gdXNlUmVhbHRpbWVHcm91cENvbnRleHQoKS5wYXRjaE1lO1xuICAgICAgICBpZiAocGF0Y2hNZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0Y2hNZTtcbiAgICB9O1xuICAgIHZhciB1c2VTdWJzY3JpYmVNZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlTWUgPSB1c2VSZWFsdGltZUdyb3VwQ29udGV4dCgpLnN1YnNjcmliZU1lO1xuICAgICAgICBpZiAoc3Vic2NyaWJlTWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNjcmliZU1lO1xuICAgIH07XG4gICAgdmFyIHVzZUJyb2FkY2FzdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYnJvYWRjYXN0ID0gdXNlUmVhbHRpbWVHcm91cENvbnRleHQoKS5icm9hZGNhc3Q7XG4gICAgICAgIGlmIChicm9hZGNhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFJlYWx0aW1lUHJvdmlkZXIgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJyb2FkY2FzdDtcbiAgICB9O1xuICAgIHZhciB1c2VCcm9hZGNhc3RMaXN0ZW5lciA9IGZ1bmN0aW9uKG9uRXZlbnQpIHtcbiAgICAgICAgdmFyIF91c2VSZWFsdGltZUdyb3VwQ29udGV4dCA9IHVzZVJlYWx0aW1lR3JvdXBDb250ZXh0KCksIHVzZUJyb2FkY2FzdExpc3RlbmVyMiA9IF91c2VSZWFsdGltZUdyb3VwQ29udGV4dC51c2VCcm9hZGNhc3RMaXN0ZW5lcjtcbiAgICAgICAgaWYgKHVzZUJyb2FkY2FzdExpc3RlbmVyMiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gUmVhbHRpbWVQcm92aWRlciBwcm92aWRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlQnJvYWRjYXN0TGlzdGVuZXIyKG9uRXZlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgUmVhbHRpbWVHcm91cFByb3ZpZGVyOiBSZWFsdGltZUdyb3VwUHJvdmlkZXIsXG4gICAgICAgIHVzZVJlYWx0aW1lR3JvdXBDb250ZXh0OiB1c2VSZWFsdGltZUdyb3VwQ29udGV4dCxcbiAgICAgICAgdXNlQ29ubmVjdGlvblN0YXR1czogdXNlQ29ubmVjdGlvblN0YXR1cyxcbiAgICAgICAgdXNlUHJlc2VuY2VTdGF0dXM6IHVzZVByZXNlbmNlU3RhdHVzLFxuICAgICAgICB1c2VDb2xsYWJvcmF0b3JzOiB1c2VDb2xsYWJvcmF0b3JzLFxuICAgICAgICB1c2VTdWJzY3JpYmVDb2xsYWJvcmF0b3JzOiB1c2VTdWJzY3JpYmVDb2xsYWJvcmF0b3JzLFxuICAgICAgICB1c2VNZTogdXNlTWUsXG4gICAgICAgIHVzZVBhdGNoTWU6IHVzZVBhdGNoTWUsXG4gICAgICAgIHVzZVN1YnNjcmliZU1lOiB1c2VTdWJzY3JpYmVNZSxcbiAgICAgICAgdXNlQnJvYWRjYXN0OiB1c2VCcm9hZGNhc3QsXG4gICAgICAgIHVzZUJyb2FkY2FzdExpc3RlbmVyOiB1c2VCcm9hZGNhc3RMaXN0ZW5lclxuICAgIH07XG59O1xuLy8gc3JjL3VzZUF1dG9zYXZlLnRzXG52YXIgaW1wb3J0X3JlYWN0MTcgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgdXNlQXV0b3NhdmUgPSBmdW5jdGlvbihwcm9wcykge1xuICAgIHZhciBjb25maWcgPSAoMCwgaW1wb3J0X3JlYWN0MTcudXNlTWVtbykoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRBdXRvc2F2ZUNvbmZpZyh7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgc3RvcmVOYW1lUG9zdGZpeDogcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLnN0b3JlTmFtZVBvc3RmaXgsXG4gICAgICAgICAgICBkaXNhYmxlV2FybmluZzogcHJvcHMgPT09IG51bGwgfHwgcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb3BzLmRpc2FibGVXYXJuaW5nXG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICB2YXIgYXV0b3NhdmVEYXRhYmFzZVJlZiA9ICgwLCBpbXBvcnRfcmVhY3QxNy51c2VSZWYpKCk7XG4gICAgKDAsIGltcG9ydF9yZWFjdDE3LnVzZUVmZmVjdCkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhdXRvc2F2ZURhdGFiYXNlID0gZ2V0SW5kZXhlZEF1dG9zYXZlSW5zdGFuY2Uoe1xuICAgICAgICAgICAgc3RvcmVOYW1lUG9zdGZpeDogY29uZmlnLnN0b3JlTmFtZVBvc3RmaXgsXG4gICAgICAgICAgICBkaXNhYmxlV2FybmluZzogY29uZmlnLmRpc2FibGVXYXJuaW5nXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBlbmFibGVkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvc2F2ZURhdGFiYXNlLmNvbm5lY3QoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9zYXZlRGF0YWJhc2VSZWYuY3VycmVudCA9IGF1dG9zYXZlRGF0YWJhc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKTtcbiAgICAgICAgY29ubmVjdCgpLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF1dG9zYXZlRGF0YWJhc2UuZGlzY29ubmVjdCgpLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIGNyZWF0ZU5ld0RvY3VtZW50ID0gKDAsIGltcG9ydF9yZWFjdDE3LnVzZUNhbGxiYWNrKShmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgZG9jdW1lbnRJZCwgZG9jdW1lbnQsIGRvY3VtZW50TWV0YWRhdGEsIGZyYWdtZW50O1xuICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQgPSBwYXJhbS5kb2N1bWVudElkLCBkb2N1bWVudCA9IHBhcmFtLmRvY3VtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRvc2F2ZURhdGFiYXNlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBdXRvc2F2ZSBkYXRhYmFzZSBub3QgaW5pdGlhbGl6ZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1ldGFkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsT25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNhdmVkQ2hhbmdlczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gZG9jdW1lbnRUb0ZyYWdtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvc2F2ZURhdGFiYXNlUmVmLmN1cnJlbnQuc2F2ZURvY3VtZW50TWV0YWRhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudElkOiBkb2N1bWVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1ldGFkYXRhOiBkb2N1bWVudE1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b3NhdmVEYXRhYmFzZVJlZi5jdXJyZW50LnNhdmVGcmFnbWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IGRvY3VtZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50OiBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHtcbiAgICAgICAgICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfSgpLCBbXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JlYXRlTmV3RG9jdW1lbnQ6IGNyZWF0ZU5ld0RvY3VtZW50XG4gICAgfTtcbn07XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBSZWFsdGltZUNvbm5lY3Rpb25TdGF0dXM6IFJlYWx0aW1lQ29ubmVjdGlvblN0YXR1cyxcbiAgICBSZWFsdGltZURvY3VtZW50U3RhdHVzOiBSZWFsdGltZURvY3VtZW50U3RhdHVzLFxuICAgIFJlYWx0aW1lUHJlc2VuY2VTdGF0dXM6IFJlYWx0aW1lUHJlc2VuY2VTdGF0dXMsXG4gICAgY3JlYXRlUmVhbHRpbWVDb250ZXh0OiBjcmVhdGVSZWFsdGltZUNvbnRleHQsXG4gICAgY3JlYXRlUmVhbHRpbWVEb2N1bWVudENvbnRleHQ6IGNyZWF0ZVJlYWx0aW1lRG9jdW1lbnRDb250ZXh0LFxuICAgIGNyZWF0ZVJlYWx0aW1lR3JvdXBDb250ZXh0OiBjcmVhdGVSZWFsdGltZUdyb3VwQ29udGV4dCxcbiAgICB1c2VBdXRvc2F2ZTogdXNlQXV0b3NhdmUsXG4gICAgdXNlUmVhbHRpbWU6IHVzZVJlYWx0aW1lXG59KTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@inrealtime/react/dist/index.js\n"));

/***/ }),

/***/ "../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": function() { return /* binding */ create; },\n/* harmony export */   \"default\": function() { return /* binding */ react; },\n/* harmony export */   \"useStore\": function() { return /* binding */ useStore; }\n/* harmony export */ });\n/* harmony import */ var zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zustand/vanilla */ \"../../node_modules/@inrealtime/react/node_modules/zustand/esm/vanilla.mjs\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"create\",\"useStore\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-sync-external-store/shim/with-selector.js */ \"../../node_modules/use-sync-external-store/shim/with-selector.js\");\n/* harmony import */ var use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n\nconst { useSyncExternalStoreWithSelector } = (use_sync_external_store_shim_with_selector_js__WEBPACK_IMPORTED_MODULE_2___default());\nfunction useStore(api, selector = api.getState, equalityFn) {\n  const slice = useSyncExternalStoreWithSelector(\n    api.subscribe,\n    api.getState,\n    api.getServerState || api.getState,\n    selector,\n    equalityFn\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useDebugValue)(slice);\n  return slice;\n}\nconst createImpl = (createState) => {\n  if ( true && typeof createState !== \"function\") {\n    console.warn(\n      \"[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.\"\n    );\n  }\n  const api = typeof createState === \"function\" ? (0,zustand_vanilla__WEBPACK_IMPORTED_MODULE_0__.createStore)(createState) : createState;\n  const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);\n  Object.assign(useBoundStore, api);\n  return useBoundStore;\n};\nconst create = (createState) => createState ? createImpl(createState) : createImpl;\nvar react = (createState) => {\n  if (true) {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`.\"\n    );\n  }\n  return create(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BpbnJlYWx0aW1lL3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNkO0FBQ007QUFDa0Q7O0FBRXhGLFFBQVEsbUNBQW1DLEVBQUUsc0ZBQTJCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLG9EQUFhO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBLDJHQUEyRyxXQUFXO0FBQ3RIO0FBQ0E7QUFDQSxrREFBa0QsNERBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBLHdFQUF3RSxTQUFTO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBOztBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL0BpbnJlYWx0aW1lL3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcz9hNDM3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVN0b3JlIH0gZnJvbSAnenVzdGFuZC92YW5pbGxhJztcbmV4cG9ydCAqIGZyb20gJ3p1c3RhbmQvdmFuaWxsYSc7XG5pbXBvcnQgeyB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlRXhwb3J0cyBmcm9tICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZS9zaGltL3dpdGgtc2VsZWN0b3IuanMnO1xuXG5jb25zdCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yIH0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZUV4cG9ydHM7XG5mdW5jdGlvbiB1c2VTdG9yZShhcGksIHNlbGVjdG9yID0gYXBpLmdldFN0YXRlLCBlcXVhbGl0eUZuKSB7XG4gIGNvbnN0IHNsaWNlID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoXG4gICAgYXBpLnN1YnNjcmliZSxcbiAgICBhcGkuZ2V0U3RhdGUsXG4gICAgYXBpLmdldFNlcnZlclN0YXRlIHx8IGFwaS5nZXRTdGF0ZSxcbiAgICBzZWxlY3RvcixcbiAgICBlcXVhbGl0eUZuXG4gICk7XG4gIHVzZURlYnVnVmFsdWUoc2xpY2UpO1xuICByZXR1cm4gc2xpY2U7XG59XG5jb25zdCBjcmVhdGVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdHlwZW9mIGNyZWF0ZVN0YXRlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBQYXNzaW5nIGEgdmFuaWxsYSBzdG9yZSB3aWxsIGJlIHVuc3VwcG9ydGVkIGluIGEgZnV0dXJlIHZlcnNpb24uIEluc3RlYWQgdXNlIGBpbXBvcnQgeyB1c2VTdG9yZSB9IGZyb20gJ3p1c3RhbmQnYC5cIlxuICAgICk7XG4gIH1cbiAgY29uc3QgYXBpID0gdHlwZW9mIGNyZWF0ZVN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSkgOiBjcmVhdGVTdGF0ZTtcbiAgY29uc3QgdXNlQm91bmRTdG9yZSA9IChzZWxlY3RvciwgZXF1YWxpdHlGbikgPT4gdXNlU3RvcmUoYXBpLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG4gIE9iamVjdC5hc3NpZ24odXNlQm91bmRTdG9yZSwgYXBpKTtcbiAgcmV0dXJuIHVzZUJvdW5kU3RvcmU7XG59O1xuY29uc3QgY3JlYXRlID0gKGNyZWF0ZVN0YXRlKSA9PiBjcmVhdGVTdGF0ZSA/IGNyZWF0ZUltcGwoY3JlYXRlU3RhdGUpIDogY3JlYXRlSW1wbDtcbnZhciByZWFjdCA9IChjcmVhdGVTdGF0ZSkgPT4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJbREVQUkVDQVRFRF0gRGVmYXVsdCBleHBvcnQgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCB1c2UgYGltcG9ydCB7IGNyZWF0ZSB9IGZyb20gJ3p1c3RhbmQnYC5cIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZShjcmVhdGVTdGF0ZSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGUsIHJlYWN0IGFzIGRlZmF1bHQsIHVzZVN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@inrealtime/react/node_modules/zustand/esm/index.js\n"));

/***/ }),

/***/ "../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"combine\": function() { return /* binding */ combine; },\n/* harmony export */   \"createJSONStorage\": function() { return /* binding */ createJSONStorage; },\n/* harmony export */   \"devtools\": function() { return /* binding */ devtools; },\n/* harmony export */   \"persist\": function() { return /* binding */ persist; },\n/* harmony export */   \"redux\": function() { return /* binding */ redux; },\n/* harmony export */   \"subscribeWithSelector\": function() { return /* binding */ subscribeWithSelector; }\n/* harmony export */ });\nconst reduxImpl = (reducer, initial) => (set, _get, api) => {\n  api.dispatch = (action) => {\n    set((state) => reducer(state, action), false, action);\n    return action;\n  };\n  api.dispatchFromDevtools = true;\n  return { dispatch: (...a) => api.dispatch(...a), ...initial };\n};\nconst redux = reduxImpl;\n\nconst trackedConnections = /* @__PURE__ */ new Map();\nconst getTrackedConnectionState = (name) => {\n  const api = trackedConnections.get(name);\n  if (!api)\n    return {};\n  return Object.fromEntries(\n    Object.entries(api.stores).map(([key, api2]) => [key, api2.getState()])\n  );\n};\nconst extractConnectionInformation = (store, extensionConnector, options) => {\n  if (store === void 0) {\n    return {\n      type: \"untracked\",\n      connection: extensionConnector.connect(options)\n    };\n  }\n  const existingConnection = trackedConnections.get(options.name);\n  if (existingConnection) {\n    return { type: \"tracked\", store, ...existingConnection };\n  }\n  const newConnection = {\n    connection: extensionConnector.connect(options),\n    stores: {}\n  };\n  trackedConnections.set(options.name, newConnection);\n  return { type: \"tracked\", store, ...newConnection };\n};\nconst devtoolsImpl = (fn, devtoolsOptions = {}) => (set, get, api) => {\n  const { enabled, anonymousActionType, store, ...options } = devtoolsOptions;\n  let extensionConnector;\n  try {\n    extensionConnector = (enabled != null ? enabled : \"development\" !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (e) {\n  }\n  if (!extensionConnector) {\n    if ( true && enabled) {\n      console.warn(\n        \"[zustand devtools middleware] Please install/enable Redux devtools extension\"\n      );\n    }\n    return fn(set, get, api);\n  }\n  const { connection, ...connectionInformation } = extractConnectionInformation(store, extensionConnector, options);\n  let isRecording = true;\n  api.setState = (state, replace, nameOrAction) => {\n    const r = set(state, replace);\n    if (!isRecording)\n      return r;\n    const action = nameOrAction === void 0 ? { type: anonymousActionType || \"anonymous\" } : typeof nameOrAction === \"string\" ? { type: nameOrAction } : nameOrAction;\n    if (store === void 0) {\n      connection == null ? void 0 : connection.send(action, get());\n      return r;\n    }\n    connection == null ? void 0 : connection.send(\n      {\n        ...action,\n        type: `${store}/${action.type}`\n      },\n      {\n        ...getTrackedConnectionState(options.name),\n        [store]: api.getState()\n      }\n    );\n    return r;\n  };\n  const setStateFromDevtools = (...a) => {\n    const originalIsRecording = isRecording;\n    isRecording = false;\n    set(...a);\n    isRecording = originalIsRecording;\n  };\n  const initialState = fn(api.setState, get, api);\n  if (connectionInformation.type === \"untracked\") {\n    connection == null ? void 0 : connection.init(initialState);\n  } else {\n    connectionInformation.stores[connectionInformation.store] = api;\n    connection == null ? void 0 : connection.init(\n      Object.fromEntries(\n        Object.entries(connectionInformation.stores).map(([key, store2]) => [\n          key,\n          key === connectionInformation.store ? initialState : store2.getState()\n        ])\n      )\n    );\n  }\n  if (api.dispatchFromDevtools && typeof api.dispatch === \"function\") {\n    let didWarnAboutReservedActionType = false;\n    const originalDispatch = api.dispatch;\n    api.dispatch = (...a) => {\n      if ( true && a[0].type === \"__setState\" && !didWarnAboutReservedActionType) {\n        console.warn(\n          '[zustand devtools middleware] \"__setState\" action type is reserved to set state from the devtools. Avoid using it.'\n        );\n        didWarnAboutReservedActionType = true;\n      }\n      originalDispatch(...a);\n    };\n  }\n  connection.subscribe((message) => {\n    var _a;\n    switch (message.type) {\n      case \"ACTION\":\n        if (typeof message.payload !== \"string\") {\n          console.error(\n            \"[zustand devtools middleware] Unsupported action format\"\n          );\n          return;\n        }\n        return parseJsonThen(\n          message.payload,\n          (action) => {\n            if (action.type === \"__setState\") {\n              if (store === void 0) {\n                setStateFromDevtools(action.state);\n                return;\n              }\n              if (Object.keys(action.state).length !== 1) {\n                console.error(\n                  `\n                    [zustand devtools middleware] Unsupported __setState action format. \n                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),\n                    and value of this only key should be a state object. Example: { \"type\": \"__setState\", \"state\": { \"abc123Store\": { \"foo\": \"bar\" } } }\n                    `\n                );\n              }\n              const stateFromDevtools = action.state[store];\n              if (stateFromDevtools === void 0 || stateFromDevtools === null) {\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(stateFromDevtools)) {\n                setStateFromDevtools(stateFromDevtools);\n              }\n              return;\n            }\n            if (!api.dispatchFromDevtools)\n              return;\n            if (typeof api.dispatch !== \"function\")\n              return;\n            api.dispatch(action);\n          }\n        );\n      case \"DISPATCH\":\n        switch (message.payload.type) {\n          case \"RESET\":\n            setStateFromDevtools(initialState);\n            if (store === void 0) {\n              return connection == null ? void 0 : connection.init(api.getState());\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"COMMIT\":\n            if (store === void 0) {\n              connection == null ? void 0 : connection.init(api.getState());\n              return;\n            }\n            return connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n          case \"ROLLBACK\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                connection == null ? void 0 : connection.init(api.getState());\n                return;\n              }\n              setStateFromDevtools(state[store]);\n              connection == null ? void 0 : connection.init(getTrackedConnectionState(options.name));\n            });\n          case \"JUMP_TO_STATE\":\n          case \"JUMP_TO_ACTION\":\n            return parseJsonThen(message.state, (state) => {\n              if (store === void 0) {\n                setStateFromDevtools(state);\n                return;\n              }\n              if (JSON.stringify(api.getState()) !== JSON.stringify(state[store])) {\n                setStateFromDevtools(state[store]);\n              }\n            });\n          case \"IMPORT_STATE\": {\n            const { nextLiftedState } = message.payload;\n            const lastComputedState = (_a = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a.state;\n            if (!lastComputedState)\n              return;\n            if (store === void 0) {\n              setStateFromDevtools(lastComputedState);\n            } else {\n              setStateFromDevtools(lastComputedState[store]);\n            }\n            connection == null ? void 0 : connection.send(\n              null,\n              // FIXME no-any\n              nextLiftedState\n            );\n            return;\n          }\n          case \"PAUSE_RECORDING\":\n            return isRecording = !isRecording;\n        }\n        return;\n    }\n  });\n  return initialState;\n};\nconst devtools = devtoolsImpl;\nconst parseJsonThen = (stringified, f) => {\n  let parsed;\n  try {\n    parsed = JSON.parse(stringified);\n  } catch (e) {\n    console.error(\n      \"[zustand devtools middleware] Could not parse the received json\",\n      e\n    );\n  }\n  if (parsed !== void 0)\n    f(parsed);\n};\n\nconst subscribeWithSelectorImpl = (fn) => (set, get, api) => {\n  const origSubscribe = api.subscribe;\n  api.subscribe = (selector, optListener, options) => {\n    let listener = selector;\n    if (optListener) {\n      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;\n      let currentSlice = selector(api.getState());\n      listener = (state) => {\n        const nextSlice = selector(state);\n        if (!equalityFn(currentSlice, nextSlice)) {\n          const previousSlice = currentSlice;\n          optListener(currentSlice = nextSlice, previousSlice);\n        }\n      };\n      if (options == null ? void 0 : options.fireImmediately) {\n        optListener(currentSlice, currentSlice);\n      }\n    }\n    return origSubscribe(listener);\n  };\n  const initialState = fn(set, get, api);\n  return initialState;\n};\nconst subscribeWithSelector = subscribeWithSelectorImpl;\n\nconst combine = (initialState, create) => (...a) => Object.assign({}, initialState, create(...a));\n\nfunction createJSONStorage(getStorage, options) {\n  let storage;\n  try {\n    storage = getStorage();\n  } catch (e) {\n    return;\n  }\n  const persistStorage = {\n    getItem: (name) => {\n      var _a;\n      const parse = (str2) => {\n        if (str2 === null) {\n          return null;\n        }\n        return JSON.parse(str2, options == null ? void 0 : options.reviver);\n      };\n      const str = (_a = storage.getItem(name)) != null ? _a : null;\n      if (str instanceof Promise) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (name, newValue) => storage.setItem(\n      name,\n      JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n    ),\n    removeItem: (name) => storage.removeItem(name)\n  };\n  return persistStorage;\n}\nconst toThenable = (fn) => (input) => {\n  try {\n    const result = fn(input);\n    if (result instanceof Promise) {\n      return result;\n    }\n    return {\n      then(onFulfilled) {\n        return toThenable(onFulfilled)(result);\n      },\n      catch(_onRejected) {\n        return this;\n      }\n    };\n  } catch (e) {\n    return {\n      then(_onFulfilled) {\n        return this;\n      },\n      catch(onRejected) {\n        return toThenable(onRejected)(e);\n      }\n    };\n  }\n};\nconst oldImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    getStorage: () => localStorage,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage;\n  try {\n    storage = options.getStorage();\n  } catch (e) {\n  }\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const thenableSerialize = toThenable(options.serialize);\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    let errorInSync;\n    const thenable = thenableSerialize({ state, version: options.version }).then(\n      (serializedValue) => storage.setItem(options.name, serializedValue)\n    ).catch((e) => {\n      errorInSync = e;\n    });\n    if (errorInSync) {\n      throw errorInSync;\n    }\n    return thenable;\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => cb(get()));\n    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get())) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {\n      if (storageValue) {\n        return options.deserialize(storageValue);\n      }\n    }).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.getStorage) {\n        storage = newOptions.getStorage();\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  hydrate();\n  return stateFromStorage || configResult;\n};\nconst newImpl = (config, baseOptions) => (set, get, api) => {\n  let options = {\n    storage: createJSONStorage(() => localStorage),\n    partialize: (state) => state,\n    version: 0,\n    merge: (persistedState, currentState) => ({\n      ...currentState,\n      ...persistedState\n    }),\n    ...baseOptions\n  };\n  let hasHydrated = false;\n  const hydrationListeners = /* @__PURE__ */ new Set();\n  const finishHydrationListeners = /* @__PURE__ */ new Set();\n  let storage = options.storage;\n  if (!storage) {\n    return config(\n      (...args) => {\n        console.warn(\n          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`\n        );\n        set(...args);\n      },\n      get,\n      api\n    );\n  }\n  const setItem = () => {\n    const state = options.partialize({ ...get() });\n    return storage.setItem(options.name, {\n      state,\n      version: options.version\n    });\n  };\n  const savedSetState = api.setState;\n  api.setState = (state, replace) => {\n    savedSetState(state, replace);\n    void setItem();\n  };\n  const configResult = config(\n    (...args) => {\n      set(...args);\n      void setItem();\n    },\n    get,\n    api\n  );\n  let stateFromStorage;\n  const hydrate = () => {\n    var _a, _b;\n    if (!storage)\n      return;\n    hasHydrated = false;\n    hydrationListeners.forEach((cb) => {\n      var _a2;\n      return cb((_a2 = get()) != null ? _a2 : configResult);\n    });\n    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a = get()) != null ? _a : configResult)) || void 0;\n    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {\n      if (deserializedStorageValue) {\n        if (typeof deserializedStorageValue.version === \"number\" && deserializedStorageValue.version !== options.version) {\n          if (options.migrate) {\n            return options.migrate(\n              deserializedStorageValue.state,\n              deserializedStorageValue.version\n            );\n          }\n          console.error(\n            `State loaded from storage couldn't be migrated since no migrate function was provided`\n          );\n        } else {\n          return deserializedStorageValue.state;\n        }\n      }\n    }).then((migratedState) => {\n      var _a2;\n      stateFromStorage = options.merge(\n        migratedState,\n        (_a2 = get()) != null ? _a2 : configResult\n      );\n      set(stateFromStorage, true);\n      return setItem();\n    }).then(() => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);\n      stateFromStorage = get();\n      hasHydrated = true;\n      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));\n    }).catch((e) => {\n      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e);\n    });\n  };\n  api.persist = {\n    setOptions: (newOptions) => {\n      options = {\n        ...options,\n        ...newOptions\n      };\n      if (newOptions.storage) {\n        storage = newOptions.storage;\n      }\n    },\n    clearStorage: () => {\n      storage == null ? void 0 : storage.removeItem(options.name);\n    },\n    getOptions: () => options,\n    rehydrate: () => hydrate(),\n    hasHydrated: () => hasHydrated,\n    onHydrate: (cb) => {\n      hydrationListeners.add(cb);\n      return () => {\n        hydrationListeners.delete(cb);\n      };\n    },\n    onFinishHydration: (cb) => {\n      finishHydrationListeners.add(cb);\n      return () => {\n        finishHydrationListeners.delete(cb);\n      };\n    }\n  };\n  if (!options.skipHydration) {\n    hydrate();\n  }\n  return stateFromStorage || configResult;\n};\nconst persistImpl = (config, baseOptions) => {\n  if (\"getStorage\" in baseOptions || \"serialize\" in baseOptions || \"deserialize\" in baseOptions) {\n    if (true) {\n      console.warn(\n        \"[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead.\"\n      );\n    }\n    return oldImpl(config, baseOptions);\n  }\n  return newImpl(config, baseOptions);\n};\nconst persist = persistImpl;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BpbnJlYWx0aW1lL3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9taWRkbGV3YXJlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSw4Q0FBOEM7QUFDOUMsVUFBVSxrREFBa0Q7QUFDNUQ7QUFDQTtBQUNBLHNEQUFzRCxhQUFvQjtBQUMxRSxJQUFJO0FBQ0o7QUFDQTtBQUNBLFFBQVEsS0FBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1Q0FBdUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQywyQ0FBMkMsdUNBQXVDLHFCQUFxQjtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLEdBQUcsWUFBWTtBQUN0QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsaUNBQWlDLGlCQUFpQjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvRUFBb0U7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxhQUFhO0FBQzlFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQSx5Q0FBeUMsaUNBQWlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxhQUFhO0FBQzlFO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGlucmVhbHRpbWUvcmVhY3Qvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL21pZGRsZXdhcmUuanM/OWE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZWR1eEltcGwgPSAocmVkdWNlciwgaW5pdGlhbCkgPT4gKHNldCwgX2dldCwgYXBpKSA9PiB7XG4gIGFwaS5kaXNwYXRjaCA9IChhY3Rpb24pID0+IHtcbiAgICBzZXQoKHN0YXRlKSA9PiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pLCBmYWxzZSwgYWN0aW9uKTtcbiAgICByZXR1cm4gYWN0aW9uO1xuICB9O1xuICBhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMgPSB0cnVlO1xuICByZXR1cm4geyBkaXNwYXRjaDogKC4uLmEpID0+IGFwaS5kaXNwYXRjaCguLi5hKSwgLi4uaW5pdGlhbCB9O1xufTtcbmNvbnN0IHJlZHV4ID0gcmVkdXhJbXBsO1xuXG5jb25zdCB0cmFja2VkQ29ubmVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuY29uc3QgZ2V0VHJhY2tlZENvbm5lY3Rpb25TdGF0ZSA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGFwaSA9IHRyYWNrZWRDb25uZWN0aW9ucy5nZXQobmFtZSk7XG4gIGlmICghYXBpKVxuICAgIHJldHVybiB7fTtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhhcGkuc3RvcmVzKS5tYXAoKFtrZXksIGFwaTJdKSA9PiBba2V5LCBhcGkyLmdldFN0YXRlKCldKVxuICApO1xufTtcbmNvbnN0IGV4dHJhY3RDb25uZWN0aW9uSW5mb3JtYXRpb24gPSAoc3RvcmUsIGV4dGVuc2lvbkNvbm5lY3Rvciwgb3B0aW9ucykgPT4ge1xuICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVudHJhY2tlZFwiLFxuICAgICAgY29ubmVjdGlvbjogZXh0ZW5zaW9uQ29ubmVjdG9yLmNvbm5lY3Qob3B0aW9ucylcbiAgICB9O1xuICB9XG4gIGNvbnN0IGV4aXN0aW5nQ29ubmVjdGlvbiA9IHRyYWNrZWRDb25uZWN0aW9ucy5nZXQob3B0aW9ucy5uYW1lKTtcbiAgaWYgKGV4aXN0aW5nQ29ubmVjdGlvbikge1xuICAgIHJldHVybiB7IHR5cGU6IFwidHJhY2tlZFwiLCBzdG9yZSwgLi4uZXhpc3RpbmdDb25uZWN0aW9uIH07XG4gIH1cbiAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICBjb25uZWN0aW9uOiBleHRlbnNpb25Db25uZWN0b3IuY29ubmVjdChvcHRpb25zKSxcbiAgICBzdG9yZXM6IHt9XG4gIH07XG4gIHRyYWNrZWRDb25uZWN0aW9ucy5zZXQob3B0aW9ucy5uYW1lLCBuZXdDb25uZWN0aW9uKTtcbiAgcmV0dXJuIHsgdHlwZTogXCJ0cmFja2VkXCIsIHN0b3JlLCAuLi5uZXdDb25uZWN0aW9uIH07XG59O1xuY29uc3QgZGV2dG9vbHNJbXBsID0gKGZuLCBkZXZ0b29sc09wdGlvbnMgPSB7fSkgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgY29uc3QgeyBlbmFibGVkLCBhbm9ueW1vdXNBY3Rpb25UeXBlLCBzdG9yZSwgLi4ub3B0aW9ucyB9ID0gZGV2dG9vbHNPcHRpb25zO1xuICBsZXQgZXh0ZW5zaW9uQ29ubmVjdG9yO1xuICB0cnkge1xuICAgIGV4dGVuc2lvbkNvbm5lY3RvciA9IChlbmFibGVkICE9IG51bGwgPyBlbmFibGVkIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSAmJiB3aW5kb3cuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fXztcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGlmICghZXh0ZW5zaW9uQ29ubmVjdG9yKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbmFibGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gUGxlYXNlIGluc3RhbGwvZW5hYmxlIFJlZHV4IGRldnRvb2xzIGV4dGVuc2lvblwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZm4oc2V0LCBnZXQsIGFwaSk7XG4gIH1cbiAgY29uc3QgeyBjb25uZWN0aW9uLCAuLi5jb25uZWN0aW9uSW5mb3JtYXRpb24gfSA9IGV4dHJhY3RDb25uZWN0aW9uSW5mb3JtYXRpb24oc3RvcmUsIGV4dGVuc2lvbkNvbm5lY3Rvciwgb3B0aW9ucyk7XG4gIGxldCBpc1JlY29yZGluZyA9IHRydWU7XG4gIGFwaS5zZXRTdGF0ZSA9IChzdGF0ZSwgcmVwbGFjZSwgbmFtZU9yQWN0aW9uKSA9PiB7XG4gICAgY29uc3QgciA9IHNldChzdGF0ZSwgcmVwbGFjZSk7XG4gICAgaWYgKCFpc1JlY29yZGluZylcbiAgICAgIHJldHVybiByO1xuICAgIGNvbnN0IGFjdGlvbiA9IG5hbWVPckFjdGlvbiA9PT0gdm9pZCAwID8geyB0eXBlOiBhbm9ueW1vdXNBY3Rpb25UeXBlIHx8IFwiYW5vbnltb3VzXCIgfSA6IHR5cGVvZiBuYW1lT3JBY3Rpb24gPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IG5hbWVPckFjdGlvbiB9IDogbmFtZU9yQWN0aW9uO1xuICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLnNlbmQoYWN0aW9uLCBnZXQoKSk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5zZW5kKFxuICAgICAge1xuICAgICAgICAuLi5hY3Rpb24sXG4gICAgICAgIHR5cGU6IGAke3N0b3JlfS8ke2FjdGlvbi50eXBlfWBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC4uLmdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSxcbiAgICAgICAgW3N0b3JlXTogYXBpLmdldFN0YXRlKClcbiAgICAgIH1cbiAgICApO1xuICAgIHJldHVybiByO1xuICB9O1xuICBjb25zdCBzZXRTdGF0ZUZyb21EZXZ0b29scyA9ICguLi5hKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJc1JlY29yZGluZyA9IGlzUmVjb3JkaW5nO1xuICAgIGlzUmVjb3JkaW5nID0gZmFsc2U7XG4gICAgc2V0KC4uLmEpO1xuICAgIGlzUmVjb3JkaW5nID0gb3JpZ2luYWxJc1JlY29yZGluZztcbiAgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gZm4oYXBpLnNldFN0YXRlLCBnZXQsIGFwaSk7XG4gIGlmIChjb25uZWN0aW9uSW5mb3JtYXRpb24udHlwZSA9PT0gXCJ1bnRyYWNrZWRcIikge1xuICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChpbml0aWFsU3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZXNbY29ubmVjdGlvbkluZm9ybWF0aW9uLnN0b3JlXSA9IGFwaTtcbiAgICBjb25uZWN0aW9uID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0aW9uLmluaXQoXG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZXMpLm1hcCgoW2tleSwgc3RvcmUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBrZXkgPT09IGNvbm5lY3Rpb25JbmZvcm1hdGlvbi5zdG9yZSA/IGluaXRpYWxTdGF0ZSA6IHN0b3JlMi5nZXRTdGF0ZSgpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoYXBpLmRpc3BhdGNoRnJvbURldnRvb2xzICYmIHR5cGVvZiBhcGkuZGlzcGF0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxldCBkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gYXBpLmRpc3BhdGNoO1xuICAgIGFwaS5kaXNwYXRjaCA9ICguLi5hKSA9PiB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGFbMF0udHlwZSA9PT0gXCJfX3NldFN0YXRlXCIgJiYgIWRpZFdhcm5BYm91dFJlc2VydmVkQWN0aW9uVHlwZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1t6dXN0YW5kIGRldnRvb2xzIG1pZGRsZXdhcmVdIFwiX19zZXRTdGF0ZVwiIGFjdGlvbiB0eXBlIGlzIHJlc2VydmVkIHRvIHNldCBzdGF0ZSBmcm9tIHRoZSBkZXZ0b29scy4gQXZvaWQgdXNpbmcgaXQuJ1xuICAgICAgICApO1xuICAgICAgICBkaWRXYXJuQWJvdXRSZXNlcnZlZEFjdGlvblR5cGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb3JpZ2luYWxEaXNwYXRjaCguLi5hKTtcbiAgICB9O1xuICB9XG4gIGNvbm5lY3Rpb24uc3Vic2NyaWJlKChtZXNzYWdlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAobWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlIFwiQUNUSU9OXCI6XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5wYXlsb2FkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gVW5zdXBwb3J0ZWQgYWN0aW9uIGZvcm1hdFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4oXG4gICAgICAgICAgbWVzc2FnZS5wYXlsb2FkLFxuICAgICAgICAgIChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJfX3NldFN0YXRlXCIpIHtcbiAgICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhhY3Rpb24uc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYWN0aW9uLnN0YXRlKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICAgICBbenVzdGFuZCBkZXZ0b29scyBtaWRkbGV3YXJlXSBVbnN1cHBvcnRlZCBfX3NldFN0YXRlIGFjdGlvbiBmb3JtYXQuIFxuICAgICAgICAgICAgICAgICAgICBXaGVuIHVzaW5nICdzdG9yZScgb3B0aW9uIGluIGRldnRvb2xzKCksIHRoZSAnc3RhdGUnIHNob3VsZCBoYXZlIG9ubHkgb25lIGtleSwgd2hpY2ggaXMgYSB2YWx1ZSBvZiAnc3RvcmUnIHRoYXQgd2FzIHBhc3NlZCBpbiBkZXZ0b29scygpLFxuICAgICAgICAgICAgICAgICAgICBhbmQgdmFsdWUgb2YgdGhpcyBvbmx5IGtleSBzaG91bGQgYmUgYSBzdGF0ZSBvYmplY3QuIEV4YW1wbGU6IHsgXCJ0eXBlXCI6IFwiX19zZXRTdGF0ZVwiLCBcInN0YXRlXCI6IHsgXCJhYmMxMjNTdG9yZVwiOiB7IFwiZm9vXCI6IFwiYmFyXCIgfSB9IH1cbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3Qgc3RhdGVGcm9tRGV2dG9vbHMgPSBhY3Rpb24uc3RhdGVbc3RvcmVdO1xuICAgICAgICAgICAgICBpZiAoc3RhdGVGcm9tRGV2dG9vbHMgPT09IHZvaWQgMCB8fCBzdGF0ZUZyb21EZXZ0b29scyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkoYXBpLmdldFN0YXRlKCkpICE9PSBKU09OLnN0cmluZ2lmeShzdGF0ZUZyb21EZXZ0b29scykpIHtcbiAgICAgICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhzdGF0ZUZyb21EZXZ0b29scyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcGkuZGlzcGF0Y2hGcm9tRGV2dG9vbHMpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYXBpLmRpc3BhdGNoICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGFwaS5kaXNwYXRjaChhY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJESVNQQVRDSFwiOlxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UucGF5bG9hZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlJFU0VUXCI6XG4gICAgICAgICAgICBzZXRTdGF0ZUZyb21EZXZ0b29scyhpbml0aWFsU3RhdGUpO1xuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGdldFRyYWNrZWRDb25uZWN0aW9uU3RhdGUob3B0aW9ucy5uYW1lKSk7XG4gICAgICAgICAgY2FzZSBcIkNPTU1JVFwiOlxuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29ubmVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogY29ubmVjdGlvbi5pbml0KGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChnZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSkpO1xuICAgICAgICAgIGNhc2UgXCJST0xMQkFDS1wiOlxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblRoZW4obWVzc2FnZS5zdGF0ZSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdG9yZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMoc3RhdGUpO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChhcGkuZ2V0U3RhdGUoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlW3N0b3JlXSk7XG4gICAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uaW5pdChnZXRUcmFja2VkQ29ubmVjdGlvblN0YXRlKG9wdGlvbnMubmFtZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgY2FzZSBcIkpVTVBfVE9fU1RBVEVcIjpcbiAgICAgICAgICBjYXNlIFwiSlVNUF9UT19BQ1RJT05cIjpcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUpzb25UaGVuKG1lc3NhZ2Uuc3RhdGUsIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoc3RvcmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KGFwaS5nZXRTdGF0ZSgpKSAhPT0gSlNPTi5zdHJpbmdpZnkoc3RhdGVbc3RvcmVdKSkge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlRnJvbURldnRvb2xzKHN0YXRlW3N0b3JlXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJJTVBPUlRfU1RBVEVcIjoge1xuICAgICAgICAgICAgY29uc3QgeyBuZXh0TGlmdGVkU3RhdGUgfSA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDb21wdXRlZFN0YXRlID0gKF9hID0gbmV4dExpZnRlZFN0YXRlLmNvbXB1dGVkU3RhdGVzLnNsaWNlKC0xKVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnN0YXRlO1xuICAgICAgICAgICAgaWYgKCFsYXN0Q29tcHV0ZWRTdGF0ZSlcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHN0b3JlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMobGFzdENvbXB1dGVkU3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0U3RhdGVGcm9tRGV2dG9vbHMobGFzdENvbXB1dGVkU3RhdGVbc3RvcmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbm5lY3Rpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uc2VuZChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgLy8gRklYTUUgbm8tYW55XG4gICAgICAgICAgICAgIG5leHRMaWZ0ZWRTdGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlBBVVNFX1JFQ09SRElOR1wiOlxuICAgICAgICAgICAgcmV0dXJuIGlzUmVjb3JkaW5nID0gIWlzUmVjb3JkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW5pdGlhbFN0YXRlO1xufTtcbmNvbnN0IGRldnRvb2xzID0gZGV2dG9vbHNJbXBsO1xuY29uc3QgcGFyc2VKc29uVGhlbiA9IChzdHJpbmdpZmllZCwgZikgPT4ge1xuICBsZXQgcGFyc2VkO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RyaW5naWZpZWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihcbiAgICAgIFwiW3p1c3RhbmQgZGV2dG9vbHMgbWlkZGxld2FyZV0gQ291bGQgbm90IHBhcnNlIHRoZSByZWNlaXZlZCBqc29uXCIsXG4gICAgICBlXG4gICAgKTtcbiAgfVxuICBpZiAocGFyc2VkICE9PSB2b2lkIDApXG4gICAgZihwYXJzZWQpO1xufTtcblxuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbCA9IChmbikgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgY29uc3Qgb3JpZ1N1YnNjcmliZSA9IGFwaS5zdWJzY3JpYmU7XG4gIGFwaS5zdWJzY3JpYmUgPSAoc2VsZWN0b3IsIG9wdExpc3RlbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgbGV0IGxpc3RlbmVyID0gc2VsZWN0b3I7XG4gICAgaWYgKG9wdExpc3RlbmVyKSB7XG4gICAgICBjb25zdCBlcXVhbGl0eUZuID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZXF1YWxpdHlGbikgfHwgT2JqZWN0LmlzO1xuICAgICAgbGV0IGN1cnJlbnRTbGljZSA9IHNlbGVjdG9yKGFwaS5nZXRTdGF0ZSgpKTtcbiAgICAgIGxpc3RlbmVyID0gKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRTbGljZSA9IHNlbGVjdG9yKHN0YXRlKTtcbiAgICAgICAgaWYgKCFlcXVhbGl0eUZuKGN1cnJlbnRTbGljZSwgbmV4dFNsaWNlKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgICAgb3B0TGlzdGVuZXIoY3VycmVudFNsaWNlID0gbmV4dFNsaWNlLCBwcmV2aW91c1NsaWNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZpcmVJbW1lZGlhdGVseSkge1xuICAgICAgICBvcHRMaXN0ZW5lcihjdXJyZW50U2xpY2UsIGN1cnJlbnRTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcmlnU3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcbiAgY29uc3QgaW5pdGlhbFN0YXRlID0gZm4oc2V0LCBnZXQsIGFwaSk7XG4gIHJldHVybiBpbml0aWFsU3RhdGU7XG59O1xuY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gc3Vic2NyaWJlV2l0aFNlbGVjdG9ySW1wbDtcblxuY29uc3QgY29tYmluZSA9IChpbml0aWFsU3RhdGUsIGNyZWF0ZSkgPT4gKC4uLmEpID0+IE9iamVjdC5hc3NpZ24oe30sIGluaXRpYWxTdGF0ZSwgY3JlYXRlKC4uLmEpKTtcblxuZnVuY3Rpb24gY3JlYXRlSlNPTlN0b3JhZ2UoZ2V0U3RvcmFnZSwgb3B0aW9ucykge1xuICBsZXQgc3RvcmFnZTtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlID0gZ2V0U3RvcmFnZSgpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBlcnNpc3RTdG9yYWdlID0ge1xuICAgIGdldEl0ZW06IChuYW1lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBwYXJzZSA9IChzdHIyKSA9PiB7XG4gICAgICAgIGlmIChzdHIyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyMiwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXZpdmVyKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzdHIgPSAoX2EgPSBzdG9yYWdlLmdldEl0ZW0obmFtZSkpICE9IG51bGwgPyBfYSA6IG51bGw7XG4gICAgICBpZiAoc3RyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gc3RyLnRoZW4ocGFyc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlKHN0cik7XG4gICAgfSxcbiAgICBzZXRJdGVtOiAobmFtZSwgbmV3VmFsdWUpID0+IHN0b3JhZ2Uuc2V0SXRlbShcbiAgICAgIG5hbWUsXG4gICAgICBKU09OLnN0cmluZ2lmeShuZXdWYWx1ZSwgb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXBsYWNlcilcbiAgICApLFxuICAgIHJlbW92ZUl0ZW06IChuYW1lKSA9PiBzdG9yYWdlLnJlbW92ZUl0ZW0obmFtZSlcbiAgfTtcbiAgcmV0dXJuIHBlcnNpc3RTdG9yYWdlO1xufVxuY29uc3QgdG9UaGVuYWJsZSA9IChmbikgPT4gKGlucHV0KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gZm4oaW5wdXQpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdGhlbihvbkZ1bGZpbGxlZCkge1xuICAgICAgICByZXR1cm4gdG9UaGVuYWJsZShvbkZ1bGZpbGxlZCkocmVzdWx0KTtcbiAgICAgIH0sXG4gICAgICBjYXRjaChfb25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRoZW4oX29uRnVsZmlsbGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRvVGhlbmFibGUob25SZWplY3RlZCkoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmNvbnN0IG9sZEltcGwgPSAoY29uZmlnLCBiYXNlT3B0aW9ucykgPT4gKHNldCwgZ2V0LCBhcGkpID0+IHtcbiAgbGV0IG9wdGlvbnMgPSB7XG4gICAgZ2V0U3RvcmFnZTogKCkgPT4gbG9jYWxTdG9yYWdlLFxuICAgIHNlcmlhbGl6ZTogSlNPTi5zdHJpbmdpZnksXG4gICAgZGVzZXJpYWxpemU6IEpTT04ucGFyc2UsXG4gICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiBzdGF0ZSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIC4uLnBlcnNpc3RlZFN0YXRlXG4gICAgfSksXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdG9yYWdlO1xuICB0cnkge1xuICAgIHN0b3JhZ2UgPSBvcHRpb25zLmdldFN0b3JhZ2UoKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIGlmICghc3RvcmFnZSkge1xuICAgIHJldHVybiBjb25maWcoXG4gICAgICAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFt6dXN0YW5kIHBlcnNpc3QgbWlkZGxld2FyZV0gVW5hYmxlIHRvIHVwZGF0ZSBpdGVtICcke29wdGlvbnMubmFtZX0nLCB0aGUgZ2l2ZW4gc3RvcmFnZSBpcyBjdXJyZW50bHkgdW5hdmFpbGFibGUuYFxuICAgICAgICApO1xuICAgICAgICBzZXQoLi4uYXJncyk7XG4gICAgICB9LFxuICAgICAgZ2V0LFxuICAgICAgYXBpXG4gICAgKTtcbiAgfVxuICBjb25zdCB0aGVuYWJsZVNlcmlhbGl6ZSA9IHRvVGhlbmFibGUob3B0aW9ucy5zZXJpYWxpemUpO1xuICBjb25zdCBzZXRJdGVtID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gb3B0aW9ucy5wYXJ0aWFsaXplKHsgLi4uZ2V0KCkgfSk7XG4gICAgbGV0IGVycm9ySW5TeW5jO1xuICAgIGNvbnN0IHRoZW5hYmxlID0gdGhlbmFibGVTZXJpYWxpemUoeyBzdGF0ZSwgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uIH0pLnRoZW4oXG4gICAgICAoc2VyaWFsaXplZFZhbHVlKSA9PiBzdG9yYWdlLnNldEl0ZW0ob3B0aW9ucy5uYW1lLCBzZXJpYWxpemVkVmFsdWUpXG4gICAgKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgZXJyb3JJblN5bmMgPSBlO1xuICAgIH0pO1xuICAgIGlmIChlcnJvckluU3luYykge1xuICAgICAgdGhyb3cgZXJyb3JJblN5bmM7XG4gICAgfVxuICAgIHJldHVybiB0aGVuYWJsZTtcbiAgfTtcbiAgY29uc3Qgc2F2ZWRTZXRTdGF0ZSA9IGFwaS5zZXRTdGF0ZTtcbiAgYXBpLnNldFN0YXRlID0gKHN0YXRlLCByZXBsYWNlKSA9PiB7XG4gICAgc2F2ZWRTZXRTdGF0ZShzdGF0ZSwgcmVwbGFjZSk7XG4gICAgdm9pZCBzZXRJdGVtKCk7XG4gIH07XG4gIGNvbnN0IGNvbmZpZ1Jlc3VsdCA9IGNvbmZpZyhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgdm9pZCBzZXRJdGVtKCk7XG4gICAgfSxcbiAgICBnZXQsXG4gICAgYXBpXG4gICk7XG4gIGxldCBzdGF0ZUZyb21TdG9yYWdlO1xuICBjb25zdCBoeWRyYXRlID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IGNiKGdldCgpKSk7XG4gICAgY29uc3QgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPSAoKF9hID0gb3B0aW9ucy5vblJlaHlkcmF0ZVN0b3JhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIGdldCgpKSkgfHwgdm9pZCAwO1xuICAgIHJldHVybiB0b1RoZW5hYmxlKHN0b3JhZ2UuZ2V0SXRlbS5iaW5kKHN0b3JhZ2UpKShvcHRpb25zLm5hbWUpLnRoZW4oKHN0b3JhZ2VWYWx1ZSkgPT4ge1xuICAgICAgaWYgKHN0b3JhZ2VWYWx1ZSkge1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXNlcmlhbGl6ZShzdG9yYWdlVmFsdWUpO1xuICAgICAgfVxuICAgIH0pLnRoZW4oKGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZSkgPT4ge1xuICAgICAgaWYgKGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uID09PSBcIm51bWJlclwiICYmIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uICE9PSBvcHRpb25zLnZlcnNpb24pIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5taWdyYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5taWdyYXRlKFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUuc3RhdGUsXG4gICAgICAgICAgICAgIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS52ZXJzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFN0YXRlIGxvYWRlZCBmcm9tIHN0b3JhZ2UgY291bGRuJ3QgYmUgbWlncmF0ZWQgc2luY2Ugbm8gbWlncmF0ZSBmdW5jdGlvbiB3YXMgcHJvdmlkZWRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkudGhlbigobWlncmF0ZWRTdGF0ZSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHN0YXRlRnJvbVN0b3JhZ2UgPSBvcHRpb25zLm1lcmdlKFxuICAgICAgICBtaWdyYXRlZFN0YXRlLFxuICAgICAgICAoX2EyID0gZ2V0KCkpICE9IG51bGwgPyBfYTIgOiBjb25maWdSZXN1bHRcbiAgICAgICk7XG4gICAgICBzZXQoc3RhdGVGcm9tU3RvcmFnZSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gc2V0SXRlbSgpO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrKHN0YXRlRnJvbVN0b3JhZ2UsIHZvaWQgMCk7XG4gICAgICBoYXNIeWRyYXRlZCA9IHRydWU7XG4gICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IGNiKHN0YXRlRnJvbVN0b3JhZ2UpKTtcbiAgICB9KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgcG9zdFJlaHlkcmF0aW9uQ2FsbGJhY2sgPT0gbnVsbCA/IHZvaWQgMCA6IHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrKHZvaWQgMCwgZSk7XG4gICAgfSk7XG4gIH07XG4gIGFwaS5wZXJzaXN0ID0ge1xuICAgIHNldE9wdGlvbnM6IChuZXdPcHRpb25zKSA9PiB7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAuLi5uZXdPcHRpb25zXG4gICAgICB9O1xuICAgICAgaWYgKG5ld09wdGlvbnMuZ2V0U3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlID0gbmV3T3B0aW9ucy5nZXRTdG9yYWdlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclN0b3JhZ2U6ICgpID0+IHtcbiAgICAgIHN0b3JhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IHN0b3JhZ2UucmVtb3ZlSXRlbShvcHRpb25zLm5hbWUpO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogKCkgPT4gb3B0aW9ucyxcbiAgICByZWh5ZHJhdGU6ICgpID0+IGh5ZHJhdGUoKSxcbiAgICBoYXNIeWRyYXRlZDogKCkgPT4gaGFzSHlkcmF0ZWQsXG4gICAgb25IeWRyYXRlOiAoY2IpID0+IHtcbiAgICAgIGh5ZHJhdGlvbkxpc3RlbmVycy5hZGQoY2IpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmRlbGV0ZShjYik7XG4gICAgICB9O1xuICAgIH0sXG4gICAgb25GaW5pc2hIeWRyYXRpb246IChjYikgPT4ge1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICBoeWRyYXRlKCk7XG4gIHJldHVybiBzdGF0ZUZyb21TdG9yYWdlIHx8IGNvbmZpZ1Jlc3VsdDtcbn07XG5jb25zdCBuZXdJbXBsID0gKGNvbmZpZywgYmFzZU9wdGlvbnMpID0+IChzZXQsIGdldCwgYXBpKSA9PiB7XG4gIGxldCBvcHRpb25zID0ge1xuICAgIHN0b3JhZ2U6IGNyZWF0ZUpTT05TdG9yYWdlKCgpID0+IGxvY2FsU3RvcmFnZSksXG4gICAgcGFydGlhbGl6ZTogKHN0YXRlKSA9PiBzdGF0ZSxcbiAgICB2ZXJzaW9uOiAwLFxuICAgIG1lcmdlOiAocGVyc2lzdGVkU3RhdGUsIGN1cnJlbnRTdGF0ZSkgPT4gKHtcbiAgICAgIC4uLmN1cnJlbnRTdGF0ZSxcbiAgICAgIC4uLnBlcnNpc3RlZFN0YXRlXG4gICAgfSksXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfTtcbiAgbGV0IGhhc0h5ZHJhdGVkID0gZmFsc2U7XG4gIGNvbnN0IGh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGNvbnN0IGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBzdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlO1xuICBpZiAoIXN0b3JhZ2UpIHtcbiAgICByZXR1cm4gY29uZmlnKFxuICAgICAgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBbenVzdGFuZCBwZXJzaXN0IG1pZGRsZXdhcmVdIFVuYWJsZSB0byB1cGRhdGUgaXRlbSAnJHtvcHRpb25zLm5hbWV9JywgdGhlIGdpdmVuIHN0b3JhZ2UgaXMgY3VycmVudGx5IHVuYXZhaWxhYmxlLmBcbiAgICAgICAgKTtcbiAgICAgICAgc2V0KC4uLmFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGdldCxcbiAgICAgIGFwaVxuICAgICk7XG4gIH1cbiAgY29uc3Qgc2V0SXRlbSA9ICgpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IG9wdGlvbnMucGFydGlhbGl6ZSh7IC4uLmdldCgpIH0pO1xuICAgIHJldHVybiBzdG9yYWdlLnNldEl0ZW0ob3B0aW9ucy5uYW1lLCB7XG4gICAgICBzdGF0ZSxcbiAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvblxuICAgIH0pO1xuICB9O1xuICBjb25zdCBzYXZlZFNldFN0YXRlID0gYXBpLnNldFN0YXRlO1xuICBhcGkuc2V0U3RhdGUgPSAoc3RhdGUsIHJlcGxhY2UpID0+IHtcbiAgICBzYXZlZFNldFN0YXRlKHN0YXRlLCByZXBsYWNlKTtcbiAgICB2b2lkIHNldEl0ZW0oKTtcbiAgfTtcbiAgY29uc3QgY29uZmlnUmVzdWx0ID0gY29uZmlnKFxuICAgICguLi5hcmdzKSA9PiB7XG4gICAgICBzZXQoLi4uYXJncyk7XG4gICAgICB2b2lkIHNldEl0ZW0oKTtcbiAgICB9LFxuICAgIGdldCxcbiAgICBhcGlcbiAgKTtcbiAgbGV0IHN0YXRlRnJvbVN0b3JhZ2U7XG4gIGNvbnN0IGh5ZHJhdGUgPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoIXN0b3JhZ2UpXG4gICAgICByZXR1cm47XG4gICAgaGFzSHlkcmF0ZWQgPSBmYWxzZTtcbiAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gY2IoKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0KTtcbiAgICB9KTtcbiAgICBjb25zdCBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayA9ICgoX2IgPSBvcHRpb25zLm9uUmVoeWRyYXRlU3RvcmFnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwob3B0aW9ucywgKF9hID0gZ2V0KCkpICE9IG51bGwgPyBfYSA6IGNvbmZpZ1Jlc3VsdCkpIHx8IHZvaWQgMDtcbiAgICByZXR1cm4gdG9UaGVuYWJsZShzdG9yYWdlLmdldEl0ZW0uYmluZChzdG9yYWdlKSkob3B0aW9ucy5uYW1lKS50aGVuKChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpID0+IHtcbiAgICAgIGlmIChkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiA9PT0gXCJudW1iZXJcIiAmJiBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvbiAhPT0gb3B0aW9ucy52ZXJzaW9uKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMubWlncmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMubWlncmF0ZShcbiAgICAgICAgICAgICAgZGVzZXJpYWxpemVkU3RvcmFnZVZhbHVlLnN0YXRlLFxuICAgICAgICAgICAgICBkZXNlcmlhbGl6ZWRTdG9yYWdlVmFsdWUudmVyc2lvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGBTdGF0ZSBsb2FkZWQgZnJvbSBzdG9yYWdlIGNvdWxkbid0IGJlIG1pZ3JhdGVkIHNpbmNlIG5vIG1pZ3JhdGUgZnVuY3Rpb24gd2FzIHByb3ZpZGVkYFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZFN0b3JhZ2VWYWx1ZS5zdGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLnRoZW4oKG1pZ3JhdGVkU3RhdGUpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBzdGF0ZUZyb21TdG9yYWdlID0gb3B0aW9ucy5tZXJnZShcbiAgICAgICAgbWlncmF0ZWRTdGF0ZSxcbiAgICAgICAgKF9hMiA9IGdldCgpKSAhPSBudWxsID8gX2EyIDogY29uZmlnUmVzdWx0XG4gICAgICApO1xuICAgICAgc2V0KHN0YXRlRnJvbVN0b3JhZ2UsIHRydWUpO1xuICAgICAgcmV0dXJuIHNldEl0ZW0oKTtcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayhzdGF0ZUZyb21TdG9yYWdlLCB2b2lkIDApO1xuICAgICAgc3RhdGVGcm9tU3RvcmFnZSA9IGdldCgpO1xuICAgICAgaGFzSHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgZmluaXNoSHlkcmF0aW9uTGlzdGVuZXJzLmZvckVhY2goKGNiKSA9PiBjYihzdGF0ZUZyb21TdG9yYWdlKSk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHBvc3RSZWh5ZHJhdGlvbkNhbGxiYWNrID09IG51bGwgPyB2b2lkIDAgOiBwb3N0UmVoeWRyYXRpb25DYWxsYmFjayh2b2lkIDAsIGUpO1xuICAgIH0pO1xuICB9O1xuICBhcGkucGVyc2lzdCA9IHtcbiAgICBzZXRPcHRpb25zOiAobmV3T3B0aW9ucykgPT4ge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgLi4ubmV3T3B0aW9uc1xuICAgICAgfTtcbiAgICAgIGlmIChuZXdPcHRpb25zLnN0b3JhZ2UpIHtcbiAgICAgICAgc3RvcmFnZSA9IG5ld09wdGlvbnMuc3RvcmFnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyU3RvcmFnZTogKCkgPT4ge1xuICAgICAgc3RvcmFnZSA9PSBudWxsID8gdm9pZCAwIDogc3RvcmFnZS5yZW1vdmVJdGVtKG9wdGlvbnMubmFtZSk7XG4gICAgfSxcbiAgICBnZXRPcHRpb25zOiAoKSA9PiBvcHRpb25zLFxuICAgIHJlaHlkcmF0ZTogKCkgPT4gaHlkcmF0ZSgpLFxuICAgIGhhc0h5ZHJhdGVkOiAoKSA9PiBoYXNIeWRyYXRlZCxcbiAgICBvbkh5ZHJhdGU6IChjYikgPT4ge1xuICAgICAgaHlkcmF0aW9uTGlzdGVuZXJzLmFkZChjYik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBoeWRyYXRpb25MaXN0ZW5lcnMuZGVsZXRlKGNiKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBvbkZpbmlzaEh5ZHJhdGlvbjogKGNiKSA9PiB7XG4gICAgICBmaW5pc2hIeWRyYXRpb25MaXN0ZW5lcnMuYWRkKGNiKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGZpbmlzaEh5ZHJhdGlvbkxpc3RlbmVycy5kZWxldGUoY2IpO1xuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIGlmICghb3B0aW9ucy5za2lwSHlkcmF0aW9uKSB7XG4gICAgaHlkcmF0ZSgpO1xuICB9XG4gIHJldHVybiBzdGF0ZUZyb21TdG9yYWdlIHx8IGNvbmZpZ1Jlc3VsdDtcbn07XG5jb25zdCBwZXJzaXN0SW1wbCA9IChjb25maWcsIGJhc2VPcHRpb25zKSA9PiB7XG4gIGlmIChcImdldFN0b3JhZ2VcIiBpbiBiYXNlT3B0aW9ucyB8fCBcInNlcmlhbGl6ZVwiIGluIGJhc2VPcHRpb25zIHx8IFwiZGVzZXJpYWxpemVcIiBpbiBiYXNlT3B0aW9ucykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbREVQUkVDQVRFRF0gYGdldFN0b3JhZ2VgLCBgc2VyaWFsaXplYCBhbmQgYGRlc2VyaWFsaXplYCBvcHRpb25zIGFyZSBkZXByZWNhdGVkLiBVc2UgYHN0b3JhZ2VgIG9wdGlvbiBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gb2xkSW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gbmV3SW1wbChjb25maWcsIGJhc2VPcHRpb25zKTtcbn07XG5jb25zdCBwZXJzaXN0ID0gcGVyc2lzdEltcGw7XG5cbmV4cG9ydCB7IGNvbWJpbmUsIGNyZWF0ZUpTT05TdG9yYWdlLCBkZXZ0b29scywgcGVyc2lzdCwgcmVkdXgsIHN1YnNjcmliZVdpdGhTZWxlY3RvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@inrealtime/react/node_modules/zustand/esm/middleware.js\n"));

/***/ }),

/***/ "../../node_modules/dayjs/dayjs.min.js":
/*!*********************************************!*\
  !*** ../../node_modules/dayjs/dayjs.min.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(t,e){ true?module.exports=e():0}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",f=\"month\",h=\"quarter\",c=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=function(t){return t instanceof _},S=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},w=function(t,e){if(p(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=v;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),l=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return O.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(h){case c:return r?l(1,0):l(31,11);case f:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=h+\"Date\",n[d]=h+\"Date\",n[f]=h+\"Month\",n[c]=h+\"FullYear\",n[u]=h+\"Hours\",n[s]=h+\"Minutes\",n[i]=h+\"Seconds\",n[r]=h+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,l=this;r=Number(r);var $=O.p(h),y=function(t){var e=w(l);return O.w(e.date(e.date()+Math.round(t*r)),l)};if($===f)return this.set(f,this.$M+r);if($===c)return this.set(c,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},c=function(t){return O.s(s%12||12,t,\"0\")},d=n.meridiem||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r},$={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,\"0\"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,\"0\"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,\"0\"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,\"0\"),s:String(this.$s),ss:O.s(this.$s,2,\"0\"),SSS:O.s(this.$ms,3,\"0\"),Z:i};return r.replace(y,(function(t,e){return e||$[t]||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,v=this-M,g=O.m(this,M);return g=($={},$[c]=g/12,$[f]=g,$[h]=g/3,$[o]=(v-m)/6048e5,$[a]=(v-m)/864e5,$[u]=v/n,$[s]=v/e,$[i]=v/t,$)[y]||v,l?g:O.a(g)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),T=_.prototype;return w.prototype=T,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",f],[\"$y\",c],[\"$D\",d]].forEach((function(t){T[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=D[g],w.Ls=D,w.p={},w}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2RheWpzL2RheWpzLm1pbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQW9ELG9CQUFvQixDQUErRyxDQUFDLGtCQUFrQixhQUFhLHdKQUF3SixFQUFFLFVBQVUsSUFBSSxXQUFXLElBQUksWUFBWSxJQUFJLFFBQVEsSUFBSSxRQUFRLElBQUksaUNBQWlDLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxPQUFPLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxVQUFVLHVOQUF1TixvQ0FBb0MsNENBQTRDLG1CQUFtQixnQkFBZ0IseURBQXlELElBQUksa0JBQWtCLDZEQUE2RCwrQ0FBK0MsbUJBQW1CLG1DQUFtQyw4R0FBOEcsbUNBQW1DLGVBQWUseUNBQXlDLGVBQWUsT0FBTyx5Q0FBeUMsa0RBQWtELGVBQWUsbUJBQW1CLGFBQWEsT0FBTyxrQkFBa0Isc0JBQXNCLHFCQUFxQixNQUFNLGVBQWUsdUJBQXVCLHNCQUFzQiw0QkFBNEIsbUJBQW1CLGlDQUFpQyxLQUFLLGFBQWEsV0FBVyw0QkFBNEIsaUJBQWlCLHlCQUF5Qiw4QkFBOEIsMENBQTBDLEtBQUssOEJBQThCLFlBQVksOENBQThDLEdBQUcsaUJBQWlCLGNBQWMsMENBQTBDLGtCQUFrQiwyQkFBMkIsb0JBQW9CLHFCQUFxQixpQ0FBaUMsMEJBQTBCLHdDQUF3Qyx1Q0FBdUMsaUJBQWlCLE1BQU0sNkNBQTZDLDBIQUEwSCxtQkFBbUIsbUJBQW1CLGFBQWEsbUJBQW1CLGNBQWMsb0xBQW9MLHFCQUFxQixTQUFTLHNCQUFzQixnQ0FBZ0Msd0JBQXdCLFdBQVcsNENBQTRDLHlCQUF5Qiw0QkFBNEIsMEJBQTBCLDBCQUEwQixzQkFBc0Isb0NBQW9DLG1CQUFtQixzQ0FBc0Msc0JBQXNCLHlCQUF5Qix5QkFBeUIsa0RBQWtELHdEQUF3RCxzQkFBc0IsaUJBQWlCLHVGQUF1RiwwREFBMEQsVUFBVSxnQ0FBZ0MsZ0NBQWdDLHlEQUF5RCwwQkFBMEIsb0NBQW9DLCtCQUErQiwrQkFBK0Isb0NBQW9DLDZCQUE2QixxQkFBcUIsMEJBQTBCLHNCQUFzQixpREFBaUQseUtBQXlLLGlCQUFpQiw0QkFBNEIsMEVBQTBFLHNCQUFzQix3QkFBd0IscUJBQXFCLDhCQUE4QixtQkFBbUIsc0JBQXNCLHFCQUFxQixhQUFhLFlBQVksMkJBQTJCLFdBQVcsZ0RBQWdELHNDQUFzQyxzQ0FBc0MscUJBQXFCLHFCQUFxQixXQUFXLHVEQUF1RCxtQkFBbUIsMEJBQTBCLHdCQUF3QixzQkFBc0IsNEJBQTRCLDJDQUEyQyxzSEFBc0gsMENBQTBDLGVBQWUsMkJBQTJCLCtCQUErQixxQkFBcUIsMkJBQTJCLElBQUksa1pBQWtaLGtDQUFrQyxrQ0FBa0MsR0FBRyx3QkFBd0Isc0RBQXNELHdCQUF3QixrRkFBa0YsY0FBYyw2R0FBNkcsMEJBQTBCLHdCQUF3QixzQkFBc0Isa0JBQWtCLHdCQUF3QixxQkFBcUIsK0JBQStCLHFCQUFxQixvQkFBb0IseUJBQXlCLHFCQUFxQixnQ0FBZ0MscUJBQXFCLDhDQUE4QywwQkFBMEIsNkJBQTZCLHVCQUF1Qiw2QkFBNkIsR0FBRyxpQkFBaUIscUhBQXFILG9CQUFvQiw2QkFBNkIsMEJBQTBCLGtDQUFrQywyQ0FBMkMsZ0JBQWdCLHdCQUF3QixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvZGF5anMvZGF5anMubWluLmpzP2Q4OTkiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoZSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqcz1lKCl9KHRoaXMsKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9MWUzLGU9NmU0LG49MzZlNSxyPVwibWlsbGlzZWNvbmRcIixpPVwic2Vjb25kXCIscz1cIm1pbnV0ZVwiLHU9XCJob3VyXCIsYT1cImRheVwiLG89XCJ3ZWVrXCIsZj1cIm1vbnRoXCIsaD1cInF1YXJ0ZXJcIixjPVwieWVhclwiLGQ9XCJkYXRlXCIsbD1cIkludmFsaWQgRGF0ZVwiLCQ9L14oXFxkezR9KVstL10/KFxcZHsxLDJ9KT9bLS9dPyhcXGR7MCwyfSlbVHRcXHNdKihcXGR7MSwyfSk/Oj8oXFxkezEsMn0pPzo/KFxcZHsxLDJ9KT9bLjpdPyhcXGQrKT8kLyx5PS9cXFsoW15cXF1dKyldfFl7MSw0fXxNezEsNH18RHsxLDJ9fGR7MSw0fXxIezEsMn18aHsxLDJ9fGF8QXxtezEsMn18c3sxLDJ9fFp7MSwyfXxTU1MvZyxNPXtuYW1lOlwiZW5cIix3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLG1vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIiksb3JkaW5hbDpmdW5jdGlvbih0KXt2YXIgZT1bXCJ0aFwiLFwic3RcIixcIm5kXCIsXCJyZFwiXSxuPXQlMTAwO3JldHVyblwiW1wiK3QrKGVbKG4tMjApJTEwXXx8ZVtuXXx8ZVswXSkrXCJdXCJ9fSxtPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj1TdHJpbmcodCk7cmV0dXJuIXJ8fHIubGVuZ3RoPj1lP3Q6XCJcIitBcnJheShlKzEtci5sZW5ndGgpLmpvaW4obikrdH0sdj17czptLHo6ZnVuY3Rpb24odCl7dmFyIGU9LXQudXRjT2Zmc2V0KCksbj1NYXRoLmFicyhlKSxyPU1hdGguZmxvb3Iobi82MCksaT1uJTYwO3JldHVybihlPD0wP1wiK1wiOlwiLVwiKSttKHIsMixcIjBcIikrXCI6XCIrbShpLDIsXCIwXCIpfSxtOmZ1bmN0aW9uIHQoZSxuKXtpZihlLmRhdGUoKTxuLmRhdGUoKSlyZXR1cm4tdChuLGUpO3ZhciByPTEyKihuLnllYXIoKS1lLnllYXIoKSkrKG4ubW9udGgoKS1lLm1vbnRoKCkpLGk9ZS5jbG9uZSgpLmFkZChyLGYpLHM9bi1pPDAsdT1lLmNsb25lKCkuYWRkKHIrKHM/LTE6MSksZik7cmV0dXJuKygtKHIrKG4taSkvKHM/aS11OnUtaSkpfHwwKX0sYTpmdW5jdGlvbih0KXtyZXR1cm4gdDwwP01hdGguY2VpbCh0KXx8MDpNYXRoLmZsb29yKHQpfSxwOmZ1bmN0aW9uKHQpe3JldHVybntNOmYseTpjLHc6byxkOmEsRDpkLGg6dSxtOnMsczppLG1zOnIsUTpofVt0XXx8U3RyaW5nKHR8fFwiXCIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvcyQvLFwiXCIpfSx1OmZ1bmN0aW9uKHQpe3JldHVybiB2b2lkIDA9PT10fX0sZz1cImVuXCIsRD17fTtEW2ddPU07dmFyIHA9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBffSxTPWZ1bmN0aW9uIHQoZSxuLHIpe3ZhciBpO2lmKCFlKXJldHVybiBnO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXt2YXIgcz1lLnRvTG93ZXJDYXNlKCk7RFtzXSYmKGk9cyksbiYmKERbc109bixpPXMpO3ZhciB1PWUuc3BsaXQoXCItXCIpO2lmKCFpJiZ1Lmxlbmd0aD4xKXJldHVybiB0KHVbMF0pfWVsc2V7dmFyIGE9ZS5uYW1lO0RbYV09ZSxpPWF9cmV0dXJuIXImJmkmJihnPWkpLGl8fCFyJiZnfSx3PWZ1bmN0aW9uKHQsZSl7aWYocCh0KSlyZXR1cm4gdC5jbG9uZSgpO3ZhciBuPVwib2JqZWN0XCI9PXR5cGVvZiBlP2U6e307cmV0dXJuIG4uZGF0ZT10LG4uYXJncz1hcmd1bWVudHMsbmV3IF8obil9LE89djtPLmw9UyxPLmk9cCxPLnc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0LHtsb2NhbGU6ZS4kTCx1dGM6ZS4kdSx4OmUuJHgsJG9mZnNldDplLiRvZmZzZXR9KX07dmFyIF89ZnVuY3Rpb24oKXtmdW5jdGlvbiBNKHQpe3RoaXMuJEw9Uyh0LmxvY2FsZSxudWxsLCEwKSx0aGlzLnBhcnNlKHQpfXZhciBtPU0ucHJvdG90eXBlO3JldHVybiBtLnBhcnNlPWZ1bmN0aW9uKHQpe3RoaXMuJGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRlLG49dC51dGM7aWYobnVsbD09PWUpcmV0dXJuIG5ldyBEYXRlKE5hTik7aWYoTy51KGUpKXJldHVybiBuZXcgRGF0ZTtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJiEvWiQvaS50ZXN0KGUpKXt2YXIgcj1lLm1hdGNoKCQpO2lmKHIpe3ZhciBpPXJbMl0tMXx8MCxzPShyWzddfHxcIjBcIikuc3Vic3RyaW5nKDAsMyk7cmV0dXJuIG4/bmV3IERhdGUoRGF0ZS5VVEMoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscykpOm5ldyBEYXRlKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpfX1yZXR1cm4gbmV3IERhdGUoZSl9KHQpLHRoaXMuJHg9dC54fHx7fSx0aGlzLmluaXQoKX0sbS5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZDt0aGlzLiR5PXQuZ2V0RnVsbFllYXIoKSx0aGlzLiRNPXQuZ2V0TW9udGgoKSx0aGlzLiREPXQuZ2V0RGF0ZSgpLHRoaXMuJFc9dC5nZXREYXkoKSx0aGlzLiRIPXQuZ2V0SG91cnMoKSx0aGlzLiRtPXQuZ2V0TWludXRlcygpLHRoaXMuJHM9dC5nZXRTZWNvbmRzKCksdGhpcy4kbXM9dC5nZXRNaWxsaXNlY29uZHMoKX0sbS4kdXRpbHM9ZnVuY3Rpb24oKXtyZXR1cm4gT30sbS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLiRkLnRvU3RyaW5nKCk9PT1sKX0sbS5pc1NhbWU9ZnVuY3Rpb24odCxlKXt2YXIgbj13KHQpO3JldHVybiB0aGlzLnN0YXJ0T2YoZSk8PW4mJm48PXRoaXMuZW5kT2YoZSl9LG0uaXNBZnRlcj1mdW5jdGlvbih0LGUpe3JldHVybiB3KHQpPHRoaXMuc3RhcnRPZihlKX0sbS5pc0JlZm9yZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuZE9mKGUpPHcodCl9LG0uJGc9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBPLnUodCk/dGhpc1tlXTp0aGlzLnNldChuLHQpfSxtLnVuaXg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKS8xZTMpfSxtLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC5nZXRUaW1lKCl9LG0uc3RhcnRPZj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMscj0hIU8udShlKXx8ZSxoPU8ucCh0KSxsPWZ1bmN0aW9uKHQsZSl7dmFyIGk9Ty53KG4uJHU/RGF0ZS5VVEMobi4keSxlLHQpOm5ldyBEYXRlKG4uJHksZSx0KSxuKTtyZXR1cm4gcj9pOmkuZW5kT2YoYSl9LCQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTy53KG4udG9EYXRlKClbdF0uYXBwbHkobi50b0RhdGUoXCJzXCIpLChyP1swLDAsMCwwXTpbMjMsNTksNTksOTk5XSkuc2xpY2UoZSkpLG4pfSx5PXRoaXMuJFcsTT10aGlzLiRNLG09dGhpcy4kRCx2PVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKTtzd2l0Y2goaCl7Y2FzZSBjOnJldHVybiByP2woMSwwKTpsKDMxLDExKTtjYXNlIGY6cmV0dXJuIHI/bCgxLE0pOmwoMCxNKzEpO2Nhc2Ugbzp2YXIgZz10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsRD0oeTxnP3krNzp5KS1nO3JldHVybiBsKHI/bS1EOm0rKDYtRCksTSk7Y2FzZSBhOmNhc2UgZDpyZXR1cm4gJCh2K1wiSG91cnNcIiwwKTtjYXNlIHU6cmV0dXJuICQoditcIk1pbnV0ZXNcIiwxKTtjYXNlIHM6cmV0dXJuICQoditcIlNlY29uZHNcIiwyKTtjYXNlIGk6cmV0dXJuICQoditcIk1pbGxpc2Vjb25kc1wiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LG0uZW5kT2Y9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnRPZih0LCExKX0sbS4kc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG4sbz1PLnAodCksaD1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIiksbD0obj17fSxuW2FdPWgrXCJEYXRlXCIsbltkXT1oK1wiRGF0ZVwiLG5bZl09aCtcIk1vbnRoXCIsbltjXT1oK1wiRnVsbFllYXJcIixuW3VdPWgrXCJIb3Vyc1wiLG5bc109aCtcIk1pbnV0ZXNcIixuW2ldPWgrXCJTZWNvbmRzXCIsbltyXT1oK1wiTWlsbGlzZWNvbmRzXCIsbilbb10sJD1vPT09YT90aGlzLiREKyhlLXRoaXMuJFcpOmU7aWYobz09PWZ8fG89PT1jKXt2YXIgeT10aGlzLmNsb25lKCkuc2V0KGQsMSk7eS4kZFtsXSgkKSx5LmluaXQoKSx0aGlzLiRkPXkuc2V0KGQsTWF0aC5taW4odGhpcy4kRCx5LmRheXNJbk1vbnRoKCkpKS4kZH1lbHNlIGwmJnRoaXMuJGRbbF0oJCk7cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9LG0uc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS4kc2V0KHQsZSl9LG0uZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzW08ucCh0KV0oKX0sbS5hZGQ9ZnVuY3Rpb24ocixoKXt2YXIgZCxsPXRoaXM7cj1OdW1iZXIocik7dmFyICQ9Ty5wKGgpLHk9ZnVuY3Rpb24odCl7dmFyIGU9dyhsKTtyZXR1cm4gTy53KGUuZGF0ZShlLmRhdGUoKStNYXRoLnJvdW5kKHQqcikpLGwpfTtpZigkPT09ZilyZXR1cm4gdGhpcy5zZXQoZix0aGlzLiRNK3IpO2lmKCQ9PT1jKXJldHVybiB0aGlzLnNldChjLHRoaXMuJHkrcik7aWYoJD09PWEpcmV0dXJuIHkoMSk7aWYoJD09PW8pcmV0dXJuIHkoNyk7dmFyIE09KGQ9e30sZFtzXT1lLGRbdV09bixkW2ldPXQsZClbJF18fDEsbT10aGlzLiRkLmdldFRpbWUoKStyKk07cmV0dXJuIE8udyhtLHRoaXMpfSxtLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKC0xKnQsZSl9LG0uZm9ybWF0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLiRsb2NhbGUoKTtpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuIG4uaW52YWxpZERhdGV8fGw7dmFyIHI9dHx8XCJZWVlZLU1NLUREVEhIOm1tOnNzWlwiLGk9Ty56KHRoaXMpLHM9dGhpcy4kSCx1PXRoaXMuJG0sYT10aGlzLiRNLG89bi53ZWVrZGF5cyxmPW4ubW9udGhzLGg9ZnVuY3Rpb24odCxuLGkscyl7cmV0dXJuIHQmJih0W25dfHx0KGUscikpfHxpW25dLnNsaWNlKDAscyl9LGM9ZnVuY3Rpb24odCl7cmV0dXJuIE8ucyhzJTEyfHwxMix0LFwiMFwiKX0sZD1uLm1lcmlkaWVtfHxmdW5jdGlvbih0LGUsbil7dmFyIHI9dDwxMj9cIkFNXCI6XCJQTVwiO3JldHVybiBuP3IudG9Mb3dlckNhc2UoKTpyfSwkPXtZWTpTdHJpbmcodGhpcy4keSkuc2xpY2UoLTIpLFlZWVk6dGhpcy4keSxNOmErMSxNTTpPLnMoYSsxLDIsXCIwXCIpLE1NTTpoKG4ubW9udGhzU2hvcnQsYSxmLDMpLE1NTU06aChmLGEpLEQ6dGhpcy4kRCxERDpPLnModGhpcy4kRCwyLFwiMFwiKSxkOlN0cmluZyh0aGlzLiRXKSxkZDpoKG4ud2Vla2RheXNNaW4sdGhpcy4kVyxvLDIpLGRkZDpoKG4ud2Vla2RheXNTaG9ydCx0aGlzLiRXLG8sMyksZGRkZDpvW3RoaXMuJFddLEg6U3RyaW5nKHMpLEhIOk8ucyhzLDIsXCIwXCIpLGg6YygxKSxoaDpjKDIpLGE6ZChzLHUsITApLEE6ZChzLHUsITEpLG06U3RyaW5nKHUpLG1tOk8ucyh1LDIsXCIwXCIpLHM6U3RyaW5nKHRoaXMuJHMpLHNzOk8ucyh0aGlzLiRzLDIsXCIwXCIpLFNTUzpPLnModGhpcy4kbXMsMyxcIjBcIiksWjppfTtyZXR1cm4gci5yZXBsYWNlKHksKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fCRbdF18fGkucmVwbGFjZShcIjpcIixcIlwiKX0pKX0sbS51dGNPZmZzZXQ9ZnVuY3Rpb24oKXtyZXR1cm4gMTUqLU1hdGgucm91bmQodGhpcy4kZC5nZXRUaW1lem9uZU9mZnNldCgpLzE1KX0sbS5kaWZmPWZ1bmN0aW9uKHIsZCxsKXt2YXIgJCx5PU8ucChkKSxNPXcociksbT0oTS51dGNPZmZzZXQoKS10aGlzLnV0Y09mZnNldCgpKSplLHY9dGhpcy1NLGc9Ty5tKHRoaXMsTSk7cmV0dXJuIGc9KCQ9e30sJFtjXT1nLzEyLCRbZl09ZywkW2hdPWcvMywkW29dPSh2LW0pLzYwNDhlNSwkW2FdPSh2LW0pLzg2NGU1LCRbdV09di9uLCRbc109di9lLCRbaV09di90LCQpW3ldfHx2LGw/ZzpPLmEoZyl9LG0uZGF5c0luTW9udGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRPZihmKS4kRH0sbS4kbG9jYWxlPWZ1bmN0aW9uKCl7cmV0dXJuIERbdGhpcy4kTF19LG0ubG9jYWxlPWZ1bmN0aW9uKHQsZSl7aWYoIXQpcmV0dXJuIHRoaXMuJEw7dmFyIG49dGhpcy5jbG9uZSgpLHI9Uyh0LGUsITApO3JldHVybiByJiYobi4kTD1yKSxufSxtLmNsb25lPWZ1bmN0aW9uKCl7cmV0dXJuIE8udyh0aGlzLiRkLHRoaXMpfSxtLnRvRGF0ZT1mdW5jdGlvbigpe3JldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSl9LG0udG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNWYWxpZCgpP3RoaXMudG9JU09TdHJpbmcoKTpudWxsfSxtLnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGQudG9JU09TdHJpbmcoKX0sbS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvVVRDU3RyaW5nKCl9LE19KCksVD1fLnByb3RvdHlwZTtyZXR1cm4gdy5wcm90b3R5cGU9VCxbW1wiJG1zXCIscl0sW1wiJHNcIixpXSxbXCIkbVwiLHNdLFtcIiRIXCIsdV0sW1wiJFdcIixhXSxbXCIkTVwiLGZdLFtcIiR5XCIsY10sW1wiJERcIixkXV0uZm9yRWFjaCgoZnVuY3Rpb24odCl7VFt0WzFdXT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy4kZyhlLHRbMF0sdFsxXSl9fSkpLHcuZXh0ZW5kPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuJGl8fCh0KGUsXyx3KSx0LiRpPSEwKSx3fSx3LmxvY2FsZT1TLHcuaXNEYXlqcz1wLHcudW5peD1mdW5jdGlvbih0KXtyZXR1cm4gdygxZTMqdCl9LHcuZW49RFtnXSx3LkxzPUQsdy5wPXt9LHd9KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/dayjs/dayjs.min.js\n"));

/***/ }),

/***/ "../../node_modules/dayjs/plugin/utc.js":
/*!**********************************************!*\
  !*** ../../node_modules/dayjs/plugin/utc.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("!function(t,i){ true?module.exports=i():0}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2RheWpzL3BsdWdpbi91dGMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFvRCxvQkFBb0IsQ0FBMEgsQ0FBQyxrQkFBa0IsYUFBYSx5REFBeUQsdUJBQXVCLGtCQUFrQixrQkFBa0IsT0FBTyw4QkFBOEIsZ0JBQWdCLG1CQUFtQix1QkFBdUIsc0JBQXNCLEVBQUUscUNBQXFDLG9CQUFvQix3QkFBd0Isc0JBQXNCLEdBQUcsY0FBYyxvQkFBb0IseUZBQXlGLGFBQWEsa0JBQWtCLFlBQVksY0FBYyw0TUFBNE0sbUJBQW1CLGtCQUFrQiwwQkFBMEIsc0JBQXNCLG1FQUFtRSxzQ0FBc0MsbUJBQW1CLGlCQUFpQixrQkFBa0IsNkRBQTZELDRCQUE0QiwwQkFBMEIsb0NBQW9DLHFDQUFxQyxVQUFVLG9FQUFvRSwwREFBMEQsa0JBQWtCLFVBQVUsZUFBZSxxQkFBcUIsK0NBQStDLHNCQUFzQixzQkFBc0IsdUdBQXVHLCtCQUErQixvQkFBb0IsZ0JBQWdCLDBCQUEwQixtQ0FBbUMsdUJBQXVCLG9DQUFvQyxlQUFlLHFCQUFxQiw2RkFBNkYsYUFBYSx1QkFBdUIsK0NBQStDLGtDQUFrQyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9kYXlqcy9wbHVnaW4vdXRjLmpzPzBjNjgiXSwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsaSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9aSgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoaSk6KHQ9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbFRoaXM/Z2xvYmFsVGhpczp0fHxzZWxmKS5kYXlqc19wbHVnaW5fdXRjPWkoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD1cIm1pbnV0ZVwiLGk9L1srLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2csZT0vKFsrLV18XFxkXFxkKS9nO3JldHVybiBmdW5jdGlvbihzLGYsbil7dmFyIHU9Zi5wcm90b3R5cGU7bi51dGM9ZnVuY3Rpb24odCl7dmFyIGk9e2RhdGU6dCx1dGM6ITAsYXJnczphcmd1bWVudHN9O3JldHVybiBuZXcgZihpKX0sdS51dGM9ZnVuY3Rpb24oaSl7dmFyIGU9bih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITB9KTtyZXR1cm4gaT9lLmFkZCh0aGlzLnV0Y09mZnNldCgpLHQpOmV9LHUubG9jYWw9ZnVuY3Rpb24oKXtyZXR1cm4gbih0aGlzLnRvRGF0ZSgpLHtsb2NhbGU6dGhpcy4kTCx1dGM6ITF9KX07dmFyIG89dS5wYXJzZTt1LnBhcnNlPWZ1bmN0aW9uKHQpe3QudXRjJiYodGhpcy4kdT0hMCksdGhpcy4kdXRpbHMoKS51KHQuJG9mZnNldCl8fCh0aGlzLiRvZmZzZXQ9dC4kb2Zmc2V0KSxvLmNhbGwodGhpcyx0KX07dmFyIHI9dS5pbml0O3UuaW5pdD1mdW5jdGlvbigpe2lmKHRoaXMuJHUpe3ZhciB0PXRoaXMuJGQ7dGhpcy4keT10LmdldFVUQ0Z1bGxZZWFyKCksdGhpcy4kTT10LmdldFVUQ01vbnRoKCksdGhpcy4kRD10LmdldFVUQ0RhdGUoKSx0aGlzLiRXPXQuZ2V0VVRDRGF5KCksdGhpcy4kSD10LmdldFVUQ0hvdXJzKCksdGhpcy4kbT10LmdldFVUQ01pbnV0ZXMoKSx0aGlzLiRzPXQuZ2V0VVRDU2Vjb25kcygpLHRoaXMuJG1zPXQuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9ZWxzZSByLmNhbGwodGhpcyl9O3ZhciBhPXUudXRjT2Zmc2V0O3UudXRjT2Zmc2V0PWZ1bmN0aW9uKHMsZil7dmFyIG49dGhpcy4kdXRpbHMoKS51O2lmKG4ocykpcmV0dXJuIHRoaXMuJHU/MDpuKHRoaXMuJG9mZnNldCk/YS5jYWxsKHRoaXMpOnRoaXMuJG9mZnNldDtpZihcInN0cmluZ1wiPT10eXBlb2YgcyYmKHM9ZnVuY3Rpb24odCl7dm9pZCAwPT09dCYmKHQ9XCJcIik7dmFyIHM9dC5tYXRjaChpKTtpZighcylyZXR1cm4gbnVsbDt2YXIgZj0oXCJcIitzWzBdKS5tYXRjaChlKXx8W1wiLVwiLDAsMF0sbj1mWzBdLHU9NjAqK2ZbMV0rICtmWzJdO3JldHVybiAwPT09dT8wOlwiK1wiPT09bj91Oi11fShzKSxudWxsPT09cykpcmV0dXJuIHRoaXM7dmFyIHU9TWF0aC5hYnMocyk8PTE2PzYwKnM6cyxvPXRoaXM7aWYoZilyZXR1cm4gby4kb2Zmc2V0PXUsby4kdT0wPT09cyxvO2lmKDAhPT1zKXt2YXIgcj10aGlzLiR1P3RoaXMudG9EYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTotMSp0aGlzLnV0Y09mZnNldCgpOyhvPXRoaXMubG9jYWwoKS5hZGQodStyLHQpKS4kb2Zmc2V0PXUsby4keC4kbG9jYWxPZmZzZXQ9cn1lbHNlIG89dGhpcy51dGMoKTtyZXR1cm4gb307dmFyIGg9dS5mb3JtYXQ7dS5mb3JtYXQ9ZnVuY3Rpb24odCl7dmFyIGk9dHx8KHRoaXMuJHU/XCJZWVlZLU1NLUREVEhIOm1tOnNzW1pdXCI6XCJcIik7cmV0dXJuIGguY2FsbCh0aGlzLGkpfSx1LnZhbHVlT2Y9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLiR1dGlscygpLnUodGhpcy4kb2Zmc2V0KT8wOnRoaXMuJG9mZnNldCsodGhpcy4keC4kbG9jYWxPZmZzZXR8fHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKSk7cmV0dXJuIHRoaXMuJGQudmFsdWVPZigpLTZlNCp0fSx1LmlzVVRDPWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLiR1fSx1LnRvSVNPU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9EYXRlKCkudG9JU09TdHJpbmcoKX0sdS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnRvRGF0ZSgpLnRvVVRDU3RyaW5nKCl9O3ZhciBsPXUudG9EYXRlO3UudG9EYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwic1wiPT09dCYmdGhpcy4kb2Zmc2V0P24odGhpcy5mb3JtYXQoXCJZWVlZLU1NLUREIEhIOm1tOnNzOlNTU1wiKSkudG9EYXRlKCk6bC5jYWxsKHRoaXMpfTt2YXIgYz11LmRpZmY7dS5kaWZmPWZ1bmN0aW9uKHQsaSxlKXtpZih0JiZ0aGlzLiR1PT09dC4kdSlyZXR1cm4gYy5jYWxsKHRoaXMsdCxpLGUpO3ZhciBzPXRoaXMubG9jYWwoKSxmPW4odCkubG9jYWwoKTtyZXR1cm4gYy5jYWxsKHMsZixpLGUpfX19KSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/dayjs/plugin/utc.js\n"));

/***/ }),

/***/ "../../node_modules/immer/dist/cjs/immer.cjs.development.js":
/*!******************************************************************!*\
  !*** ../../node_modules/immer/dist/cjs/immer.cjs.development.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/immer.ts\nvar immer_exports = {};\n__export(immer_exports, {\n  Immer: () => Immer2,\n  applyPatches: () => applyPatches,\n  castDraft: () => castDraft,\n  castImmutable: () => castImmutable,\n  createDraft: () => createDraft,\n  current: () => current,\n  enableMapSet: () => enableMapSet,\n  enablePatches: () => enablePatches,\n  finishDraft: () => finishDraft,\n  freeze: () => freeze,\n  immerable: () => DRAFTABLE,\n  isDraft: () => isDraft,\n  isDraftable: () => isDraftable,\n  nothing: () => NOTHING,\n  original: () => original,\n  produce: () => produce,\n  produceWithPatches: () => produceWithPatches,\n  setAutoFreeze: () => setAutoFreeze,\n  setUseStrictShallowCopy: () => setUseStrictShallowCopy\n});\nmodule.exports = __toCommonJS(immer_exports);\n\n// src/utils/env.ts\nvar NOTHING = Symbol.for(\"immer-nothing\");\nvar DRAFTABLE = Symbol.for(\"immer-draftable\");\nvar DRAFT_STATE = Symbol.for(\"immer-state\");\n\n// src/utils/errors.ts\nvar errors =  true ? [\n  // All error codes, starting by 0:\n  function(plugin) {\n    return `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`;\n  },\n  function(thing) {\n    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`;\n  },\n  \"This object has been frozen and should not be mutated\",\n  function(data) {\n    return \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + data;\n  },\n  \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n  \"Immer forbids circular references\",\n  \"The first or second argument to `produce` must be a function\",\n  \"The third argument to `produce` must be a function or undefined\",\n  \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n  \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n  function(thing) {\n    return `'current' expects a draft, got: ${thing}`;\n  },\n  \"Object.defineProperty() cannot be used on an Immer draft\",\n  \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n  \"Immer only supports deleting array indices\",\n  \"Immer only supports setting array indices and the 'length' property\",\n  function(thing) {\n    return `'original' expects a draft, got: ${thing}`;\n  }\n  // Note: if more errors are added, the errorOffset in Patches.ts should be increased\n  // See Patches.ts for additional errors\n] : 0;\nfunction die(error, ...args) {\n  if (true) {\n    const e = errors[error];\n    const msg = typeof e === \"function\" ? e.apply(null, args) : e;\n    throw new Error(`[Immer] ${msg}`);\n  }\n  throw new Error(\n    `[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n  );\n}\n\n// src/utils/common.ts\nvar getPrototypeOf = Object.getPrototypeOf;\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value)\n    return false;\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor?.[DRAFTABLE] || isMap(value) || isSet(value);\n}\nvar objectCtorString = Object.prototype.constructor.toString();\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\")\n    return false;\n  const proto = getPrototypeOf(value);\n  if (proto === null) {\n    return true;\n  }\n  const Ctor = Object.hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n  if (Ctor === Object)\n    return true;\n  return typeof Ctor == \"function\" && Function.toString.call(Ctor) === objectCtorString;\n}\nfunction original(value) {\n  if (!isDraft(value))\n    die(15, value);\n  return value[DRAFT_STATE].base_;\n}\nfunction each(obj, iter) {\n  if (getArchtype(obj) === 0 /* Object */) {\n    Object.entries(obj).forEach(([key, value]) => {\n      iter(key, value, obj);\n    });\n  } else {\n    obj.forEach((entry, index) => iter(index, entry, obj));\n  }\n}\nfunction getArchtype(thing) {\n  const state = thing[DRAFT_STATE];\n  return state ? state.type_ : Array.isArray(thing) ? 1 /* Array */ : isMap(thing) ? 2 /* Map */ : isSet(thing) ? 3 /* Set */ : 0 /* Object */;\n}\nfunction has(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction get(thing, prop) {\n  return getArchtype(thing) === 2 /* Map */ ? thing.get(prop) : thing[prop];\n}\nfunction set(thing, propOrOldValue, value) {\n  const t = getArchtype(thing);\n  if (t === 2 /* Map */)\n    thing.set(propOrOldValue, value);\n  else if (t === 3 /* Set */) {\n    thing.add(value);\n  } else\n    thing[propOrOldValue] = value;\n}\nfunction is(x, y) {\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction isMap(target) {\n  return target instanceof Map;\n}\nfunction isSet(target) {\n  return target instanceof Set;\n}\nfunction latest(state) {\n  return state.copy_ || state.base_;\n}\nfunction shallowCopy(base, strict) {\n  if (isMap(base)) {\n    return new Map(base);\n  }\n  if (isSet(base)) {\n    return new Set(base);\n  }\n  if (Array.isArray(base))\n    return Array.prototype.slice.call(base);\n  if (!strict && isPlainObject(base)) {\n    if (!getPrototypeOf(base)) {\n      const obj = /* @__PURE__ */ Object.create(null);\n      return Object.assign(obj, base);\n    }\n    return { ...base };\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(base);\n  delete descriptors[DRAFT_STATE];\n  let keys = Reflect.ownKeys(descriptors);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const desc = descriptors[key];\n    if (desc.writable === false) {\n      desc.writable = true;\n      desc.configurable = true;\n    }\n    if (desc.get || desc.set)\n      descriptors[key] = {\n        configurable: true,\n        writable: true,\n        // could live with !!desc.set as well here...\n        enumerable: desc.enumerable,\n        value: base[key]\n      };\n  }\n  return Object.create(getPrototypeOf(base), descriptors);\n}\nfunction freeze(obj, deep = false) {\n  if (isFrozen(obj) || isDraft(obj) || !isDraftable(obj))\n    return obj;\n  if (getArchtype(obj) > 1) {\n    obj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n  Object.freeze(obj);\n  if (deep)\n    each(obj, (_key, value) => freeze(value, true), true);\n  return obj;\n}\nfunction dontMutateFrozenCollections() {\n  die(2);\n}\nfunction isFrozen(obj) {\n  return Object.isFrozen(obj);\n}\n\n// src/utils/plugins.ts\nvar plugins = {};\nfunction getPlugin(pluginKey) {\n  const plugin = plugins[pluginKey];\n  if (!plugin) {\n    die(0, pluginKey);\n  }\n  return plugin;\n}\nfunction loadPlugin(pluginKey, implementation) {\n  if (!plugins[pluginKey])\n    plugins[pluginKey] = implementation;\n}\n\n// src/core/scope.ts\nvar currentScope;\nfunction getCurrentScope() {\n  return currentScope;\n}\nfunction createScope(parent_, immer_) {\n  return {\n    drafts_: [],\n    parent_,\n    immer_,\n    // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n    canAutoFreeze_: true,\n    unfinalizedDrafts_: 0\n  };\n}\nfunction usePatchesInScope(scope, patchListener) {\n  if (patchListener) {\n    getPlugin(\"Patches\");\n    scope.patches_ = [];\n    scope.inversePatches_ = [];\n    scope.patchListener_ = patchListener;\n  }\n}\nfunction revokeScope(scope) {\n  leaveScope(scope);\n  scope.drafts_.forEach(revokeDraft);\n  scope.drafts_ = null;\n}\nfunction leaveScope(scope) {\n  if (scope === currentScope) {\n    currentScope = scope.parent_;\n  }\n}\nfunction enterScope(immer2) {\n  return currentScope = createScope(currentScope, immer2);\n}\nfunction revokeDraft(draft) {\n  const state = draft[DRAFT_STATE];\n  if (state.type_ === 0 /* Object */ || state.type_ === 1 /* Array */)\n    state.revoke_();\n  else\n    state.revoked_ = true;\n}\n\n// src/core/finalize.ts\nfunction processResult(result, scope) {\n  scope.unfinalizedDrafts_ = scope.drafts_.length;\n  const baseDraft = scope.drafts_[0];\n  const isReplaced = result !== void 0 && result !== baseDraft;\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified_) {\n      revokeScope(scope);\n      die(4);\n    }\n    if (isDraftable(result)) {\n      result = finalize(scope, result);\n      if (!scope.parent_)\n        maybeFreeze(scope, result);\n    }\n    if (scope.patches_) {\n      getPlugin(\"Patches\").generateReplacementPatches_(\n        baseDraft[DRAFT_STATE].base_,\n        result,\n        scope.patches_,\n        scope.inversePatches_\n      );\n    }\n  } else {\n    result = finalize(scope, baseDraft, []);\n  }\n  revokeScope(scope);\n  if (scope.patches_) {\n    scope.patchListener_(scope.patches_, scope.inversePatches_);\n  }\n  return result !== NOTHING ? result : void 0;\n}\nfunction finalize(rootScope, value, path) {\n  if (isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  if (!state) {\n    each(\n      value,\n      (key, childValue) => finalizeProperty(rootScope, state, value, key, childValue, path),\n      true\n      // See #590, don't recurse into non-enumerable of non drafted objects\n    );\n    return value;\n  }\n  if (state.scope_ !== rootScope)\n    return value;\n  if (!state.modified_) {\n    maybeFreeze(rootScope, state.base_, true);\n    return state.base_;\n  }\n  if (!state.finalized_) {\n    state.finalized_ = true;\n    state.scope_.unfinalizedDrafts_--;\n    const result = state.copy_;\n    let resultEach = result;\n    let isSet2 = false;\n    if (state.type_ === 3 /* Set */) {\n      resultEach = new Set(result);\n      result.clear();\n      isSet2 = true;\n    }\n    each(\n      resultEach,\n      (key, childValue) => finalizeProperty(rootScope, state, result, key, childValue, path, isSet2)\n    );\n    maybeFreeze(rootScope, result, false);\n    if (path && rootScope.patches_) {\n      getPlugin(\"Patches\").generatePatches_(\n        state,\n        path,\n        rootScope.patches_,\n        rootScope.inversePatches_\n      );\n    }\n  }\n  return state.copy_;\n}\nfunction finalizeProperty(rootScope, parentState, targetObject, prop, childValue, rootPath, targetIsSet) {\n  if ( true && childValue === targetObject)\n    die(5);\n  if (isDraft(childValue)) {\n    const path = rootPath && parentState && parentState.type_ !== 3 /* Set */ && // Set objects are atomic since they have no keys.\n    !has(parentState.assigned_, prop) ? rootPath.concat(prop) : void 0;\n    const res = finalize(rootScope, childValue, path);\n    set(targetObject, prop, res);\n    if (isDraft(res)) {\n      rootScope.canAutoFreeze_ = false;\n    } else\n      return;\n  } else if (targetIsSet) {\n    targetObject.add(childValue);\n  }\n  if (isDraftable(childValue) && !isFrozen(childValue)) {\n    if (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n      return;\n    }\n    finalize(rootScope, childValue);\n    if (!parentState || !parentState.scope_.parent_)\n      maybeFreeze(rootScope, childValue);\n  }\n}\nfunction maybeFreeze(scope, value, deep = false) {\n  if (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n    freeze(value, deep);\n  }\n}\n\n// src/core/proxy.ts\nfunction createProxyProxy(base, parent) {\n  const isArray = Array.isArray(base);\n  const state = {\n    type_: isArray ? 1 /* Array */ : 0 /* Object */,\n    // Track which produce call this is associated with.\n    scope_: parent ? parent.scope_ : getCurrentScope(),\n    // True for both shallow and deep changes.\n    modified_: false,\n    // Used during finalization.\n    finalized_: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned_: {},\n    // The parent draft state.\n    parent_: parent,\n    // The base state.\n    base_: base,\n    // The base proxy.\n    draft_: null,\n    // set below\n    // The base copy with any updated values.\n    copy_: null,\n    // Called by the `produce` function.\n    revoke_: null,\n    isManual_: false\n  };\n  let target = state;\n  let traps = objectTraps;\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  }\n  const { revoke, proxy } = Proxy.revocable(target, traps);\n  state.draft_ = proxy;\n  state.revoke_ = revoke;\n  return proxy;\n}\nvar objectTraps = {\n  get(state, prop) {\n    if (prop === DRAFT_STATE)\n      return state;\n    const source = latest(state);\n    if (!has(source, prop)) {\n      return readPropFromProto(state, source, prop);\n    }\n    const value = source[prop];\n    if (state.finalized_ || !isDraftable(value)) {\n      return value;\n    }\n    if (value === peek(state.base_, prop)) {\n      prepareCopy(state);\n      return state.copy_[prop] = createProxy(value, state);\n    }\n    return value;\n  },\n  has(state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys(state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set(state, prop, value) {\n    const desc = getDescriptorFromProto(latest(state), prop);\n    if (desc?.set) {\n      desc.set.call(state.draft_, value);\n      return true;\n    }\n    if (!state.modified_) {\n      const current2 = peek(latest(state), prop);\n      const currentState = current2?.[DRAFT_STATE];\n      if (currentState && currentState.base_ === value) {\n        state.copy_[prop] = value;\n        state.assigned_[prop] = false;\n        return true;\n      }\n      if (is(value, current2) && (value !== void 0 || has(state.base_, prop)))\n        return true;\n      prepareCopy(state);\n      markChanged(state);\n    }\n    if (state.copy_[prop] === value && // special case: handle new props with value 'undefined'\n    (value !== void 0 || prop in state.copy_) || // special case: NaN\n    Number.isNaN(value) && Number.isNaN(state.copy_[prop]))\n      return true;\n    state.copy_[prop] = value;\n    state.assigned_[prop] = true;\n    return true;\n  },\n  deleteProperty(state, prop) {\n    if (peek(state.base_, prop) !== void 0 || prop in state.base_) {\n      state.assigned_[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else {\n      delete state.assigned_[prop];\n    }\n    if (state.copy_) {\n      delete state.copy_[prop];\n    }\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor(state, prop) {\n    const owner = latest(state);\n    const desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n    if (!desc)\n      return desc;\n    return {\n      writable: true,\n      configurable: state.type_ !== 1 /* Array */ || prop !== \"length\",\n      enumerable: desc.enumerable,\n      value: owner[prop]\n    };\n  },\n  defineProperty() {\n    die(11);\n  },\n  getPrototypeOf(state) {\n    return getPrototypeOf(state.base_);\n  },\n  setPrototypeOf() {\n    die(12);\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, (key, fn) => {\n  arrayTraps[key] = function() {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\narrayTraps.deleteProperty = function(state, prop) {\n  if ( true && isNaN(parseInt(prop)))\n    die(13);\n  return arrayTraps.set.call(this, state, prop, void 0);\n};\narrayTraps.set = function(state, prop, value) {\n  if ( true && prop !== \"length\" && isNaN(parseInt(prop)))\n    die(14);\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\nfunction peek(draft, prop) {\n  const state = draft[DRAFT_STATE];\n  const source = state ? latest(state) : draft;\n  return source[prop];\n}\nfunction readPropFromProto(state, source, prop) {\n  const desc = getDescriptorFromProto(source, prop);\n  return desc ? `value` in desc ? desc.value : (\n    // This is a very special case, if the prop is a getter defined by the\n    // prototype, we should invoke it with the draft as context!\n    desc.get?.call(state.draft_)\n  ) : void 0;\n}\nfunction getDescriptorFromProto(source, prop) {\n  if (!(prop in source))\n    return void 0;\n  let proto = getPrototypeOf(source);\n  while (proto) {\n    const desc = Object.getOwnPropertyDescriptor(proto, prop);\n    if (desc)\n      return desc;\n    proto = getPrototypeOf(proto);\n  }\n  return void 0;\n}\nfunction markChanged(state) {\n  if (!state.modified_) {\n    state.modified_ = true;\n    if (state.parent_) {\n      markChanged(state.parent_);\n    }\n  }\n}\nfunction prepareCopy(state) {\n  if (!state.copy_) {\n    state.copy_ = shallowCopy(\n      state.base_,\n      state.scope_.immer_.useStrictShallowCopy_\n    );\n  }\n}\n\n// src/core/immerClass.ts\nvar Immer2 = class {\n  constructor(config) {\n    this.autoFreeze_ = true;\n    this.useStrictShallowCopy_ = false;\n    /**\n     * The `produce` function takes a value and a \"recipe function\" (whose\n     * return value often depends on the base state). The recipe function is\n     * free to mutate its first argument however it wants. All mutations are\n     * only ever applied to a __copy__ of the base state.\n     *\n     * Pass only a function to create a \"curried producer\" which relieves you\n     * from passing the recipe function every time.\n     *\n     * Only plain objects and arrays are made mutable. All other objects are\n     * considered uncopyable.\n     *\n     * Note: This function is __bound__ to its `Immer` instance.\n     *\n     * @param {any} base - the initial state\n     * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n     * @param {Function} patchListener - optional function that will be called with all the patches produced here\n     * @returns {any} a new state, or the initial state if nothing was modified\n     */\n    this.produce = (base, recipe, patchListener) => {\n      if (typeof base === \"function\" && typeof recipe !== \"function\") {\n        const defaultBase = recipe;\n        recipe = base;\n        const self = this;\n        return function curriedProduce(base2 = defaultBase, ...args) {\n          return self.produce(base2, (draft) => recipe.call(this, draft, ...args));\n        };\n      }\n      if (typeof recipe !== \"function\")\n        die(6);\n      if (patchListener !== void 0 && typeof patchListener !== \"function\")\n        die(7);\n      let result;\n      if (isDraftable(base)) {\n        const scope = enterScope(this);\n        const proxy = createProxy(base, void 0);\n        let hasError = true;\n        try {\n          result = recipe(proxy);\n          hasError = false;\n        } finally {\n          if (hasError)\n            revokeScope(scope);\n          else\n            leaveScope(scope);\n        }\n        usePatchesInScope(scope, patchListener);\n        return processResult(result, scope);\n      } else if (!base || typeof base !== \"object\") {\n        result = recipe(base);\n        if (result === void 0)\n          result = base;\n        if (result === NOTHING)\n          result = void 0;\n        if (this.autoFreeze_)\n          freeze(result, true);\n        if (patchListener) {\n          const p = [];\n          const ip = [];\n          getPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip);\n          patchListener(p, ip);\n        }\n        return result;\n      } else\n        die(1, base);\n    };\n    this.produceWithPatches = (base, recipe) => {\n      if (typeof base === \"function\") {\n        return (state, ...args) => this.produceWithPatches(state, (draft) => base(draft, ...args));\n      }\n      let patches, inversePatches;\n      const result = this.produce(base, recipe, (p, ip) => {\n        patches = p;\n        inversePatches = ip;\n      });\n      return [result, patches, inversePatches];\n    };\n    if (typeof config?.autoFreeze === \"boolean\")\n      this.setAutoFreeze(config.autoFreeze);\n    if (typeof config?.useStrictShallowCopy === \"boolean\")\n      this.setUseStrictShallowCopy(config.useStrictShallowCopy);\n  }\n  createDraft(base) {\n    if (!isDraftable(base))\n      die(8);\n    if (isDraft(base))\n      base = current(base);\n    const scope = enterScope(this);\n    const proxy = createProxy(base, void 0);\n    proxy[DRAFT_STATE].isManual_ = true;\n    leaveScope(scope);\n    return proxy;\n  }\n  finishDraft(draft, patchListener) {\n    const state = draft && draft[DRAFT_STATE];\n    if (!state || !state.isManual_)\n      die(9);\n    const { scope_: scope } = state;\n    usePatchesInScope(scope, patchListener);\n    return processResult(void 0, scope);\n  }\n  /**\n   * Pass true to automatically freeze all copies created by Immer.\n   *\n   * By default, auto-freezing is enabled.\n   */\n  setAutoFreeze(value) {\n    this.autoFreeze_ = value;\n  }\n  /**\n   * Pass true to enable strict shallow copy.\n   *\n   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n   */\n  setUseStrictShallowCopy(value) {\n    this.useStrictShallowCopy_ = value;\n  }\n  applyPatches(base, patches) {\n    let i;\n    for (i = patches.length - 1; i >= 0; i--) {\n      const patch = patches[i];\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n    if (i > -1) {\n      patches = patches.slice(i + 1);\n    }\n    const applyPatchesImpl = getPlugin(\"Patches\").applyPatches_;\n    if (isDraft(base)) {\n      return applyPatchesImpl(base, patches);\n    }\n    return this.produce(\n      base,\n      (draft) => applyPatchesImpl(draft, patches)\n    );\n  }\n};\nfunction createProxy(value, parent) {\n  const draft = isMap(value) ? getPlugin(\"MapSet\").proxyMap_(value, parent) : isSet(value) ? getPlugin(\"MapSet\").proxySet_(value, parent) : createProxyProxy(value, parent);\n  const scope = parent ? parent.scope_ : getCurrentScope();\n  scope.drafts_.push(draft);\n  return draft;\n}\n\n// src/core/current.ts\nfunction current(value) {\n  if (!isDraft(value))\n    die(10, value);\n  return currentImpl(value);\n}\nfunction currentImpl(value) {\n  if (!isDraftable(value) || isFrozen(value))\n    return value;\n  const state = value[DRAFT_STATE];\n  let copy;\n  if (state) {\n    if (!state.modified_)\n      return state.base_;\n    state.finalized_ = true;\n    copy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_);\n  } else {\n    copy = shallowCopy(value, true);\n  }\n  each(copy, (key, childValue) => {\n    set(copy, key, currentImpl(childValue));\n  });\n  if (state) {\n    state.finalized_ = false;\n  }\n  return copy;\n}\n\n// src/plugins/patches.ts\nfunction enablePatches() {\n  const errorOffset = 16;\n  if (true) {\n    errors.push(\n      'Sets cannot have \"replace\" patches.',\n      function(op) {\n        return \"Unsupported patch operation: \" + op;\n      },\n      function(path) {\n        return \"Cannot apply patch, path doesn't resolve: \" + path;\n      },\n      \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n    );\n  }\n  const REPLACE = \"replace\";\n  const ADD = \"add\";\n  const REMOVE = \"remove\";\n  function generatePatches_(state, basePath, patches, inversePatches) {\n    switch (state.type_) {\n      case 0 /* Object */:\n      case 2 /* Map */:\n        return generatePatchesFromAssigned(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n      case 1 /* Array */:\n        return generateArrayPatches(state, basePath, patches, inversePatches);\n      case 3 /* Set */:\n        return generateSetPatches(\n          state,\n          basePath,\n          patches,\n          inversePatches\n        );\n    }\n  }\n  function generateArrayPatches(state, basePath, patches, inversePatches) {\n    let { base_, assigned_ } = state;\n    let copy_ = state.copy_;\n    if (copy_.length < base_.length) {\n      ;\n      [base_, copy_] = [copy_, base_];\n      [patches, inversePatches] = [inversePatches, patches];\n    }\n    for (let i = 0; i < base_.length; i++) {\n      if (assigned_[i] && copy_[i] !== base_[i]) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REPLACE,\n          path,\n          // Need to maybe clone it, as it can in fact be the original value\n          // due to the base/copy inversion at the start of this function\n          value: clonePatchValueIfNeeded(copy_[i])\n        });\n        inversePatches.push({\n          op: REPLACE,\n          path,\n          value: clonePatchValueIfNeeded(base_[i])\n        });\n      }\n    }\n    for (let i = base_.length; i < copy_.length; i++) {\n      const path = basePath.concat([i]);\n      patches.push({\n        op: ADD,\n        path,\n        // Need to maybe clone it, as it can in fact be the original value\n        // due to the base/copy inversion at the start of this function\n        value: clonePatchValueIfNeeded(copy_[i])\n      });\n    }\n    for (let i = copy_.length - 1; base_.length <= i; --i) {\n      const path = basePath.concat([i]);\n      inversePatches.push({\n        op: REMOVE,\n        path\n      });\n    }\n  }\n  function generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n    const { base_, copy_ } = state;\n    each(state.assigned_, (key, assignedValue) => {\n      const origValue = get(base_, key);\n      const value = get(copy_, key);\n      const op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD;\n      if (origValue === value && op === REPLACE)\n        return;\n      const path = basePath.concat(key);\n      patches.push(op === REMOVE ? { op, path } : { op, path, value });\n      inversePatches.push(\n        op === ADD ? { op: REMOVE, path } : op === REMOVE ? { op: ADD, path, value: clonePatchValueIfNeeded(origValue) } : { op: REPLACE, path, value: clonePatchValueIfNeeded(origValue) }\n      );\n    });\n  }\n  function generateSetPatches(state, basePath, patches, inversePatches) {\n    let { base_, copy_ } = state;\n    let i = 0;\n    base_.forEach((value) => {\n      if (!copy_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: REMOVE,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: ADD,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n    i = 0;\n    copy_.forEach((value) => {\n      if (!base_.has(value)) {\n        const path = basePath.concat([i]);\n        patches.push({\n          op: ADD,\n          path,\n          value\n        });\n        inversePatches.unshift({\n          op: REMOVE,\n          path,\n          value\n        });\n      }\n      i++;\n    });\n  }\n  function generateReplacementPatches_(baseValue, replacement, patches, inversePatches) {\n    patches.push({\n      op: REPLACE,\n      path: [],\n      value: replacement === NOTHING ? void 0 : replacement\n    });\n    inversePatches.push({\n      op: REPLACE,\n      path: [],\n      value: baseValue\n    });\n  }\n  function applyPatches_(draft, patches) {\n    patches.forEach((patch) => {\n      const { path, op } = patch;\n      let base = draft;\n      for (let i = 0; i < path.length - 1; i++) {\n        const parentType = getArchtype(base);\n        let p = path[i];\n        if (typeof p !== \"string\" && typeof p !== \"number\") {\n          p = \"\" + p;\n        }\n        if ((parentType === 0 /* Object */ || parentType === 1 /* Array */) && (p === \"__proto__\" || p === \"constructor\"))\n          die(errorOffset + 3);\n        if (typeof base === \"function\" && p === \"prototype\")\n          die(errorOffset + 3);\n        base = get(base, p);\n        if (typeof base !== \"object\")\n          die(errorOffset + 2, path.join(\"/\"));\n      }\n      const type = getArchtype(base);\n      const value = deepClonePatchValue(patch.value);\n      const key = path[path.length - 1];\n      switch (op) {\n        case REPLACE:\n          switch (type) {\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              die(errorOffset);\n            default:\n              return base[key] = value;\n          }\n        case ADD:\n          switch (type) {\n            case 1 /* Array */:\n              return key === \"-\" ? base.push(value) : base.splice(key, 0, value);\n            case 2 /* Map */:\n              return base.set(key, value);\n            case 3 /* Set */:\n              return base.add(value);\n            default:\n              return base[key] = value;\n          }\n        case REMOVE:\n          switch (type) {\n            case 1 /* Array */:\n              return base.splice(key, 1);\n            case 2 /* Map */:\n              return base.delete(key);\n            case 3 /* Set */:\n              return base.delete(patch.value);\n            default:\n              return delete base[key];\n          }\n        default:\n          die(errorOffset + 1, op);\n      }\n    });\n    return draft;\n  }\n  function deepClonePatchValue(obj) {\n    if (!isDraftable(obj))\n      return obj;\n    if (Array.isArray(obj))\n      return obj.map(deepClonePatchValue);\n    if (isMap(obj))\n      return new Map(\n        Array.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n      );\n    if (isSet(obj))\n      return new Set(Array.from(obj).map(deepClonePatchValue));\n    const cloned = Object.create(getPrototypeOf(obj));\n    for (const key in obj)\n      cloned[key] = deepClonePatchValue(obj[key]);\n    if (has(obj, DRAFTABLE))\n      cloned[DRAFTABLE] = obj[DRAFTABLE];\n    return cloned;\n  }\n  function clonePatchValueIfNeeded(obj) {\n    if (isDraft(obj)) {\n      return deepClonePatchValue(obj);\n    } else\n      return obj;\n  }\n  loadPlugin(\"Patches\", {\n    applyPatches_,\n    generatePatches_,\n    generateReplacementPatches_\n  });\n}\n\n// src/plugins/mapset.ts\nfunction enableMapSet() {\n  class DraftMap extends Map {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 2 /* Map */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        assigned_: void 0,\n        base_: target,\n        draft_: this,\n        isManual_: false,\n        revoked_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(key) {\n      return latest(this[DRAFT_STATE]).has(key);\n    }\n    set(key, value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!latest(state).has(key) || latest(state).get(key) !== value) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_.set(key, true);\n        state.copy_.set(key, value);\n        state.assigned_.set(key, true);\n      }\n      return this;\n    }\n    delete(key) {\n      if (!this.has(key)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareMapCopy(state);\n      markChanged(state);\n      if (state.base_.has(key)) {\n        state.assigned_.set(key, false);\n      } else {\n        state.assigned_.delete(key);\n      }\n      state.copy_.delete(key);\n      return true;\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareMapCopy(state);\n        markChanged(state);\n        state.assigned_ = /* @__PURE__ */ new Map();\n        each(state.base_, (key) => {\n          state.assigned_.set(key, false);\n        });\n        state.copy_.clear();\n      }\n    }\n    forEach(cb, thisArg) {\n      const state = this[DRAFT_STATE];\n      latest(state).forEach((_value, key, _map) => {\n        cb.call(thisArg, this.get(key), key, this);\n      });\n    }\n    get(key) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      const value = latest(state).get(key);\n      if (state.finalized_ || !isDraftable(value)) {\n        return value;\n      }\n      if (value !== state.base_.get(key)) {\n        return value;\n      }\n      const draft = createProxy(value, state);\n      prepareMapCopy(state);\n      state.copy_.set(key, draft);\n      return draft;\n    }\n    keys() {\n      return latest(this[DRAFT_STATE]).keys();\n    }\n    values() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.values(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value\n          };\n        }\n      };\n    }\n    entries() {\n      const iterator = this.keys();\n      return {\n        [Symbol.iterator]: () => this.entries(),\n        next: () => {\n          const r = iterator.next();\n          if (r.done)\n            return r;\n          const value = this.get(r.value);\n          return {\n            done: false,\n            value: [r.value, value]\n          };\n        }\n      };\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.entries();\n    }\n  }\n  function proxyMap_(target, parent) {\n    return new DraftMap(target, parent);\n  }\n  function prepareMapCopy(state) {\n    if (!state.copy_) {\n      state.assigned_ = /* @__PURE__ */ new Map();\n      state.copy_ = new Map(state.base_);\n    }\n  }\n  class DraftSet extends Set {\n    constructor(target, parent) {\n      super();\n      this[DRAFT_STATE] = {\n        type_: 3 /* Set */,\n        parent_: parent,\n        scope_: parent ? parent.scope_ : getCurrentScope(),\n        modified_: false,\n        finalized_: false,\n        copy_: void 0,\n        base_: target,\n        draft_: this,\n        drafts_: /* @__PURE__ */ new Map(),\n        revoked_: false,\n        isManual_: false\n      };\n    }\n    get size() {\n      return latest(this[DRAFT_STATE]).size;\n    }\n    has(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!state.copy_) {\n        return state.base_.has(value);\n      }\n      if (state.copy_.has(value))\n        return true;\n      if (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n        return true;\n      return false;\n    }\n    add(value) {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (!this.has(value)) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.add(value);\n      }\n      return this;\n    }\n    delete(value) {\n      if (!this.has(value)) {\n        return false;\n      }\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      markChanged(state);\n      return state.copy_.delete(value) || (state.drafts_.has(value) ? state.copy_.delete(state.drafts_.get(value)) : (\n        /* istanbul ignore next */\n        false\n      ));\n    }\n    clear() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      if (latest(state).size) {\n        prepareSetCopy(state);\n        markChanged(state);\n        state.copy_.clear();\n      }\n    }\n    values() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.values();\n    }\n    entries() {\n      const state = this[DRAFT_STATE];\n      assertUnrevoked(state);\n      prepareSetCopy(state);\n      return state.copy_.entries();\n    }\n    keys() {\n      return this.values();\n    }\n    [(DRAFT_STATE, Symbol.iterator)]() {\n      return this.values();\n    }\n    forEach(cb, thisArg) {\n      const iterator = this.values();\n      let result = iterator.next();\n      while (!result.done) {\n        cb.call(thisArg, result.value, result.value, this);\n        result = iterator.next();\n      }\n    }\n  }\n  function proxySet_(target, parent) {\n    return new DraftSet(target, parent);\n  }\n  function prepareSetCopy(state) {\n    if (!state.copy_) {\n      state.copy_ = /* @__PURE__ */ new Set();\n      state.base_.forEach((value) => {\n        if (isDraftable(value)) {\n          const draft = createProxy(value, state);\n          state.drafts_.set(value, draft);\n          state.copy_.add(draft);\n        } else {\n          state.copy_.add(value);\n        }\n      });\n    }\n  }\n  function assertUnrevoked(state) {\n    if (state.revoked_)\n      die(3, JSON.stringify(latest(state)));\n  }\n  loadPlugin(\"MapSet\", { proxyMap_, proxySet_ });\n}\n\n// src/immer.ts\nvar immer = new Immer2();\nvar produce = immer.produce;\nvar produceWithPatches = immer.produceWithPatches.bind(\n  immer\n);\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\nvar setUseStrictShallowCopy = immer.setUseStrictShallowCopy.bind(immer);\nvar applyPatches = immer.applyPatches.bind(immer);\nvar createDraft = immer.createDraft.bind(immer);\nvar finishDraft = immer.finishDraft.bind(immer);\nfunction castDraft(value) {\n  return value;\n}\nfunction castImmutable(value) {\n  return value;\n}\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceMappingURL=immer.cjs.development.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvY2pzL2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw0RkFBNEY7QUFDekg7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQixhQUFhOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBcUM7QUFDbEQ7QUFDQTtBQUNBLDhCQUE4QixPQUFPLGtGQUFrRixPQUFPO0FBQzlILEdBQUc7QUFDSDtBQUNBLGlLQUFpSyxNQUFNO0FBQ3ZLLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsTUFBTTtBQUNwRCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLElBQUksQ0FBRTtBQUNOO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0EsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLE1BQU0sS0FBcUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxtQ0FBbUMsbUJBQW1CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXLElBQUksaUJBQWlCO0FBQ3JFO0FBQ0EsdUJBQXVCLG1CQUFtQixvQkFBb0IsMkRBQTJELElBQUk7QUFDN0g7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sQ0FvQkw7QUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvY2pzL2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcz9hZTIyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2ltbWVyLnRzXG52YXIgaW1tZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW1tZXJfZXhwb3J0cywge1xuICBJbW1lcjogKCkgPT4gSW1tZXIyLFxuICBhcHBseVBhdGNoZXM6ICgpID0+IGFwcGx5UGF0Y2hlcyxcbiAgY2FzdERyYWZ0OiAoKSA9PiBjYXN0RHJhZnQsXG4gIGNhc3RJbW11dGFibGU6ICgpID0+IGNhc3RJbW11dGFibGUsXG4gIGNyZWF0ZURyYWZ0OiAoKSA9PiBjcmVhdGVEcmFmdCxcbiAgY3VycmVudDogKCkgPT4gY3VycmVudCxcbiAgZW5hYmxlTWFwU2V0OiAoKSA9PiBlbmFibGVNYXBTZXQsXG4gIGVuYWJsZVBhdGNoZXM6ICgpID0+IGVuYWJsZVBhdGNoZXMsXG4gIGZpbmlzaERyYWZ0OiAoKSA9PiBmaW5pc2hEcmFmdCxcbiAgZnJlZXplOiAoKSA9PiBmcmVlemUsXG4gIGltbWVyYWJsZTogKCkgPT4gRFJBRlRBQkxFLFxuICBpc0RyYWZ0OiAoKSA9PiBpc0RyYWZ0LFxuICBpc0RyYWZ0YWJsZTogKCkgPT4gaXNEcmFmdGFibGUsXG4gIG5vdGhpbmc6ICgpID0+IE5PVEhJTkcsXG4gIG9yaWdpbmFsOiAoKSA9PiBvcmlnaW5hbCxcbiAgcHJvZHVjZTogKCkgPT4gcHJvZHVjZSxcbiAgcHJvZHVjZVdpdGhQYXRjaGVzOiAoKSA9PiBwcm9kdWNlV2l0aFBhdGNoZXMsXG4gIHNldEF1dG9GcmVlemU6ICgpID0+IHNldEF1dG9GcmVlemUsXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5OiAoKSA9PiBzZXRVc2VTdHJpY3RTaGFsbG93Q29weVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbW1lcl9leHBvcnRzKTtcblxuLy8gc3JjL3V0aWxzL2Vudi50c1xudmFyIE5PVEhJTkcgPSBTeW1ib2wuZm9yKFwiaW1tZXItbm90aGluZ1wiKTtcbnZhciBEUkFGVEFCTEUgPSBTeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpO1xudmFyIERSQUZUX1NUQVRFID0gU3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpO1xuXG4vLyBzcmMvdXRpbHMvZXJyb3JzLnRzXG52YXIgZXJyb3JzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gW1xuICAvLyBBbGwgZXJyb3IgY29kZXMsIHN0YXJ0aW5nIGJ5IDA6XG4gIGZ1bmN0aW9uKHBsdWdpbikge1xuICAgIHJldHVybiBgVGhlIHBsdWdpbiBmb3IgJyR7cGx1Z2lufScgaGFzIG5vdCBiZWVuIGxvYWRlZCBpbnRvIEltbWVyLiBUbyBlbmFibGUgdGhlIHBsdWdpbiwgaW1wb3J0IGFuZCBjYWxsIFxcYGVuYWJsZSR7cGx1Z2lufSgpXFxgIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXIgYXBwbGljYXRpb24uYDtcbiAgfSxcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYHByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJyR7dGhpbmd9J2A7XG4gIH0sXG4gIFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcbiAgZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiBcIkNhbm5vdCB1c2UgYSBwcm94eSB0aGF0IGhhcyBiZWVuIHJldm9rZWQuIERpZCB5b3UgcGFzcyBhbiBvYmplY3QgZnJvbSBpbnNpZGUgYW4gaW1tZXIgZnVuY3Rpb24gdG8gYW4gYXN5bmMgcHJvY2Vzcz8gXCIgKyBkYXRhO1xuICB9LFxuICBcIkFuIGltbWVyIHByb2R1Y2VyIHJldHVybmVkIGEgbmV3IHZhbHVlICphbmQqIG1vZGlmaWVkIGl0cyBkcmFmdC4gRWl0aGVyIHJldHVybiBhIG5ldyB2YWx1ZSAqb3IqIG1vZGlmeSB0aGUgZHJhZnQuXCIsXG4gIFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXG4gIFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gIFwiVGhlIHRoaXJkIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXCIsXG4gIFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxuICBcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcbiAgZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gO1xuICB9LFxuICBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG4gIFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcbiAgXCJJbW1lciBvbmx5IHN1cHBvcnRzIGRlbGV0aW5nIGFycmF5IGluZGljZXNcIixcbiAgXCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXG4gIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIGAnb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWA7XG4gIH1cbiAgLy8gTm90ZTogaWYgbW9yZSBlcnJvcnMgYXJlIGFkZGVkLCB0aGUgZXJyb3JPZmZzZXQgaW4gUGF0Y2hlcy50cyBzaG91bGQgYmUgaW5jcmVhc2VkXG4gIC8vIFNlZSBQYXRjaGVzLnRzIGZvciBhZGRpdGlvbmFsIGVycm9yc1xuXSA6IFtdO1xuZnVuY3Rpb24gZGllKGVycm9yLCAuLi5hcmdzKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zdCBlID0gZXJyb3JzW2Vycm9yXTtcbiAgICBjb25zdCBtc2cgPSB0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiID8gZS5hcHBseShudWxsLCBhcmdzKSA6IGU7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbSW1tZXJdICR7bXNnfWApO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBgW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogJHtlcnJvcn0uIEZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZgXG4gICk7XG59XG5cbi8vIHNyYy91dGlscy9jb21tb24udHNcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbmZ1bmN0aW9uIGlzRHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgISF2YWx1ZVtEUkFGVF9TVEFURV07XG59XG5mdW5jdGlvbiBpc0RyYWZ0YWJsZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8ICEhdmFsdWVbRFJBRlRBQkxFXSB8fCAhIXZhbHVlLmNvbnN0cnVjdG9yPy5bRFJBRlRBQkxFXSB8fCBpc01hcCh2YWx1ZSkgfHwgaXNTZXQodmFsdWUpO1xufVxudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY29uc3QgcHJvdG8gPSBnZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IEN0b3IgPSBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgXCJjb25zdHJ1Y3RvclwiKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgaWYgKEN0b3IgPT09IE9iamVjdClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBGdW5jdGlvbi50b1N0cmluZy5jYWxsKEN0b3IpID09PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuZnVuY3Rpb24gb3JpZ2luYWwodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcbiAgICBkaWUoMTUsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlW0RSQUZUX1NUQVRFXS5iYXNlXztcbn1cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyKSB7XG4gIGlmIChnZXRBcmNodHlwZShvYmopID09PSAwIC8qIE9iamVjdCAqLykge1xuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpdGVyKGtleSwgdmFsdWUsIG9iaik7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqLmZvckVhY2goKGVudHJ5LCBpbmRleCkgPT4gaXRlcihpbmRleCwgZW50cnksIG9iaikpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRBcmNodHlwZSh0aGluZykge1xuICBjb25zdCBzdGF0ZSA9IHRoaW5nW0RSQUZUX1NUQVRFXTtcbiAgcmV0dXJuIHN0YXRlID8gc3RhdGUudHlwZV8gOiBBcnJheS5pc0FycmF5KHRoaW5nKSA/IDEgLyogQXJyYXkgKi8gOiBpc01hcCh0aGluZykgPyAyIC8qIE1hcCAqLyA6IGlzU2V0KHRoaW5nKSA/IDMgLyogU2V0ICovIDogMCAvKiBPYmplY3QgKi87XG59XG5mdW5jdGlvbiBoYXModGhpbmcsIHByb3ApIHtcbiAgcmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gMiAvKiBNYXAgKi8gPyB0aGluZy5oYXMocHJvcCkgOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApO1xufVxuZnVuY3Rpb24gZ2V0KHRoaW5nLCBwcm9wKSB7XG4gIHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IDIgLyogTWFwICovID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF07XG59XG5mdW5jdGlvbiBzZXQodGhpbmcsIHByb3BPck9sZFZhbHVlLCB2YWx1ZSkge1xuICBjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpO1xuICBpZiAodCA9PT0gMiAvKiBNYXAgKi8pXG4gICAgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSk7XG4gIGVsc2UgaWYgKHQgPT09IDMgLyogU2V0ICovKSB7XG4gICAgdGhpbmcuYWRkKHZhbHVlKTtcbiAgfSBlbHNlXG4gICAgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWU7XG59XG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFwKHRhcmdldCkge1xuICByZXR1cm4gdGFyZ2V0IGluc3RhbmNlb2YgTWFwO1xufVxuZnVuY3Rpb24gaXNTZXQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBTZXQ7XG59XG5mdW5jdGlvbiBsYXRlc3Qoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfO1xufVxuZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZSwgc3RyaWN0KSB7XG4gIGlmIChpc01hcChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgTWFwKGJhc2UpO1xuICB9XG4gIGlmIChpc1NldChiYXNlKSkge1xuICAgIHJldHVybiBuZXcgU2V0KGJhc2UpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGJhc2UpKVxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlKTtcbiAgaWYgKCFzdHJpY3QgJiYgaXNQbGFpbk9iamVjdChiYXNlKSkge1xuICAgIGlmICghZ2V0UHJvdG90eXBlT2YoYmFzZSkpIHtcbiAgICAgIGNvbnN0IG9iaiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ob2JqLCBiYXNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uYmFzZSB9O1xuICB9XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSk7XG4gIGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURV07XG4gIGxldCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKGRlc2NyaXB0b3JzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XTtcbiAgICBpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgIGRlc2Mud3JpdGFibGUgPSB0cnVlO1xuICAgICAgZGVzYy5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpXG4gICAgICBkZXNjcmlwdG9yc1trZXldID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAvLyBjb3VsZCBsaXZlIHdpdGggISFkZXNjLnNldCBhcyB3ZWxsIGhlcmUuLi5cbiAgICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICB2YWx1ZTogYmFzZVtrZXldXG4gICAgICB9O1xuICB9XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycyk7XG59XG5mdW5jdGlvbiBmcmVlemUob2JqLCBkZWVwID0gZmFsc2UpIHtcbiAgaWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKVxuICAgIHJldHVybiBvYmo7XG4gIGlmIChnZXRBcmNodHlwZShvYmopID4gMSkge1xuICAgIG9iai5zZXQgPSBvYmouYWRkID0gb2JqLmNsZWFyID0gb2JqLmRlbGV0ZSA9IGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucztcbiAgfVxuICBPYmplY3QuZnJlZXplKG9iaik7XG4gIGlmIChkZWVwKVxuICAgIGVhY2gob2JqLCAoX2tleSwgdmFsdWUpID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSksIHRydWUpO1xuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zKCkge1xuICBkaWUoMik7XG59XG5mdW5jdGlvbiBpc0Zyb3plbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5pc0Zyb3plbihvYmopO1xufVxuXG4vLyBzcmMvdXRpbHMvcGx1Z2lucy50c1xudmFyIHBsdWdpbnMgPSB7fTtcbmZ1bmN0aW9uIGdldFBsdWdpbihwbHVnaW5LZXkpIHtcbiAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1twbHVnaW5LZXldO1xuICBpZiAoIXBsdWdpbikge1xuICAgIGRpZSgwLCBwbHVnaW5LZXkpO1xuICB9XG4gIHJldHVybiBwbHVnaW47XG59XG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbktleSwgaW1wbGVtZW50YXRpb24pIHtcbiAgaWYgKCFwbHVnaW5zW3BsdWdpbktleV0pXG4gICAgcGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb247XG59XG5cbi8vIHNyYy9jb3JlL3Njb3BlLnRzXG52YXIgY3VycmVudFNjb3BlO1xuZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuICByZXR1cm4gY3VycmVudFNjb3BlO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NvcGUocGFyZW50XywgaW1tZXJfKSB7XG4gIHJldHVybiB7XG4gICAgZHJhZnRzXzogW10sXG4gICAgcGFyZW50XyxcbiAgICBpbW1lcl8sXG4gICAgLy8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuICAgIC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG4gICAgY2FuQXV0b0ZyZWV6ZV86IHRydWUsXG4gICAgdW5maW5hbGl6ZWREcmFmdHNfOiAwXG4gIH07XG59XG5mdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcikge1xuICBpZiAocGF0Y2hMaXN0ZW5lcikge1xuICAgIGdldFBsdWdpbihcIlBhdGNoZXNcIik7XG4gICAgc2NvcGUucGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXTtcbiAgICBzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldm9rZVNjb3BlKHNjb3BlKSB7XG4gIGxlYXZlU2NvcGUoc2NvcGUpO1xuICBzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpO1xuICBzY29wZS5kcmFmdHNfID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGUpIHtcbiAgaWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcbiAgICBjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfO1xuICB9XG59XG5mdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyMikge1xuICByZXR1cm4gY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcjIpO1xufVxuZnVuY3Rpb24gcmV2b2tlRHJhZnQoZHJhZnQpIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGlmIChzdGF0ZS50eXBlXyA9PT0gMCAvKiBPYmplY3QgKi8gfHwgc3RhdGUudHlwZV8gPT09IDEgLyogQXJyYXkgKi8pXG4gICAgc3RhdGUucmV2b2tlXygpO1xuICBlbHNlXG4gICAgc3RhdGUucmV2b2tlZF8gPSB0cnVlO1xufVxuXG4vLyBzcmMvY29yZS9maW5hbGl6ZS50c1xuZnVuY3Rpb24gcHJvY2Vzc1Jlc3VsdChyZXN1bHQsIHNjb3BlKSB7XG4gIHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoO1xuICBjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfWzBdO1xuICBjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB2b2lkIDAgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnQ7XG4gIGlmIChpc1JlcGxhY2VkKSB7XG4gICAgaWYgKGJhc2VEcmFmdFtEUkFGVF9TVEFURV0ubW9kaWZpZWRfKSB7XG4gICAgICByZXZva2VTY29wZShzY29wZSk7XG4gICAgICBkaWUoNCk7XG4gICAgfVxuICAgIGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG4gICAgICByZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KTtcbiAgICAgIGlmICghc2NvcGUucGFyZW50XylcbiAgICAgICAgbWF5YmVGcmVlemUoc2NvcGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChzY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG4gICAgICAgIGJhc2VEcmFmdFtEUkFGVF9TVEFURV0uYmFzZV8sXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgc2NvcGUucGF0Y2hlc18sXG4gICAgICAgIHNjb3BlLmludmVyc2VQYXRjaGVzX1xuICAgICAgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pO1xuICB9XG4gIHJldm9rZVNjb3BlKHNjb3BlKTtcbiAgaWYgKHNjb3BlLnBhdGNoZXNfKSB7XG4gICAgc2NvcGUucGF0Y2hMaXN0ZW5lcl8oc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZSwgdmFsdWUsIHBhdGgpIHtcbiAgaWYgKGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBpZiAoIXN0YXRlKSB7XG4gICAgZWFjaChcbiAgICAgIHZhbHVlLFxuICAgICAgKGtleSwgY2hpbGRWYWx1ZSkgPT4gZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKSxcbiAgICAgIHRydWVcbiAgICAgIC8vIFNlZSAjNTkwLCBkb24ndCByZWN1cnNlIGludG8gbm9uLWVudW1lcmFibGUgb2Ygbm9uIGRyYWZ0ZWQgb2JqZWN0c1xuICAgICk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChzdGF0ZS5zY29wZV8gIT09IHJvb3RTY29wZSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG4gICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmJhc2VfO1xuICB9XG4gIGlmICghc3RhdGUuZmluYWxpemVkXykge1xuICAgIHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlO1xuICAgIHN0YXRlLnNjb3BlXy51bmZpbmFsaXplZERyYWZ0c18tLTtcbiAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5jb3B5XztcbiAgICBsZXQgcmVzdWx0RWFjaCA9IHJlc3VsdDtcbiAgICBsZXQgaXNTZXQyID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlLnR5cGVfID09PSAzIC8qIFNldCAqLykge1xuICAgICAgcmVzdWx0RWFjaCA9IG5ldyBTZXQocmVzdWx0KTtcbiAgICAgIHJlc3VsdC5jbGVhcigpO1xuICAgICAgaXNTZXQyID0gdHJ1ZTtcbiAgICB9XG4gICAgZWFjaChcbiAgICAgIHJlc3VsdEVhY2gsXG4gICAgICAoa2V5LCBjaGlsZFZhbHVlKSA9PiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoLCBpc1NldDIpXG4gICAgKTtcbiAgICBtYXliZUZyZWV6ZShyb290U2NvcGUsIHJlc3VsdCwgZmFsc2UpO1xuICAgIGlmIChwYXRoICYmIHJvb3RTY29wZS5wYXRjaGVzXykge1xuICAgICAgZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVBhdGNoZXNfKFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcm9vdFNjb3BlLnBhdGNoZXNfLFxuICAgICAgICByb290U2NvcGUuaW52ZXJzZVBhdGNoZXNfXG4gICAgICApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGUuY29weV87XG59XG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgcGFyZW50U3RhdGUsIHRhcmdldE9iamVjdCwgcHJvcCwgY2hpbGRWYWx1ZSwgcm9vdFBhdGgsIHRhcmdldElzU2V0KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KVxuICAgIGRpZSg1KTtcbiAgaWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcbiAgICBjb25zdCBwYXRoID0gcm9vdFBhdGggJiYgcGFyZW50U3RhdGUgJiYgcGFyZW50U3RhdGUudHlwZV8gIT09IDMgLyogU2V0ICovICYmIC8vIFNldCBvYmplY3RzIGFyZSBhdG9taWMgc2luY2UgdGhleSBoYXZlIG5vIGtleXMuXG4gICAgIWhhcyhwYXJlbnRTdGF0ZS5hc3NpZ25lZF8sIHByb3ApID8gcm9vdFBhdGguY29uY2F0KHByb3ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aCk7XG4gICAgc2V0KHRhcmdldE9iamVjdCwgcHJvcCwgcmVzKTtcbiAgICBpZiAoaXNEcmFmdChyZXMpKSB7XG4gICAgICByb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0YXJnZXRJc1NldCkge1xuICAgIHRhcmdldE9iamVjdC5hZGQoY2hpbGRWYWx1ZSk7XG4gIH1cbiAgaWYgKGlzRHJhZnRhYmxlKGNoaWxkVmFsdWUpICYmICFpc0Zyb3plbihjaGlsZFZhbHVlKSkge1xuICAgIGlmICghcm9vdFNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiByb290U2NvcGUudW5maW5hbGl6ZWREcmFmdHNfIDwgMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpO1xuICAgIGlmICghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKVxuICAgICAgbWF5YmVGcmVlemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVGcmVlemUoc2NvcGUsIHZhbHVlLCBkZWVwID0gZmFsc2UpIHtcbiAgaWYgKCFzY29wZS5wYXJlbnRfICYmIHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xuICAgIGZyZWV6ZSh2YWx1ZSwgZGVlcCk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvcHJveHkudHNcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHkoYmFzZSwgcGFyZW50KSB7XG4gIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpO1xuICBjb25zdCBzdGF0ZSA9IHtcbiAgICB0eXBlXzogaXNBcnJheSA/IDEgLyogQXJyYXkgKi8gOiAwIC8qIE9iamVjdCAqLyxcbiAgICAvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgLy8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXG4gICAgbW9kaWZpZWRfOiBmYWxzZSxcbiAgICAvLyBVc2VkIGR1cmluZyBmaW5hbGl6YXRpb24uXG4gICAgZmluYWxpemVkXzogZmFsc2UsXG4gICAgLy8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cbiAgICBhc3NpZ25lZF86IHt9LFxuICAgIC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG4gICAgcGFyZW50XzogcGFyZW50LFxuICAgIC8vIFRoZSBiYXNlIHN0YXRlLlxuICAgIGJhc2VfOiBiYXNlLFxuICAgIC8vIFRoZSBiYXNlIHByb3h5LlxuICAgIGRyYWZ0XzogbnVsbCxcbiAgICAvLyBzZXQgYmVsb3dcbiAgICAvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuICAgIGNvcHlfOiBudWxsLFxuICAgIC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuICAgIHJldm9rZV86IG51bGwsXG4gICAgaXNNYW51YWxfOiBmYWxzZVxuICB9O1xuICBsZXQgdGFyZ2V0ID0gc3RhdGU7XG4gIGxldCB0cmFwcyA9IG9iamVjdFRyYXBzO1xuICBpZiAoaXNBcnJheSkge1xuICAgIHRhcmdldCA9IFtzdGF0ZV07XG4gICAgdHJhcHMgPSBhcnJheVRyYXBzO1xuICB9XG4gIGNvbnN0IHsgcmV2b2tlLCBwcm94eSB9ID0gUHJveHkucmV2b2NhYmxlKHRhcmdldCwgdHJhcHMpO1xuICBzdGF0ZS5kcmFmdF8gPSBwcm94eTtcbiAgc3RhdGUucmV2b2tlXyA9IHJldm9rZTtcbiAgcmV0dXJuIHByb3h5O1xufVxudmFyIG9iamVjdFRyYXBzID0ge1xuICBnZXQoc3RhdGUsIHByb3ApIHtcbiAgICBpZiAocHJvcCA9PT0gRFJBRlRfU1RBVEUpXG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgY29uc3Qgc291cmNlID0gbGF0ZXN0KHN0YXRlKTtcbiAgICBpZiAoIWhhcyhzb3VyY2UsIHByb3ApKSB7XG4gICAgICByZXR1cm4gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCk7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc291cmNlW3Byb3BdO1xuICAgIGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgcmV0dXJuIHN0YXRlLmNvcHlfW3Byb3BdID0gY3JlYXRlUHJveHkodmFsdWUsIHN0YXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuICBoYXMoc3RhdGUsIHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCBpbiBsYXRlc3Qoc3RhdGUpO1xuICB9LFxuICBvd25LZXlzKHN0YXRlKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKTtcbiAgfSxcbiAgc2V0KHN0YXRlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApO1xuICAgIGlmIChkZXNjPy5zZXQpIHtcbiAgICAgIGRlc2Muc2V0LmNhbGwoc3RhdGUuZHJhZnRfLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQyID0gcGVlayhsYXRlc3Qoc3RhdGUpLCBwcm9wKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnQyPy5bRFJBRlRfU1RBVEVdO1xuICAgICAgaWYgKGN1cnJlbnRTdGF0ZSAmJiBjdXJyZW50U3RhdGUuYmFzZV8gPT09IHZhbHVlKSB7XG4gICAgICAgIHN0YXRlLmNvcHlfW3Byb3BdID0gdmFsdWU7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpcyh2YWx1ZSwgY3VycmVudDIpICYmICh2YWx1ZSAhPT0gdm9pZCAwIHx8IGhhcyhzdGF0ZS5iYXNlXywgcHJvcCkpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIHByZXBhcmVDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLmNvcHlfW3Byb3BdID09PSB2YWx1ZSAmJiAvLyBzcGVjaWFsIGNhc2U6IGhhbmRsZSBuZXcgcHJvcHMgd2l0aCB2YWx1ZSAndW5kZWZpbmVkJ1xuICAgICh2YWx1ZSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuY29weV8pIHx8IC8vIHNwZWNpYWwgY2FzZTogTmFOXG4gICAgTnVtYmVyLmlzTmFOKHZhbHVlKSAmJiBOdW1iZXIuaXNOYU4oc3RhdGUuY29weV9bcHJvcF0pKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgc3RhdGUuY29weV9bcHJvcF0gPSB2YWx1ZTtcbiAgICBzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCkge1xuICAgIGlmIChwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSAhPT0gdm9pZCAwIHx8IHByb3AgaW4gc3RhdGUuYmFzZV8pIHtcbiAgICAgIHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IGZhbHNlO1xuICAgICAgcHJlcGFyZUNvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdO1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29weV8pIHtcbiAgICAgIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG4gIC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG4gIC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG4gICAgY29uc3Qgb3duZXIgPSBsYXRlc3Qoc3RhdGUpO1xuICAgIGNvbnN0IGRlc2MgPSBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvd25lciwgcHJvcCk7XG4gICAgaWYgKCFkZXNjKVxuICAgICAgcmV0dXJuIGRlc2M7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiBzdGF0ZS50eXBlXyAhPT0gMSAvKiBBcnJheSAqLyB8fCBwcm9wICE9PSBcImxlbmd0aFwiLFxuICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgdmFsdWU6IG93bmVyW3Byb3BdXG4gICAgfTtcbiAgfSxcbiAgZGVmaW5lUHJvcGVydHkoKSB7XG4gICAgZGllKDExKTtcbiAgfSxcbiAgZ2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcbiAgICByZXR1cm4gZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pO1xuICB9LFxuICBzZXRQcm90b3R5cGVPZigpIHtcbiAgICBkaWUoMTIpO1xuICB9XG59O1xudmFyIGFycmF5VHJhcHMgPSB7fTtcbmVhY2gob2JqZWN0VHJhcHMsIChrZXksIGZuKSA9PiB7XG4gIGFycmF5VHJhcHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuICAgIGFyZ3VtZW50c1swXSA9IGFyZ3VtZW50c1swXVswXTtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0pO1xuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCkpKVxuICAgIGRpZSgxMyk7XG4gIHJldHVybiBhcnJheVRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlLCBwcm9wLCB2b2lkIDApO1xufTtcbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcHJvcCAhPT0gXCJsZW5ndGhcIiAmJiBpc05hTihwYXJzZUludChwcm9wKSkpXG4gICAgZGllKDE0KTtcbiAgcmV0dXJuIG9iamVjdFRyYXBzLnNldC5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pO1xufTtcbmZ1bmN0aW9uIHBlZWsoZHJhZnQsIHByb3ApIHtcbiAgY29uc3Qgc3RhdGUgPSBkcmFmdFtEUkFGVF9TVEFURV07XG4gIGNvbnN0IHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0O1xuICByZXR1cm4gc291cmNlW3Byb3BdO1xufVxuZnVuY3Rpb24gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGUsIHNvdXJjZSwgcHJvcCkge1xuICBjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApO1xuICByZXR1cm4gZGVzYyA/IGB2YWx1ZWAgaW4gZGVzYyA/IGRlc2MudmFsdWUgOiAoXG4gICAgLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuICAgIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxuICAgIGRlc2MuZ2V0Py5jYWxsKHN0YXRlLmRyYWZ0XylcbiAgKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKSB7XG4gIGlmICghKHByb3AgaW4gc291cmNlKSlcbiAgICByZXR1cm4gdm9pZCAwO1xuICBsZXQgcHJvdG8gPSBnZXRQcm90b3R5cGVPZihzb3VyY2UpO1xuICB3aGlsZSAocHJvdG8pIHtcbiAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcCk7XG4gICAgaWYgKGRlc2MpXG4gICAgICByZXR1cm4gZGVzYztcbiAgICBwcm90byA9IGdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gbWFya0NoYW5nZWQoc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcbiAgICBzdGF0ZS5tb2RpZmllZF8gPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5wYXJlbnRfKSB7XG4gICAgICBtYXJrQ2hhbmdlZChzdGF0ZS5wYXJlbnRfKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlKSB7XG4gIGlmICghc3RhdGUuY29weV8pIHtcbiAgICBzdGF0ZS5jb3B5XyA9IHNoYWxsb3dDb3B5KFxuICAgICAgc3RhdGUuYmFzZV8sXG4gICAgICBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5X1xuICAgICk7XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvaW1tZXJDbGFzcy50c1xudmFyIEltbWVyMiA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5hdXRvRnJlZXplXyA9IHRydWU7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2VcbiAgICAgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAgICAgKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAgICAgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuICAgICAqXG4gICAgICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gICAgICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cbiAgICAgKlxuICAgICAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICAgICAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlY2lwZSAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAgICAgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAgICAgKi9cbiAgICB0aGlzLnByb2R1Y2UgPSAoYmFzZSwgcmVjaXBlLCBwYXRjaExpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdEJhc2UgPSByZWNpcGU7XG4gICAgICAgIHJlY2lwZSA9IGJhc2U7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoYmFzZTIgPSBkZWZhdWx0QmFzZSwgLi4uYXJncykge1xuICAgICAgICAgIHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZTIsIChkcmFmdCkgPT4gcmVjaXBlLmNhbGwodGhpcywgZHJhZnQsIC4uLmFyZ3MpKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGRpZSg2KTtcbiAgICAgIGlmIChwYXRjaExpc3RlbmVyICE9PSB2b2lkIDAgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZGllKDcpO1xuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGlmIChpc0RyYWZ0YWJsZShiYXNlKSkge1xuICAgICAgICBjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcyk7XG4gICAgICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXN1bHQgPSByZWNpcGUocHJveHkpO1xuICAgICAgICAgIGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGhhc0Vycm9yKVxuICAgICAgICAgICAgcmV2b2tlU2NvcGUoc2NvcGUpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxlYXZlU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlY2lwZShiYXNlKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKVxuICAgICAgICAgIHJlc3VsdCA9IGJhc2U7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IE5PVEhJTkcpXG4gICAgICAgICAgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBpZiAodGhpcy5hdXRvRnJlZXplXylcbiAgICAgICAgICBmcmVlemUocmVzdWx0LCB0cnVlKTtcbiAgICAgICAgaWYgKHBhdGNoTGlzdGVuZXIpIHtcbiAgICAgICAgICBjb25zdCBwID0gW107XG4gICAgICAgICAgY29uc3QgaXAgPSBbXTtcbiAgICAgICAgICBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhiYXNlLCByZXN1bHQsIHAsIGlwKTtcbiAgICAgICAgICBwYXRjaExpc3RlbmVyKHAsIGlwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSBlbHNlXG4gICAgICAgIGRpZSgxLCBiYXNlKTtcbiAgICB9O1xuICAgIHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gKGJhc2UsIHJlY2lwZSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIChzdGF0ZSwgLi4uYXJncykgPT4gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdCkgPT4gYmFzZShkcmFmdCwgLi4uYXJncykpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdGNoZXMsIGludmVyc2VQYXRjaGVzO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm9kdWNlKGJhc2UsIHJlY2lwZSwgKHAsIGlwKSA9PiB7XG4gICAgICAgIHBhdGNoZXMgPSBwO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcyA9IGlwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gW3Jlc3VsdCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdO1xuICAgIH07XG4gICAgaWYgKHR5cGVvZiBjb25maWc/LmF1dG9GcmVlemUgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZy5hdXRvRnJlZXplKTtcbiAgICBpZiAodHlwZW9mIGNvbmZpZz8udXNlU3RyaWN0U2hhbGxvd0NvcHkgPT09IFwiYm9vbGVhblwiKVxuICAgICAgdGhpcy5zZXRVc2VTdHJpY3RTaGFsbG93Q29weShjb25maWcudXNlU3RyaWN0U2hhbGxvd0NvcHkpO1xuICB9XG4gIGNyZWF0ZURyYWZ0KGJhc2UpIHtcbiAgICBpZiAoIWlzRHJhZnRhYmxlKGJhc2UpKVxuICAgICAgZGllKDgpO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKVxuICAgICAgYmFzZSA9IGN1cnJlbnQoYmFzZSk7XG4gICAgY29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpO1xuICAgIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoYmFzZSwgdm9pZCAwKTtcbiAgICBwcm94eVtEUkFGVF9TVEFURV0uaXNNYW51YWxfID0gdHJ1ZTtcbiAgICBsZWF2ZVNjb3BlKHNjb3BlKTtcbiAgICByZXR1cm4gcHJveHk7XG4gIH1cbiAgZmluaXNoRHJhZnQoZHJhZnQsIHBhdGNoTGlzdGVuZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IGRyYWZ0ICYmIGRyYWZ0W0RSQUZUX1NUQVRFXTtcbiAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pXG4gICAgICBkaWUoOSk7XG4gICAgY29uc3QgeyBzY29wZV86IHNjb3BlIH0gPSBzdGF0ZTtcbiAgICB1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcik7XG4gICAgcmV0dXJuIHByb2Nlc3NSZXN1bHQodm9pZCAwLCBzY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZW5hYmxlZC5cbiAgICovXG4gIHNldEF1dG9GcmVlemUodmFsdWUpIHtcbiAgICB0aGlzLmF1dG9GcmVlemVfID0gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFBhc3MgdHJ1ZSB0byBlbmFibGUgc3RyaWN0IHNoYWxsb3cgY29weS5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgaW1tZXIgZG9lcyBub3QgY29weSB0aGUgb2JqZWN0IGRlc2NyaXB0b3JzIHN1Y2ggYXMgZ2V0dGVyLCBzZXR0ZXIgYW5kIG5vbi1lbnVtcmFibGUgcHJvcGVydGllcy5cbiAgICovXG4gIHNldFVzZVN0cmljdFNoYWxsb3dDb3B5KHZhbHVlKSB7XG4gICAgdGhpcy51c2VTdHJpY3RTaGFsbG93Q29weV8gPSB2YWx1ZTtcbiAgfVxuICBhcHBseVBhdGNoZXMoYmFzZSwgcGF0Y2hlcykge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHBhdGNoID0gcGF0Y2hlc1tpXTtcbiAgICAgIGlmIChwYXRjaC5wYXRoLmxlbmd0aCA9PT0gMCAmJiBwYXRjaC5vcCA9PT0gXCJyZXBsYWNlXCIpIHtcbiAgICAgICAgYmFzZSA9IHBhdGNoLnZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPiAtMSkge1xuICAgICAgcGF0Y2hlcyA9IHBhdGNoZXMuc2xpY2UoaSArIDEpO1xuICAgIH1cbiAgICBjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfO1xuICAgIGlmIChpc0RyYWZ0KGJhc2UpKSB7XG4gICAgICByZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvZHVjZShcbiAgICAgIGJhc2UsXG4gICAgICAoZHJhZnQpID0+IGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVByb3h5KHZhbHVlLCBwYXJlbnQpIHtcbiAgY29uc3QgZHJhZnQgPSBpc01hcCh2YWx1ZSkgPyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlNYXBfKHZhbHVlLCBwYXJlbnQpIDogaXNTZXQodmFsdWUpID8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KSA6IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudCk7XG4gIGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpO1xuICBzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpO1xuICByZXR1cm4gZHJhZnQ7XG59XG5cbi8vIHNyYy9jb3JlL2N1cnJlbnQudHNcbmZ1bmN0aW9uIGN1cnJlbnQodmFsdWUpIHtcbiAgaWYgKCFpc0RyYWZ0KHZhbHVlKSlcbiAgICBkaWUoMTAsIHZhbHVlKTtcbiAgcmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGN1cnJlbnRJbXBsKHZhbHVlKSB7XG4gIGlmICghaXNEcmFmdGFibGUodmFsdWUpIHx8IGlzRnJvemVuKHZhbHVlKSlcbiAgICByZXR1cm4gdmFsdWU7XG4gIGNvbnN0IHN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdO1xuICBsZXQgY29weTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5tb2RpZmllZF8pXG4gICAgICByZXR1cm4gc3RhdGUuYmFzZV87XG4gICAgc3RhdGUuZmluYWxpemVkXyA9IHRydWU7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCBzdGF0ZS5zY29wZV8uaW1tZXJfLnVzZVN0cmljdFNoYWxsb3dDb3B5Xyk7XG4gIH0gZWxzZSB7XG4gICAgY29weSA9IHNoYWxsb3dDb3B5KHZhbHVlLCB0cnVlKTtcbiAgfVxuICBlYWNoKGNvcHksIChrZXksIGNoaWxkVmFsdWUpID0+IHtcbiAgICBzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSk7XG4gIH0pO1xuICBpZiAoc3RhdGUpIHtcbiAgICBzdGF0ZS5maW5hbGl6ZWRfID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL3BhdGNoZXMudHNcbmZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XG4gIGNvbnN0IGVycm9yT2Zmc2V0ID0gMTY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgICdTZXRzIGNhbm5vdCBoYXZlIFwicmVwbGFjZVwiIHBhdGNoZXMuJyxcbiAgICAgIGZ1bmN0aW9uKG9wKSB7XG4gICAgICAgIHJldHVybiBcIlVuc3VwcG9ydGVkIHBhdGNoIG9wZXJhdGlvbjogXCIgKyBvcDtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aDtcbiAgICAgIH0sXG4gICAgICBcIlBhdGNoaW5nIHJlc2VydmVkIGF0dHJpYnV0ZXMgbGlrZSBfX3Byb3RvX18sIHByb3RvdHlwZSBhbmQgY29uc3RydWN0b3IgaXMgbm90IGFsbG93ZWRcIlxuICAgICk7XG4gIH1cbiAgY29uc3QgUkVQTEFDRSA9IFwicmVwbGFjZVwiO1xuICBjb25zdCBBREQgPSBcImFkZFwiO1xuICBjb25zdCBSRU1PVkUgPSBcInJlbW92ZVwiO1xuICBmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG4gICAgICBjYXNlIDAgLyogT2JqZWN0ICovOlxuICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcbiAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICBiYXNlUGF0aCxcbiAgICAgICAgICBwYXRjaGVzLFxuICAgICAgICAgIGludmVyc2VQYXRjaGVzXG4gICAgICAgICk7XG4gICAgICBjYXNlIDEgLyogQXJyYXkgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKTtcbiAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoXG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgYmFzZVBhdGgsXG4gICAgICAgICAgcGF0Y2hlcyxcbiAgICAgICAgICBpbnZlcnNlUGF0Y2hlc1xuICAgICAgICApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGFzc2lnbmVkXyB9ID0gc3RhdGU7XG4gICAgbGV0IGNvcHlfID0gc3RhdGUuY29weV87XG4gICAgaWYgKGNvcHlfLmxlbmd0aCA8IGJhc2VfLmxlbmd0aCkge1xuICAgICAgO1xuICAgICAgW2Jhc2VfLCBjb3B5X10gPSBbY29weV8sIGJhc2VfXTtcbiAgICAgIFtwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2VfLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXNzaWduZWRfW2ldICYmIGNvcHlfW2ldICE9PSBiYXNlX1tpXSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICAvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgICAgICAgICAvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBvcDogUkVQTEFDRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBjb3B5Xy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pO1xuICAgICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgICAgb3A6IEFERCxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgLy8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG4gICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IGNvcHlfLmxlbmd0aCAtIDE7IGJhc2VfLmxlbmd0aCA8PSBpOyAtLWkpIHtcbiAgICAgIGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICBwYXRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpIHtcbiAgICBjb25zdCB7IGJhc2VfLCBjb3B5XyB9ID0gc3RhdGU7XG4gICAgZWFjaChzdGF0ZS5hc3NpZ25lZF8sIChrZXksIGFzc2lnbmVkVmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gZ2V0KGNvcHlfLCBrZXkpO1xuICAgICAgY29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBREQ7XG4gICAgICBpZiAob3JpZ1ZhbHVlID09PSB2YWx1ZSAmJiBvcCA9PT0gUkVQTEFDRSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkpO1xuICAgICAgcGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7IG9wLCBwYXRoIH0gOiB7IG9wLCBwYXRoLCB2YWx1ZSB9KTtcbiAgICAgIGludmVyc2VQYXRjaGVzLnB1c2goXG4gICAgICAgIG9wID09PSBBREQgPyB7IG9wOiBSRU1PVkUsIHBhdGggfSA6IG9wID09PSBSRU1PVkUgPyB7IG9wOiBBREQsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpIH0gOiB7IG9wOiBSRVBMQUNFLCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKSB9XG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgbGV0IHsgYmFzZV8sIGNvcHlfIH0gPSBzdGF0ZTtcbiAgICBsZXQgaSA9IDA7XG4gICAgYmFzZV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmICghY29weV8uaGFzKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IFJFTU9WRSxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogQURELFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSk7XG4gICAgaSA9IDA7XG4gICAgY29weV8uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSk7XG4gICAgICAgIHBhdGNoZXMucHVzaCh7XG4gICAgICAgICAgb3A6IEFERCxcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcbiAgICAgICAgICBvcDogUkVNT1ZFLFxuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKGJhc2VWYWx1ZSwgcmVwbGFjZW1lbnQsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5wdXNoKHtcbiAgICAgIG9wOiBSRVBMQUNFLFxuICAgICAgcGF0aDogW10sXG4gICAgICB2YWx1ZTogcmVwbGFjZW1lbnQgPT09IE5PVEhJTkcgPyB2b2lkIDAgOiByZXBsYWNlbWVudFxuICAgIH0pO1xuICAgIGludmVyc2VQYXRjaGVzLnB1c2goe1xuICAgICAgb3A6IFJFUExBQ0UsXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHZhbHVlOiBiYXNlVmFsdWVcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVBhdGNoZXNfKGRyYWZ0LCBwYXRjaGVzKSB7XG4gICAgcGF0Y2hlcy5mb3JFYWNoKChwYXRjaCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRoLCBvcCB9ID0gcGF0Y2g7XG4gICAgICBsZXQgYmFzZSA9IGRyYWZ0O1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJlbnRUeXBlID0gZ2V0QXJjaHR5cGUoYmFzZSk7XG4gICAgICAgIGxldCBwID0gcGF0aFtpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwICE9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcCA9IFwiXCIgKyBwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocGFyZW50VHlwZSA9PT0gMCAvKiBPYmplY3QgKi8gfHwgcGFyZW50VHlwZSA9PT0gMSAvKiBBcnJheSAqLykgJiYgKHAgPT09IFwiX19wcm90b19fXCIgfHwgcCA9PT0gXCJjb25zdHJ1Y3RvclwiKSlcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlID09PSBcImZ1bmN0aW9uXCIgJiYgcCA9PT0gXCJwcm90b3R5cGVcIilcbiAgICAgICAgICBkaWUoZXJyb3JPZmZzZXQgKyAzKTtcbiAgICAgICAgYmFzZSA9IGdldChiYXNlLCBwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKVxuICAgICAgICAgIGRpZShlcnJvck9mZnNldCArIDIsIHBhdGguam9pbihcIi9cIikpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpO1xuICAgICAgY29uc3QgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKTtcbiAgICAgIGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgIHN3aXRjaCAob3ApIHtcbiAgICAgICAgY2FzZSBSRVBMQUNFOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAyIC8qIE1hcCAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY2FzZSAzIC8qIFNldCAqLzpcbiAgICAgICAgICAgICAgZGllKGVycm9yT2Zmc2V0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgQUREOlxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxIC8qIEFycmF5ICovOlxuICAgICAgICAgICAgICByZXR1cm4ga2V5ID09PSBcIi1cIiA/IGJhc2UucHVzaCh2YWx1ZSkgOiBiYXNlLnNwbGljZShrZXksIDAsIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNYXAgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFTU9WRTpcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBBcnJheSAqLzpcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2Uuc3BsaWNlKGtleSwgMSk7XG4gICAgICAgICAgICBjYXNlIDIgLyogTWFwICovOlxuICAgICAgICAgICAgICByZXR1cm4gYmFzZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTZXQgKi86XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlLmRlbGV0ZShwYXRjaC52YWx1ZSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlIGJhc2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZGllKGVycm9yT2Zmc2V0ICsgMSwgb3ApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkcmFmdDtcbiAgfVxuICBmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iaikge1xuICAgIGlmICghaXNEcmFmdGFibGUob2JqKSlcbiAgICAgIHJldHVybiBvYmo7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSlcbiAgICAgIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpO1xuICAgIGlmIChpc01hcChvYmopKVxuICAgICAgcmV0dXJuIG5ldyBNYXAoXG4gICAgICAgIEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSkubWFwKChbaywgdl0pID0+IFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXSlcbiAgICAgICk7XG4gICAgaWYgKGlzU2V0KG9iaikpXG4gICAgICByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKTtcbiAgICBjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKGdldFByb3RvdHlwZU9mKG9iaikpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iailcbiAgICAgIGNsb25lZFtrZXldID0gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmpba2V5XSk7XG4gICAgaWYgKGhhcyhvYmosIERSQUZUQUJMRSkpXG4gICAgICBjbG9uZWRbRFJBRlRBQkxFXSA9IG9ialtEUkFGVEFCTEVdO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbiAgZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob2JqKSB7XG4gICAgaWYgKGlzRHJhZnQob2JqKSkge1xuICAgICAgcmV0dXJuIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbiAgbG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuICAgIGFwcGx5UGF0Y2hlc18sXG4gICAgZ2VuZXJhdGVQYXRjaGVzXyxcbiAgICBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cbiAgfSk7XG59XG5cbi8vIHNyYy9wbHVnaW5zL21hcHNldC50c1xuZnVuY3Rpb24gZW5hYmxlTWFwU2V0KCkge1xuICBjbGFzcyBEcmFmdE1hcCBleHRlbmRzIE1hcCB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwYXJlbnQpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzW0RSQUZUX1NUQVRFXSA9IHtcbiAgICAgICAgdHlwZV86IDIgLyogTWFwICovLFxuICAgICAgICBwYXJlbnRfOiBwYXJlbnQsXG4gICAgICAgIHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuICAgICAgICBtb2RpZmllZF86IGZhbHNlLFxuICAgICAgICBmaW5hbGl6ZWRfOiBmYWxzZSxcbiAgICAgICAgY29weV86IHZvaWQgMCxcbiAgICAgICAgYXNzaWduZWRfOiB2b2lkIDAsXG4gICAgICAgIGJhc2VfOiB0YXJnZXQsXG4gICAgICAgIGRyYWZ0XzogdGhpcyxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZSxcbiAgICAgICAgcmV2b2tlZF86IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBpZiAoIWxhdGVzdChzdGF0ZSkuaGFzKGtleSkgfHwgbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KSAhPT0gdmFsdWUpIHtcbiAgICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uc2V0KGtleSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgaWYgKCF0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgbWFya0NoYW5nZWQoc3RhdGUpO1xuICAgICAgaWYgKHN0YXRlLmJhc2VfLmhhcyhrZXkpKSB7XG4gICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5hc3NpZ25lZF8uZGVsZXRlKGtleSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5jb3B5Xy5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlTWFwQ29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZWFjaChzdGF0ZS5iYXNlXywgKGtleSkgPT4ge1xuICAgICAgICAgIHN0YXRlLmFzc2lnbmVkXy5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5jb3B5Xy5jbGVhcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoKGNiLCB0aGlzQXJnKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgbGF0ZXN0KHN0YXRlKS5mb3JFYWNoKChfdmFsdWUsIGtleSwgX21hcCkgPT4ge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHRoaXMuZ2V0KGtleSksIGtleSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICBpZiAoc3RhdGUuZmluYWxpemVkXyB8fCAhaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPT0gc3RhdGUuYmFzZV8uZ2V0KGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgcHJlcGFyZU1hcENvcHkoc3RhdGUpO1xuICAgICAgc3RhdGUuY29weV8uc2V0KGtleSwgZHJhZnQpO1xuICAgICAgcmV0dXJuIGRyYWZ0O1xuICAgIH1cbiAgICBrZXlzKCkge1xuICAgICAgcmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpO1xuICAgIH1cbiAgICB2YWx1ZXMoKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMua2V5cygpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IHRoaXMudmFsdWVzKCksXG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChyLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU3ltYm9sLml0ZXJhdG9yXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCByID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgIGlmIChyLmRvbmUpXG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBbci52YWx1ZSwgdmFsdWVdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgWyhEUkFGVF9TVEFURSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHByb3h5TWFwXyh0YXJnZXQsIHBhcmVudCkge1xuICAgIHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpO1xuICB9XG4gIGZ1bmN0aW9uIHByZXBhcmVNYXBDb3B5KHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgc3RhdGUuYXNzaWduZWRfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXyk7XG4gICAgfVxuICB9XG4gIGNsYXNzIERyYWZ0U2V0IGV4dGVuZHMgU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuICAgICAgICB0eXBlXzogMyAvKiBTZXQgKi8sXG4gICAgICAgIHBhcmVudF86IHBhcmVudCxcbiAgICAgICAgc2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG4gICAgICAgIG1vZGlmaWVkXzogZmFsc2UsXG4gICAgICAgIGZpbmFsaXplZF86IGZhbHNlLFxuICAgICAgICBjb3B5Xzogdm9pZCAwLFxuICAgICAgICBiYXNlXzogdGFyZ2V0LFxuICAgICAgICBkcmFmdF86IHRoaXMsXG4gICAgICAgIGRyYWZ0c186IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgICAgIHJldm9rZWRfOiBmYWxzZSxcbiAgICAgICAgaXNNYW51YWxfOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplO1xuICAgIH1cbiAgICBoYXModmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCFzdGF0ZS5jb3B5Xykge1xuICAgICAgICByZXR1cm4gc3RhdGUuYmFzZV8uaGFzKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcHJlcGFyZVNldENvcHkoc3RhdGUpO1xuICAgICAgICBtYXJrQ2hhbmdlZChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmNvcHlfLmFkZCh2YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5kZWxldGUodmFsdWUpIHx8IChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgPyBzdGF0ZS5jb3B5Xy5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSA6IChcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZmFsc2VcbiAgICAgICkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV07XG4gICAgICBhc3NlcnRVbnJldm9rZWQoc3RhdGUpO1xuICAgICAgaWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuICAgICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICAgIG1hcmtDaGFuZ2VkKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuY29weV8uY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXTtcbiAgICAgIGFzc2VydFVucmV2b2tlZChzdGF0ZSk7XG4gICAgICBwcmVwYXJlU2V0Q29weShzdGF0ZSk7XG4gICAgICByZXR1cm4gc3RhdGUuY29weV8udmFsdWVzKCk7XG4gICAgfVxuICAgIGVudHJpZXMoKSB7XG4gICAgICBjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdO1xuICAgICAgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKTtcbiAgICAgIHByZXBhcmVTZXRDb3B5KHN0YXRlKTtcbiAgICAgIHJldHVybiBzdGF0ZS5jb3B5Xy5lbnRyaWVzKCk7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgWyhEUkFGVF9TVEFURSwgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZXMoKTtcbiAgICB9XG4gICAgZm9yRWFjaChjYiwgdGhpc0FyZykge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpO1xuICAgICAgbGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY2IuY2FsbCh0aGlzQXJnLCByZXN1bHQudmFsdWUsIHJlc3VsdC52YWx1ZSwgdGhpcyk7XG4gICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJveHlTZXRfKHRhcmdldCwgcGFyZW50KSB7XG4gICAgcmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJlcGFyZVNldENvcHkoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmNvcHlfKSB7XG4gICAgICBzdGF0ZS5jb3B5XyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBzdGF0ZS5iYXNlXy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eSh2YWx1ZSwgc3RhdGUpO1xuICAgICAgICAgIHN0YXRlLmRyYWZ0c18uc2V0KHZhbHVlLCBkcmFmdCk7XG4gICAgICAgICAgc3RhdGUuY29weV8uYWRkKGRyYWZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5jb3B5Xy5hZGQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYXNzZXJ0VW5yZXZva2VkKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLnJldm9rZWRfKVxuICAgICAgZGllKDMsIEpTT04uc3RyaW5naWZ5KGxhdGVzdChzdGF0ZSkpKTtcbiAgfVxuICBsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHsgcHJveHlNYXBfLCBwcm94eVNldF8gfSk7XG59XG5cbi8vIHNyYy9pbW1lci50c1xudmFyIGltbWVyID0gbmV3IEltbWVyMigpO1xudmFyIHByb2R1Y2UgPSBpbW1lci5wcm9kdWNlO1xudmFyIHByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuICBpbW1lclxuKTtcbnZhciBzZXRBdXRvRnJlZXplID0gaW1tZXIuc2V0QXV0b0ZyZWV6ZS5iaW5kKGltbWVyKTtcbnZhciBzZXRVc2VTdHJpY3RTaGFsbG93Q29weSA9IGltbWVyLnNldFVzZVN0cmljdFNoYWxsb3dDb3B5LmJpbmQoaW1tZXIpO1xudmFyIGFwcGx5UGF0Y2hlcyA9IGltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKTtcbnZhciBjcmVhdGVEcmFmdCA9IGltbWVyLmNyZWF0ZURyYWZ0LmJpbmQoaW1tZXIpO1xudmFyIGZpbmlzaERyYWZ0ID0gaW1tZXIuZmluaXNoRHJhZnQuYmluZChpbW1lcik7XG5mdW5jdGlvbiBjYXN0RHJhZnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY2FzdEltbXV0YWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgSW1tZXIsXG4gIGFwcGx5UGF0Y2hlcyxcbiAgY2FzdERyYWZ0LFxuICBjYXN0SW1tdXRhYmxlLFxuICBjcmVhdGVEcmFmdCxcbiAgY3VycmVudCxcbiAgZW5hYmxlTWFwU2V0LFxuICBlbmFibGVQYXRjaGVzLFxuICBmaW5pc2hEcmFmdCxcbiAgZnJlZXplLFxuICBpbW1lcmFibGUsXG4gIGlzRHJhZnQsXG4gIGlzRHJhZnRhYmxlLFxuICBub3RoaW5nLFxuICBvcmlnaW5hbCxcbiAgcHJvZHVjZSxcbiAgcHJvZHVjZVdpdGhQYXRjaGVzLFxuICBzZXRBdXRvRnJlZXplLFxuICBzZXRVc2VTdHJpY3RTaGFsbG93Q29weVxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5janMuZGV2ZWxvcG1lbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/immer/dist/cjs/immer.cjs.development.js\n"));

/***/ }),

/***/ "../../node_modules/immer/dist/cjs/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/immer/dist/cjs/index.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./immer.cjs.development.js */ \"../../node_modules/immer/dist/cjs/immer.cjs.development.js\")\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvY2pzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7QUFDWTs7QUFFWixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0lBQXNEO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9janMvaW5kZXguanM/YjYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbid1c2Ugc3RyaWN0J1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW1tZXIuY2pzLnByb2R1Y3Rpb24uanMnKVxufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ltbWVyLmNqcy5kZXZlbG9wbWVudC5qcycpXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/immer/dist/cjs/index.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css":
/*!******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css ***!
  \******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.1 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */\\n  -moz-tab-size: 4; /* 3 */\\n  -o-tab-size: 4;\\n     tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::-moz-placeholder, textarea::-moz-placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n  html {\\n    font-size: 16px;\\n  }\\n\\n  body {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(250 250 250 / var(--tw-bg-opacity));\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\";\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n  font-weight: 400;\\n  --tw-text-opacity: 1;\\n  color: rgb(23 23 23 / var(--tw-text-opacity));\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n.btn {\\n  display: flex;\\n  height: 2.25rem;\\n  align-items: center;\\n  justify-content: center;\\n  border-radius: 0.25rem;\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(236 72 153 / var(--tw-bg-opacity));\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n  font-weight: 600;\\n  --tw-text-opacity: 1;\\n  color: rgb(250 250 250 / var(--tw-text-opacity));\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.btn:hover {\\n  --tw-brightness: brightness(1.1);\\n  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);\\n}\\n.btn:active {\\n  --tw-scale-x: .95;\\n  --tw-scale-y: .95;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.btn:disabled {\\n  pointer-events: none;\\n  opacity: 0.6;\\n}\\n.btn>svg:first-child {\\n  margin-left: -0.25rem;\\n  margin-right: 0.25rem;\\n}\\n.btn>svg:last-child {\\n  margin-right: -0.25rem;\\n  margin-left: 0.25rem;\\n}\\n.icon-btn {\\n  display: flex;\\n  height: 2.25rem;\\n  width: 2.25rem;\\n  align-items: center;\\n  justify-content: center;\\n  border-radius: 0.25rem;\\n  background-color: rgb(163 163 163 / var(--tw-bg-opacity));\\n  --tw-bg-opacity: 0;\\n  --tw-text-opacity: 1;\\n  color: rgb(82 82 82 / var(--tw-text-opacity));\\n  transition-property: all;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.icon-btn:hover {\\n  --tw-bg-opacity: 0.2;\\n  --tw-text-opacity: 1;\\n  color: rgb(23 23 23 / var(--tw-text-opacity));\\n}\\n.icon-btn:active {\\n  --tw-scale-x: .95;\\n  --tw-scale-y: .95;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.icon-btn:disabled {\\n  pointer-events: none;\\n  opacity: 0.6;\\n}\\n.input {\\n  height: 2.25rem;\\n  border-radius: 0.25rem;\\n  border-width: 1px;\\n  --tw-border-opacity: 1;\\n  border-color: rgb(212 212 212 / var(--tw-border-opacity));\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(245 245 245 / var(--tw-bg-opacity));\\n  padding-top: 0px;\\n  padding-bottom: 0px;\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n  font-weight: 500;\\n  --tw-text-opacity: 1;\\n  color: rgb(23 23 23 / var(--tw-text-opacity));\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n  --tw-ring-opacity: 1;\\n  --tw-ring-color: rgb(212 212 212 / var(--tw-ring-opacity));\\n  --tw-ring-offset-width: 2px;\\n  --tw-ring-offset-color: #fafafa;\\n}\\n.input::-moz-placeholder {\\n  --tw-text-opacity: 1;\\n  color: rgb(163 163 163 / var(--tw-text-opacity));\\n}\\n.input::placeholder {\\n  --tw-text-opacity: 1;\\n  color: rgb(163 163 163 / var(--tw-text-opacity));\\n}\\n.input:focus {\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n.input:disabled {\\n  opacity: 0.6;\\n}\\n@media (prefers-color-scheme: dark) {\\n\\n  .input {\\n    --tw-border-opacity: 1;\\n    border-color: rgb(82 82 82 / var(--tw-border-opacity));\\n    --tw-ring-opacity: 1;\\n    --tw-ring-color: rgb(82 82 82 / var(--tw-ring-opacity));\\n    --tw-ring-offset-color: #171717;\\n  }\\n\\n  .input::-moz-placeholder {\\n    --tw-text-opacity: 1;\\n    color: rgb(115 115 115 / var(--tw-text-opacity));\\n  }\\n\\n  .input::placeholder {\\n    --tw-text-opacity: 1;\\n    color: rgb(115 115 115 / var(--tw-text-opacity));\\n  }\\n}\\n.checkbox {\\n  position: relative;\\n  height: 1.25rem;\\n  width: 1.25rem;\\n  -webkit-appearance: none;\\n     -moz-appearance: none;\\n          appearance: none;\\n  border-radius: 0.375rem;\\n  border-width: 1px;\\n  border-color: rgb(115 115 115 / 0.6);\\n  outline: 2px solid transparent;\\n  outline-offset: 2px;\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.checkbox::after {\\n  position: absolute;\\n  top: 1px;\\n  left: 5px;\\n  display: block;\\n  height: 0.75rem;\\n  width: 0.5rem;\\n  --tw-rotate: 45deg;\\n  --tw-scale-x: 0;\\n  --tw-scale-y: 0;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n  border-right-width: 2px;\\n  border-bottom-width: 2px;\\n  --tw-border-opacity: 1;\\n  border-color: rgb(250 250 250 / var(--tw-border-opacity));\\n  transition-property: transform;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n  --tw-content: '';\\n  content: var(--tw-content);\\n}\\n.checkbox:checked {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(236 72 153 / var(--tw-border-opacity));\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(236 72 153 / var(--tw-bg-opacity));\\n}\\n.checkbox:checked::after {\\n  content: var(--tw-content);\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\\n}\\n.checkbox:hover {\\n  cursor: pointer;\\n}\\n@media (prefers-color-scheme: dark) {\\n\\n  .checkbox:checked {\\n    --tw-border-opacity: 1;\\n    border-color: rgb(236 72 153 / var(--tw-border-opacity));\\n    --tw-bg-opacity: 1;\\n    background-color: rgb(236 72 153 / var(--tw-bg-opacity));\\n  }\\n}\\n.wrapper {\\n  margin-left: auto;\\n  margin-right: auto;\\n  width: 100%;\\n  max-width: 32rem;\\n  padding-left: 1.25rem;\\n  padding-right: 1.25rem;\\n  padding-top: 2rem;\\n  padding-bottom: 2rem;\\n}\\n@media (min-width: 640px) {\\n\\n  .wrapper {\\n    max-width: 36rem;\\n    padding-top: 3rem;\\n    padding-bottom: 3rem;\\n  }\\n}\\n@media (min-width: 768px) {\\n\\n  .wrapper {\\n    max-width: 48rem;\\n  }\\n}\\n@media (min-width: 1024px) {\\n\\n  .wrapper {\\n    max-width: 64rem;\\n    padding-top: 5rem;\\n    padding-bottom: 5rem;\\n  }\\n}\\n@media (min-width: 1280px) {\\n\\n  .wrapper {\\n    max-width: 80rem;\\n  }\\n}\\n@keyframes pulse {\\n\\n  50% {\\n    opacity: .5;\\n  }\\n}\\n.skeleton {\\n  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(212 212 212 / var(--tw-bg-opacity));\\n  opacity: 0.1;\\n}\\n.mx-2 {\\n  margin-left: 0.5rem;\\n  margin-right: 0.5rem;\\n}\\n.my-3 {\\n  margin-top: 0.75rem;\\n  margin-bottom: 0.75rem;\\n}\\n.-ml-1 {\\n  margin-left: -0.25rem;\\n}\\n.-ml-2 {\\n  margin-left: -0.5rem;\\n}\\n.-mr-1 {\\n  margin-right: -0.25rem;\\n}\\n.mb-3 {\\n  margin-bottom: 0.75rem;\\n}\\n.mb-5 {\\n  margin-bottom: 1.25rem;\\n}\\n.flex {\\n  display: flex;\\n}\\n.h-12 {\\n  height: 3rem;\\n}\\n.h-8 {\\n  height: 2rem;\\n}\\n.min-h-screen {\\n  min-height: 100vh;\\n}\\n.w-8 {\\n  width: 2rem;\\n}\\n.w-full {\\n  width: 100%;\\n}\\n.min-w-0 {\\n  min-width: 0px;\\n}\\n.shrink-0 {\\n  flex-shrink: 0;\\n}\\n.grow {\\n  flex-grow: 1;\\n}\\n.cursor-default {\\n  cursor: default;\\n}\\n.cursor-grab {\\n  cursor: grab;\\n}\\n.touch-none {\\n  touch-action: none;\\n}\\n.select-none {\\n  -webkit-user-select: none;\\n     -moz-user-select: none;\\n          user-select: none;\\n}\\n.flex-col {\\n  flex-direction: column;\\n}\\n.items-center {\\n  align-items: center;\\n}\\n.justify-center {\\n  justify-content: center;\\n}\\n.justify-between {\\n  justify-content: space-between;\\n}\\n.gap-3 {\\n  gap: 0.75rem;\\n}\\n.rounded {\\n  border-radius: 0.25rem;\\n}\\n.rounded-full {\\n  border-radius: 9999px;\\n}\\n.rounded-md {\\n  border-radius: 0.375rem;\\n}\\n.border {\\n  border-width: 1px;\\n}\\n.border-neutral-200 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(229 229 229 / var(--tw-border-opacity));\\n}\\n.border-neutral-300 {\\n  --tw-border-opacity: 1;\\n  border-color: rgb(212 212 212 / var(--tw-border-opacity));\\n}\\n.bg-neutral-100 {\\n  --tw-bg-opacity: 1;\\n  background-color: rgb(245 245 245 / var(--tw-bg-opacity));\\n}\\n.bg-neutral-200\\\\/0 {\\n  background-color: rgb(229 229 229 / 0);\\n}\\n.bg-pink-500\\\\/20 {\\n  background-color: rgb(236 72 153 / 0.2);\\n}\\n.px-1 {\\n  padding-left: 0.25rem;\\n  padding-right: 0.25rem;\\n}\\n.px-3 {\\n  padding-left: 0.75rem;\\n  padding-right: 0.75rem;\\n}\\n.py-1 {\\n  padding-top: 0.25rem;\\n  padding-bottom: 0.25rem;\\n}\\n.py-1\\\\.5 {\\n  padding-top: 0.375rem;\\n  padding-bottom: 0.375rem;\\n}\\n.py-2 {\\n  padding-top: 0.5rem;\\n  padding-bottom: 0.5rem;\\n}\\n.text-left {\\n  text-align: left;\\n}\\n.text-base {\\n  font-size: 1rem;\\n  line-height: 1.5rem;\\n}\\n.text-sm {\\n  font-size: 0.875rem;\\n  line-height: 1.25rem;\\n}\\n.text-xl {\\n  font-size: 1.25rem;\\n  line-height: 1.75rem;\\n}\\n.font-medium {\\n  font-weight: 500;\\n}\\n.font-semibold {\\n  font-weight: 600;\\n}\\n.text-neutral-500 {\\n  --tw-text-opacity: 1;\\n  color: rgb(115 115 115 / var(--tw-text-opacity));\\n}\\n.line-through {\\n  text-decoration-line: line-through;\\n}\\n.opacity-60 {\\n  opacity: 0.6;\\n}\\n.shadow-md {\\n  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\\n  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);\\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\\n}\\n.ring-2 {\\n  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);\\n  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);\\n  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);\\n}\\n.ring-pink-500\\\\/50 {\\n  --tw-ring-color: rgb(236 72 153 / 0.5);\\n}\\n.ring-offset-2 {\\n  --tw-ring-offset-width: 2px;\\n}\\n.ring-offset-neutral-50 {\\n  --tw-ring-offset-color: #fafafa;\\n}\\n.transition-colors {\\n  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n.transition-opacity {\\n  transition-property: opacity;\\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\\n  transition-duration: 150ms;\\n}\\n\\nhtml,\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  font-size: 16px;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\na {\\n  color: inherit;\\n  text-decoration: none;\\n}\\n\\n* {\\n  box-sizing: border-box;\\n}\\n\\n.hover\\\\:bg-neutral-200\\\\/100:hover {\\n  background-color: rgb(229 229 229 / 1);\\n}\\n\\n.group:hover .group-hover\\\\:text-neutral-700 {\\n  --tw-text-opacity: 1;\\n  color: rgb(64 64 64 / var(--tw-text-opacity));\\n}\\n\\n@media (min-width: 640px) {\\n\\n  .sm\\\\:mb-5 {\\n    margin-bottom: 1.25rem;\\n  }\\n\\n  .sm\\\\:mb-8 {\\n    margin-bottom: 2rem;\\n  }\\n\\n  .sm\\\\:text-2xl {\\n    font-size: 1.5rem;\\n    line-height: 2rem;\\n  }\\n\\n  .sm\\\\:text-lg {\\n    font-size: 1.125rem;\\n    line-height: 1.75rem;\\n  }\\n}\\n\\n@media (min-width: 1024px) {\\n\\n  .lg\\\\:text-3xl {\\n    font-size: 1.875rem;\\n    line-height: 2.25rem;\\n  }\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://styles/globals.css\",\"<no source>\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\n@tailwind components;\\n@tailwind utilities;\\n\\nhtml,\\nbody {\\n  padding: 0;\\n  margin: 0;\\n  font-size: 16px;\\n  -webkit-font-smoothing: antialiased;\\n  -moz-osx-font-smoothing: grayscale;\\n}\\n\\na {\\n  color: inherit;\\n  text-decoration: none;\\n}\\n\\n* {\\n  box-sizing: border-box;\\n}\\n\\n@layer base {\\n  html {\\n    font-size: 16px;\\n  }\\n\\n  body {\\n    @apply font-sans font-normal text-base text-neutral-900 bg-neutral-50;\\n  }\\n}\\n\\n@layer components {\\n  .btn {\\n    @apply bg-pink-500 text-neutral-50 h-9 rounded px-3 text-sm font-semibold flex items-center justify-center hover:brightness-110 active:scale-95 transition-all [&>svg:last-child]:-mr-1 [&>svg:last-child]:ml-1 [&>svg:first-child]:-ml-1 [&>svg:first-child]:mr-1 disabled:opacity-60 disabled:pointer-events-none;\\n  }\\n\\n  .icon-btn {\\n    @apply text-neutral-600 hover:text-neutral-900 h-9 w-9 rounded flex items-center justify-center bg-neutral-400 bg-opacity-0 hover:bg-opacity-20 active:scale-95 transition-all disabled:opacity-60 disabled:pointer-events-none;\\n  }\\n\\n  .input {\\n    @apply h-9 py-0 px-3 text-sm font-medium text-neutral-900 rounded border bg-neutral-100 border-neutral-300 dark:border-neutral-600 placeholder:text-neutral-400 dark:placeholder:text-neutral-500 outline-none focus:outline-none focus:ring-2 ring-offset-2 ring-offset-neutral-50 dark:ring-offset-neutral-900 ring-neutral-300 dark:ring-neutral-600 disabled:opacity-60;\\n  }\\n\\n  .toggle {\\n    @apply w-11 h-6 flex items-center flex-shrink-0 p-0.5 bg-neutral-500 rounded-full duration-300 ease-in-out peer-checked:bg-pink-500 after:w-5 after:h-5 after:bg-neutral-50 after:rounded-full after:duration-300 peer-checked:after:translate-x-5 group-hover:after:scale-105 peer-disabled:opacity-50;\\n  }\\n\\n  .checkbox {\\n    @apply relative h-5 w-5 appearance-none rounded-md border border-neutral-500/60 outline-none transition-colors checked:border-pink-500 checked:bg-pink-500 after:transition-transform after:scale-0 checked:after:scale-100 after:absolute after:top-[1px] after:left-[5px] after:block after:h-3 after:w-2 after:rotate-45 after:border-r-[2px] after:border-b-[2px] after:border-neutral-50 after:content-[''] hover:cursor-pointer dark:checked:border-pink-500 dark:checked:bg-pink-500;\\n  }\\n\\n  .wrapper {\\n    @apply mx-auto px-5 py-8 sm:py-12 lg:py-20 w-full max-w-lg sm:max-w-xl md:max-w-3xl lg:max-w-5xl xl:max-w-7xl;\\n  }\\n\\n  .skeleton {\\n    @apply bg-neutral-300 opacity-10 animate-pulse;\\n  }\\n}\\n\",null],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsyXSEuL3N0eWxlcy9nbG9iYWxzLmNzcy5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUM4SDtBQUM5SCw4QkFBOEIsa0hBQTJCO0FBQ3pEO0FBQ0EsMFhBQTBYLDRCQUE0Qiw0QkFBNEIsZ0NBQWdDLGtDQUFrQyxVQUFVLHdCQUF3QixxQkFBcUIsR0FBRyxxWUFBcVksc0JBQXNCLDJDQUEyQyw2QkFBNkIsMEJBQTBCLG9CQUFvQix1UEFBdVAsMENBQTBDLDRDQUE0QyxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsaUNBQWlDLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsOEZBQThGLHlCQUF5QixHQUFHLG1MQUFtTCxnQ0FBZ0MsMENBQTBDLG1DQUFtQyxVQUFVLCtGQUErRixrQkFBa0IsR0FBRywrTUFB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VyxXQUFXLE1BQU0sS0FBSyxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sUUFBUSxNQUFNLEtBQUssb0JBQW9CLHFCQUFxQixxQkFBcUIsTUFBTSxRQUFRLE1BQU0sU0FBUyxxQkFBcUIsb0JBQW9CLHFCQUFxQixxQkFBcUIsb0JBQW9CLG9CQUFvQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sTUFBTSxXQUFXLE1BQU0sT0FBTyxNQUFNLFFBQVEscUJBQXFCLHFCQUFxQixxQkFBcUIsTUFBTSxNQUFNLE1BQU0sS0FBSyxVQUFVLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLE1BQU0sTUFBTSxVQUFVLE1BQU0sT0FBTyxNQUFNLEtBQUsscUJBQXFCLHFCQUFxQixNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxxQkFBcUIsb0JBQW9CLE1BQU0sTUFBTSxNQUFNLEtBQUssV0FBVyxNQUFNLE1BQU0sTUFBTSxpQkFBaUIsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLE1BQU0sT0FBTyxXQUFXLFVBQVUsVUFBVSxNQUFNLE1BQU0sTUFBTSxLQUFLLFdBQVcsTUFBTSxPQUFPLE1BQU0sS0FBSyxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxvQkFBb0Isb0JBQW9CLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxNQUFNLE1BQU0sS0FBSyxLQUFLLFVBQVUsTUFBTSxRQUFRLE1BQU0sWUFBWSxvQkFBb0IscUJBQXFCLE1BQU0sTUFBTSxNQUFNLE1BQU0sVUFBVSxVQUFVLE1BQU0sV0FBVyxLQUFLLFVBQVUsS0FBSyxLQUFLLFVBQVUsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sV0FBVyxZQUFZLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsTUFBTSxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFdBQVcsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsYUFBYSxNQUFNLE9BQU8sTUFBTSxZQUFZLE1BQU0sT0FBTyxNQUFNLFlBQVksTUFBTSxNQUFNLEtBQUssTUFBTSxZQUFZLFlBQVksWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksWUFBWSxZQUFZLFlBQVksWUFBWSxZQUFZLGFBQWEsWUFBWSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksWUFBWSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxPQUFPLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxNQUFNLEtBQUssTUFBTSxZQUFZLGFBQWEsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sTUFBTSxPQUFPLEtBQUssWUFBWSxhQUFhLE1BQU0sTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssWUFBWSxhQUFhLE1BQU0sTUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLE1BQU0sT0FBTyxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxXQUFXLE1BQU0sTUFBTSxNQUFNLFlBQVksTUFBTSxNQUFNLE1BQU0sWUFBWSxNQUFNLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTSxZQUFZLE1BQU0sTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE1BQU0sTUFBTSxZQUFZLGFBQWEsTUFBTSxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sTUFBTSxNQUFNLFlBQVksYUFBYSxNQUFNLE9BQU8sT0FBTyxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLE1BQU0sS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLE1BQU0sTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLFdBQVcsS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxNQUFNLEtBQUssV0FBVyxLQUFLLEtBQUssd0NBQXdDLHVCQUF1QixzQkFBc0IsaUJBQWlCLGVBQWUsY0FBYyxvQkFBb0Isd0NBQXdDLHVDQUF1QyxHQUFHLE9BQU8sbUJBQW1CLDBCQUEwQixHQUFHLE9BQU8sMkJBQTJCLEdBQUcsaUJBQWlCLFVBQVUsc0JBQXNCLEtBQUssWUFBWSw0RUFBNEUsS0FBSyxHQUFHLHVCQUF1QixVQUFVLDBUQUEwVCxLQUFLLGlCQUFpQixzT0FBc08sS0FBSyxjQUFjLGtYQUFrWCxLQUFLLGVBQWUsOFNBQThTLEtBQUssaUJBQWlCLGtlQUFrZSxLQUFLLGdCQUFnQixvSEFBb0gsS0FBSyxpQkFBaUIscURBQXFELEtBQUssR0FBRywwQkFBMEI7QUFDMTA5QjtBQUNBLCtEQUFlLHVCQUF1QixFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz81YTYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKlxcbiEgdGFpbHdpbmRjc3MgdjMuMy4xIHwgTUlUIExpY2Vuc2UgfCBodHRwczovL3RhaWx3aW5kY3NzLmNvbVxcbiovLypcXG4xLiBQcmV2ZW50IHBhZGRpbmcgYW5kIGJvcmRlciBmcm9tIGFmZmVjdGluZyBlbGVtZW50IHdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy80KVxcbjIuIEFsbG93IGFkZGluZyBhIGJvcmRlciB0byBhbiBlbGVtZW50IGJ5IGp1c3QgYWRkaW5nIGEgYm9yZGVyLXdpZHRoLiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kY3NzL3RhaWx3aW5kY3NzL3B1bGwvMTE2KVxcbiovXFxuXFxuKixcXG46OmJlZm9yZSxcXG46OmFmdGVyIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7IC8qIDEgKi9cXG4gIGJvcmRlci13aWR0aDogMDsgLyogMiAqL1xcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbG9yOiAjZTVlN2ViOyAvKiAyICovXFxufVxcblxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgLS10dy1jb250ZW50OiAnJztcXG59XFxuXFxuLypcXG4xLiBVc2UgYSBjb25zaXN0ZW50IHNlbnNpYmxlIGxpbmUtaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4yLiBQcmV2ZW50IGFkanVzdG1lbnRzIG9mIGZvbnQgc2l6ZSBhZnRlciBvcmllbnRhdGlvbiBjaGFuZ2VzIGluIGlPUy5cXG4zLiBVc2UgYSBtb3JlIHJlYWRhYmxlIHRhYiBzaXplLlxcbjQuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYHNhbnNgIGZvbnQtZmFtaWx5IGJ5IGRlZmF1bHQuXFxuNS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mZWF0dXJlLXNldHRpbmdzIGJ5IGRlZmF1bHQuXFxuNi4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC12YXJpYXRpb24tc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG4qL1xcblxcbmh0bWwge1xcbiAgbGluZS1oZWlnaHQ6IDEuNTsgLyogMSAqL1xcbiAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlOyAvKiAyICovXFxuICAtbW96LXRhYi1zaXplOiA0OyAvKiAzICovXFxuICAtby10YWItc2l6ZTogNDtcXG4gICAgIHRhYi1zaXplOiA0OyAvKiAzICovXFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiOyAvKiA0ICovXFxuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IG5vcm1hbDsgLyogNSAqL1xcbiAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IG5vcm1hbDsgLyogNiAqL1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0aGUgbWFyZ2luIGluIGFsbCBicm93c2Vycy5cXG4yLiBJbmhlcml0IGxpbmUtaGVpZ2h0IGZyb20gYGh0bWxgIHNvIHVzZXJzIGNhbiBzZXQgdGhlbSBhcyBhIGNsYXNzIGRpcmVjdGx5IG9uIHRoZSBgaHRtbGAgZWxlbWVudC5cXG4qL1xcblxcbmJvZHkge1xcbiAgbWFyZ2luOiAwOyAvKiAxICovXFxuICBsaW5lLWhlaWdodDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbjEuIEFkZCB0aGUgY29ycmVjdCBoZWlnaHQgaW4gRmlyZWZveC5cXG4yLiBDb3JyZWN0IHRoZSBpbmhlcml0YW5jZSBvZiBib3JkZXIgY29sb3IgaW4gRmlyZWZveC4gKGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE5MDY1NSlcXG4zLiBFbnN1cmUgaG9yaXpvbnRhbCBydWxlcyBhcmUgdmlzaWJsZSBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHIge1xcbiAgaGVpZ2h0OiAwOyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLXRvcC13aWR0aDogMXB4OyAvKiAzICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IHRleHQgZGVjb3JhdGlvbiBpbiBDaHJvbWUsIEVkZ2UsIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5hYmJyOndoZXJlKFt0aXRsZV0pIHtcXG4gIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xcbiAgICAgICAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBkZWZhdWx0IGZvbnQgc2l6ZSBhbmQgd2VpZ2h0IGZvciBoZWFkaW5ncy5cXG4qL1xcblxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2IHtcXG4gIGZvbnQtc2l6ZTogaW5oZXJpdDtcXG4gIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcblJlc2V0IGxpbmtzIHRvIG9wdGltaXplIGZvciBvcHQtaW4gc3R5bGluZyBpbnN0ZWFkIG9mIG9wdC1vdXQuXFxuKi9cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHdlaWdodCBpbiBFZGdlIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5iLFxcbnN0cm9uZyB7XFxuICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgYG1vbm9gIGZvbnQgZmFtaWx5IGJ5IGRlZmF1bHQuXFxuMi4gQ29ycmVjdCB0aGUgb2RkIGBlbWAgZm9udCBzaXppbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuY29kZSxcXG5rYmQsXFxuc2FtcCxcXG5wcmUge1xcbiAgZm9udC1mYW1pbHk6IHVpLW1vbm9zcGFjZSwgU0ZNb25vLVJlZ3VsYXIsIE1lbmxvLCBNb25hY28sIENvbnNvbGFzLCBcXFwiTGliZXJhdGlvbiBNb25vXFxcIiwgXFxcIkNvdXJpZXIgTmV3XFxcIiwgbW9ub3NwYWNlOyAvKiAxICovXFxuICBmb250LXNpemU6IDFlbTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBmb250IHNpemUgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc21hbGwge1xcbiAgZm9udC1zaXplOiA4MCU7XFxufVxcblxcbi8qXFxuUHJldmVudCBgc3ViYCBhbmQgYHN1cGAgZWxlbWVudHMgZnJvbSBhZmZlY3RpbmcgdGhlIGxpbmUgaGVpZ2h0IGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbnN1YixcXG5zdXAge1xcbiAgZm9udC1zaXplOiA3NSU7XFxuICBsaW5lLWhlaWdodDogMDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuc3ViIHtcXG4gIGJvdHRvbTogLTAuMjVlbTtcXG59XFxuXFxuc3VwIHtcXG4gIHRvcDogLTAuNWVtO1xcbn1cXG5cXG4vKlxcbjEuIFJlbW92ZSB0ZXh0IGluZGVudGF0aW9uIGZyb20gdGFibGUgY29udGVudHMgaW4gQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05OTkwODgsIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDEyOTcpXFxuMi4gQ29ycmVjdCB0YWJsZSBib3JkZXIgY29sb3IgaW5oZXJpdGFuY2UgaW4gYWxsIENocm9tZSBhbmQgU2FmYXJpLiAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTM1NzI5LCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTk1MDE2KVxcbjMuIFJlbW92ZSBnYXBzIGJldHdlZW4gdGFibGUgYm9yZGVycyBieSBkZWZhdWx0LlxcbiovXFxuXFxudGFibGUge1xcbiAgdGV4dC1pbmRlbnQ6IDA7IC8qIDEgKi9cXG4gIGJvcmRlci1jb2xvcjogaW5oZXJpdDsgLyogMiAqL1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTsgLyogMyAqL1xcbn1cXG5cXG4vKlxcbjEuIENoYW5nZSB0aGUgZm9udCBzdHlsZXMgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFJlbW92ZSB0aGUgbWFyZ2luIGluIEZpcmVmb3ggYW5kIFNhZmFyaS5cXG4zLiBSZW1vdmUgZGVmYXVsdCBwYWRkaW5nIGluIGFsbCBicm93c2Vycy5cXG4qL1xcblxcbmJ1dHRvbixcXG5pbnB1dCxcXG5vcHRncm91cCxcXG5zZWxlY3QsXFxudGV4dGFyZWEge1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMTAwJTsgLyogMSAqL1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAxICovXFxuICBjb2xvcjogaW5oZXJpdDsgLyogMSAqL1xcbiAgbWFyZ2luOiAwOyAvKiAyICovXFxuICBwYWRkaW5nOiAwOyAvKiAzICovXFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBpbmhlcml0YW5jZSBvZiB0ZXh0IHRyYW5zZm9ybSBpbiBFZGdlIGFuZCBGaXJlZm94LlxcbiovXFxuXFxuYnV0dG9uLFxcbnNlbGVjdCB7XFxuICB0ZXh0LXRyYW5zZm9ybTogbm9uZTtcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBpbmFiaWxpdHkgdG8gc3R5bGUgY2xpY2thYmxlIHR5cGVzIGluIGlPUyBhbmQgU2FmYXJpLlxcbjIuIFJlbW92ZSBkZWZhdWx0IGJ1dHRvbiBzdHlsZXMuXFxuKi9cXG5cXG5idXR0b24sXFxuW3R5cGU9J2J1dHRvbiddLFxcblt0eXBlPSdyZXNldCddLFxcblt0eXBlPSdzdWJtaXQnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7IC8qIDIgKi9cXG4gIGJhY2tncm91bmQtaW1hZ2U6IG5vbmU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Vc2UgdGhlIG1vZGVybiBGaXJlZm94IGZvY3VzIHN0eWxlIGZvciBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzLlxcbiovXFxuXFxuOi1tb3otZm9jdXNyaW5nIHtcXG4gIG91dGxpbmU6IGF1dG87XFxufVxcblxcbi8qXFxuUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGA6aW52YWxpZGAgc3R5bGVzIGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi8yZjllYWNkOWQzZDk5NWM5MzdiNDI1MWE1NTU3ZDk1ZDQ5NGM5YmUxL2xheW91dC9zdHlsZS9yZXMvZm9ybXMuY3NzI0w3MjgtTDczNylcXG4qL1xcblxcbjotbW96LXVpLWludmFsaWQge1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdmVydGljYWwgYWxpZ25tZW50IGluIENocm9tZSBhbmQgRmlyZWZveC5cXG4qL1xcblxcbnByb2dyZXNzIHtcXG4gIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcXG59XFxuXFxuLypcXG5Db3JyZWN0IHRoZSBjdXJzb3Igc3R5bGUgb2YgaW5jcmVtZW50IGFuZCBkZWNyZW1lbnQgYnV0dG9ucyBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sXFxuOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLypcXG4xLiBDb3JyZWN0IHRoZSBvZGQgYXBwZWFyYW5jZSBpbiBDaHJvbWUgYW5kIFNhZmFyaS5cXG4yLiBDb3JyZWN0IHRoZSBvdXRsaW5lIHN0eWxlIGluIFNhZmFyaS5cXG4qL1xcblxcblt0eXBlPSdzZWFyY2gnXSB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IHRleHRmaWVsZDsgLyogMSAqL1xcbiAgb3V0bGluZS1vZmZzZXQ6IC0ycHg7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGlubmVyIHBhZGRpbmcgaW4gQ2hyb21lIGFuZCBTYWZhcmkgb24gbWFjT1MuXFxuKi9cXG5cXG46Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb24ge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gQ2hhbmdlIGZvbnQgcHJvcGVydGllcyB0byBgaW5oZXJpdGAgaW4gU2FmYXJpLlxcbiovXFxuXFxuOjotd2Via2l0LWZpbGUtdXBsb2FkLWJ1dHRvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IGJ1dHRvbjsgLyogMSAqL1xcbiAgZm9udDogaW5oZXJpdDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCBkaXNwbGF5IGluIENocm9tZSBhbmQgU2FmYXJpLlxcbiovXFxuXFxuc3VtbWFyeSB7XFxuICBkaXNwbGF5OiBsaXN0LWl0ZW07XFxufVxcblxcbi8qXFxuUmVtb3ZlcyB0aGUgZGVmYXVsdCBzcGFjaW5nIGFuZCBib3JkZXIgZm9yIGFwcHJvcHJpYXRlIGVsZW1lbnRzLlxcbiovXFxuXFxuYmxvY2txdW90ZSxcXG5kbCxcXG5kZCxcXG5oMSxcXG5oMixcXG5oMyxcXG5oNCxcXG5oNSxcXG5oNixcXG5ocixcXG5maWd1cmUsXFxucCxcXG5wcmUge1xcbiAgbWFyZ2luOiAwO1xcbn1cXG5cXG5maWVsZHNldCB7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5sZWdlbmQge1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxub2wsXFxudWwsXFxubWVudSB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuXFxuLypcXG5QcmV2ZW50IHJlc2l6aW5nIHRleHRhcmVhcyBob3Jpem9udGFsbHkgYnkgZGVmYXVsdC5cXG4qL1xcblxcbnRleHRhcmVhIHtcXG4gIHJlc2l6ZTogdmVydGljYWw7XFxufVxcblxcbi8qXFxuMS4gUmVzZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgb3BhY2l0eSBpbiBGaXJlZm94LiAoaHR0cHM6Ly9naXRodWIuY29tL3RhaWx3aW5kbGFicy90YWlsd2luZGNzcy9pc3N1ZXMvMzMwMClcXG4yLiBTZXQgdGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgY29sb3IgdG8gdGhlIHVzZXIncyBjb25maWd1cmVkIGdyYXkgNDAwIGNvbG9yLlxcbiovXFxuXFxuaW5wdXQ6Oi1tb3otcGxhY2Vob2xkZXIsIHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbmlucHV0OjpwbGFjZWhvbGRlcixcXG50ZXh0YXJlYTo6cGxhY2Vob2xkZXIge1xcbiAgb3BhY2l0eTogMTsgLyogMSAqL1xcbiAgY29sb3I6ICM5Y2EzYWY7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5TZXQgdGhlIGRlZmF1bHQgY3Vyc29yIGZvciBidXR0b25zLlxcbiovXFxuXFxuYnV0dG9uLFxcbltyb2xlPVxcXCJidXR0b25cXFwiXSB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi8qXFxuTWFrZSBzdXJlIGRpc2FibGVkIGJ1dHRvbnMgZG9uJ3QgZ2V0IHRoZSBwb2ludGVyIGN1cnNvci5cXG4qL1xcbjpkaXNhYmxlZCB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcblxcbi8qXFxuMS4gTWFrZSByZXBsYWNlZCBlbGVtZW50cyBgZGlzcGxheTogYmxvY2tgIGJ5IGRlZmF1bHQuIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbjIuIEFkZCBgdmVydGljYWwtYWxpZ246IG1pZGRsZWAgdG8gYWxpZ24gcmVwbGFjZWQgZWxlbWVudHMgbW9yZSBzZW5zaWJseSBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL2plbnNpbW1vbnMvY3NzcmVtZWR5L2lzc3Vlcy8xNCNpc3N1ZWNvbW1lbnQtNjM0OTM0MjEwKVxcbiAgIFRoaXMgY2FuIHRyaWdnZXIgYSBwb29ybHkgY29uc2lkZXJlZCBsaW50IGVycm9yIGluIHNvbWUgdG9vbHMgYnV0IGlzIGluY2x1ZGVkIGJ5IGRlc2lnbi5cXG4qL1xcblxcbmltZyxcXG5zdmcsXFxudmlkZW8sXFxuY2FudmFzLFxcbmF1ZGlvLFxcbmlmcmFtZSxcXG5lbWJlZCxcXG5vYmplY3Qge1xcbiAgZGlzcGxheTogYmxvY2s7IC8qIDEgKi9cXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7IC8qIDIgKi9cXG59XFxuXFxuLypcXG5Db25zdHJhaW4gaW1hZ2VzIGFuZCB2aWRlb3MgdG8gdGhlIHBhcmVudCB3aWR0aCBhbmQgcHJlc2VydmUgdGhlaXIgaW50cmluc2ljIGFzcGVjdCByYXRpby4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3pkZXZzL2Nzc3JlbWVkeS9pc3N1ZXMvMTQpXFxuKi9cXG5cXG5pbWcsXFxudmlkZW8ge1xcbiAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKiBNYWtlIGVsZW1lbnRzIHdpdGggdGhlIEhUTUwgaGlkZGVuIGF0dHJpYnV0ZSBzdGF5IGhpZGRlbiBieSBkZWZhdWx0ICovXFxuW2hpZGRlbl0ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuICBodG1sIHtcXG4gICAgZm9udC1zaXplOiAxNnB4O1xcbiAgfVxcblxcbiAgYm9keSB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjUwIDI1MCAyNTAgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxuICBmb250LWZhbWlseTogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFxcXCJTZWdvZSBVSVxcXCIsIFJvYm90bywgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgQXJpYWwsIFxcXCJOb3RvIFNhbnNcXFwiLCBzYW5zLXNlcmlmLCBcXFwiQXBwbGUgQ29sb3IgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgRW1vamlcXFwiLCBcXFwiU2Vnb2UgVUkgU3ltYm9sXFxcIiwgXFxcIk5vdG8gQ29sb3IgRW1vamlcXFwiO1xcbiAgZm9udC1zaXplOiAxcmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuNXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiA0MDA7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMjMgMjMgMjMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuXFxuKiwgOjpiZWZvcmUsIDo6YWZ0ZXIge1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuXFxuOjpiYWNrZHJvcCB7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXg6IDA7XFxuICAtLXR3LWJvcmRlci1zcGFjaW5nLXk6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS14OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteTogMDtcXG4gIC0tdHctcm90YXRlOiAwO1xcbiAgLS10dy1za2V3LXg6IDA7XFxuICAtLXR3LXNrZXcteTogMDtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIC0tdHctcGFuLXg6ICA7XFxuICAtLXR3LXBhbi15OiAgO1xcbiAgLS10dy1waW5jaC16b29tOiAgO1xcbiAgLS10dy1zY3JvbGwtc25hcC1zdHJpY3RuZXNzOiBwcm94aW1pdHk7XFxuICAtLXR3LW9yZGluYWw6ICA7XFxuICAtLXR3LXNsYXNoZWQtemVybzogIDtcXG4gIC0tdHctbnVtZXJpYy1maWd1cmU6ICA7XFxuICAtLXR3LW51bWVyaWMtc3BhY2luZzogIDtcXG4gIC0tdHctbnVtZXJpYy1mcmFjdGlvbjogIDtcXG4gIC0tdHctcmluZy1pbnNldDogIDtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDBweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmZmY7XFxuICAtLXR3LXJpbmctY29sb3I6IHJnYig1OSAxMzAgMjQ2IC8gMC41KTtcXG4gIC0tdHctcmluZy1vZmZzZXQtc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXJpbmctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCAwICMwMDAwO1xcbiAgLS10dy1ibHVyOiAgO1xcbiAgLS10dy1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1jb250cmFzdDogIDtcXG4gIC0tdHctZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1pbnZlcnQ6ICA7XFxuICAtLXR3LXNhdHVyYXRlOiAgO1xcbiAgLS10dy1zZXBpYTogIDtcXG4gIC0tdHctZHJvcC1zaGFkb3c6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJsdXI6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWludmVydDogIDtcXG4gIC0tdHctYmFja2Ryb3Atb3BhY2l0eTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2F0dXJhdGU6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNlcGlhOiAgO1xcbn1cXG4uYnRuIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDIuMjVyZW07XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNiA3MiAxNTMgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyNTAgMjUwIDI1MCAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmJ0bjpob3ZlciB7XFxuICAtLXR3LWJyaWdodG5lc3M6IGJyaWdodG5lc3MoMS4xKTtcXG4gIGZpbHRlcjogdmFyKC0tdHctYmx1cikgdmFyKC0tdHctYnJpZ2h0bmVzcykgdmFyKC0tdHctY29udHJhc3QpIHZhcigtLXR3LWdyYXlzY2FsZSkgdmFyKC0tdHctaHVlLXJvdGF0ZSkgdmFyKC0tdHctaW52ZXJ0KSB2YXIoLS10dy1zYXR1cmF0ZSkgdmFyKC0tdHctc2VwaWEpIHZhcigtLXR3LWRyb3Atc2hhZG93KTtcXG59XFxuLmJ0bjphY3RpdmUge1xcbiAgLS10dy1zY2FsZS14OiAuOTU7XFxuICAtLXR3LXNjYWxlLXk6IC45NTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uYnRuOmRpc2FibGVkIHtcXG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgb3BhY2l0eTogMC42O1xcbn1cXG4uYnRuPnN2ZzpmaXJzdC1jaGlsZCB7XFxuICBtYXJnaW4tbGVmdDogLTAuMjVyZW07XFxuICBtYXJnaW4tcmlnaHQ6IDAuMjVyZW07XFxufVxcbi5idG4+c3ZnOmxhc3QtY2hpbGQge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMC4yNXJlbTtcXG4gIG1hcmdpbi1sZWZ0OiAwLjI1cmVtO1xcbn1cXG4uaWNvbi1idG4ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGhlaWdodDogMi4yNXJlbTtcXG4gIHdpZHRoOiAyLjI1cmVtO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigxNjMgMTYzIDE2MyAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG4gIC0tdHctYmctb3BhY2l0eTogMDtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYig4MiA4MiA4MiAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmljb24tYnRuOmhvdmVyIHtcXG4gIC0tdHctYmctb3BhY2l0eTogMC4yO1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDIzIDIzIDIzIC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5pY29uLWJ0bjphY3RpdmUge1xcbiAgLS10dy1zY2FsZS14OiAuOTU7XFxuICAtLXR3LXNjYWxlLXk6IC45NTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uaWNvbi1idG46ZGlzYWJsZWQge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuICBvcGFjaXR5OiAwLjY7XFxufVxcbi5pbnB1dCB7XFxuICBoZWlnaHQ6IDIuMjVyZW07XFxuICBib3JkZXItcmFkaXVzOiAwLjI1cmVtO1xcbiAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjEyIDIxMiAyMTIgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDI0NSAyNDUgMjQ1IC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbiAgcGFkZGluZy10b3A6IDBweDtcXG4gIHBhZGRpbmctYm90dG9tOiAwcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDAuNzVyZW07XFxuICBwYWRkaW5nLXJpZ2h0OiAwLjc1cmVtO1xcbiAgZm9udC1zaXplOiAwLjg3NXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjI1cmVtO1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIC0tdHctdGV4dC1vcGFjaXR5OiAxO1xcbiAgY29sb3I6IHJnYigyMyAyMyAyMyAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbiAgb3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgb3V0bGluZS1vZmZzZXQ6IDJweDtcXG4gIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoMjEyIDIxMiAyMTIgLyB2YXIoLS10dy1yaW5nLW9wYWNpdHkpKTtcXG4gIC0tdHctcmluZy1vZmZzZXQtd2lkdGg6IDJweDtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmYWZhZmE7XFxufVxcbi5pbnB1dDo6LW1vei1wbGFjZWhvbGRlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTYzIDE2MyAxNjMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLmlucHV0OjpwbGFjZWhvbGRlciB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoMTYzIDE2MyAxNjMgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuLmlucHV0OmZvY3VzIHtcXG4gIG91dGxpbmU6IDJweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIG91dGxpbmUtb2Zmc2V0OiAycHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogdmFyKC0tdHctcmluZy1pbnNldCkgMCAwIDAgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpIHZhcigtLXR3LXJpbmctb2Zmc2V0LWNvbG9yKTtcXG4gIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIGNhbGMoMnB4ICsgdmFyKC0tdHctcmluZy1vZmZzZXQtd2lkdGgpKSB2YXIoLS10dy1yaW5nLWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93LCAwIDAgIzAwMDApO1xcbn1cXG4uaW5wdXQ6ZGlzYWJsZWQge1xcbiAgb3BhY2l0eTogMC42O1xcbn1cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuXFxuICAuaW5wdXQge1xcbiAgICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgICBib3JkZXItY29sb3I6IHJnYig4MiA4MiA4MiAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxuICAgIC0tdHctcmluZy1vcGFjaXR5OiAxO1xcbiAgICAtLXR3LXJpbmctY29sb3I6IHJnYig4MiA4MiA4MiAvIHZhcigtLXR3LXJpbmctb3BhY2l0eSkpO1xcbiAgICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjMTcxNzE3O1xcbiAgfVxcblxcbiAgLmlucHV0OjotbW96LXBsYWNlaG9sZGVyIHtcXG4gICAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICAgIGNvbG9yOiByZ2IoMTE1IDExNSAxMTUgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG4gIH1cXG5cXG4gIC5pbnB1dDo6cGxhY2Vob2xkZXIge1xcbiAgICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gICAgY29sb3I6IHJnYigxMTUgMTE1IDExNSAvIHZhcigtLXR3LXRleHQtb3BhY2l0eSkpO1xcbiAgfVxcbn1cXG4uY2hlY2tib3gge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgaGVpZ2h0OiAxLjI1cmVtO1xcbiAgd2lkdGg6IDEuMjVyZW07XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgICAgICAgIGFwcGVhcmFuY2U6IG5vbmU7XFxuICBib3JkZXItcmFkaXVzOiAwLjM3NXJlbTtcXG4gIGJvcmRlci13aWR0aDogMXB4O1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMTE1IDExNSAxMTUgLyAwLjYpO1xcbiAgb3V0bGluZTogMnB4IHNvbGlkIHRyYW5zcGFyZW50O1xcbiAgb3V0bGluZS1vZmZzZXQ6IDJweDtcXG4gIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG59XFxuLmNoZWNrYm94OjphZnRlciB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDFweDtcXG4gIGxlZnQ6IDVweDtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgaGVpZ2h0OiAwLjc1cmVtO1xcbiAgd2lkdGg6IDAuNXJlbTtcXG4gIC0tdHctcm90YXRlOiA0NWRlZztcXG4gIC0tdHctc2NhbGUteDogMDtcXG4gIC0tdHctc2NhbGUteTogMDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAycHg7XFxuICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjUwIDI1MCAyNTAgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogdHJhbnNmb3JtO1xcbiAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XFxuICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcXG4gIC0tdHctY29udGVudDogJyc7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG59XFxuLmNoZWNrYm94OmNoZWNrZWQge1xcbiAgLS10dy1ib3JkZXItb3BhY2l0eTogMTtcXG4gIGJvcmRlci1jb2xvcjogcmdiKDIzNiA3MiAxNTMgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbiAgLS10dy1iZy1vcGFjaXR5OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDIzNiA3MiAxNTMgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5jaGVja2JveDpjaGVja2VkOjphZnRlciB7XFxuICBjb250ZW50OiB2YXIoLS10dy1jb250ZW50KTtcXG4gIC0tdHctc2NhbGUteDogMTtcXG4gIC0tdHctc2NhbGUteTogMTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKHZhcigtLXR3LXRyYW5zbGF0ZS14KSwgdmFyKC0tdHctdHJhbnNsYXRlLXkpKSByb3RhdGUodmFyKC0tdHctcm90YXRlKSkgc2tld1godmFyKC0tdHctc2tldy14KSkgc2tld1kodmFyKC0tdHctc2tldy15KSkgc2NhbGVYKHZhcigtLXR3LXNjYWxlLXgpKSBzY2FsZVkodmFyKC0tdHctc2NhbGUteSkpO1xcbn1cXG4uY2hlY2tib3g6aG92ZXIge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5AbWVkaWEgKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKSB7XFxuXFxuICAuY2hlY2tib3g6Y2hlY2tlZCB7XFxuICAgIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICAgIGJvcmRlci1jb2xvcjogcmdiKDIzNiA3MiAxNTMgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbiAgICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYigyMzYgNzIgMTUzIC8gdmFyKC0tdHctYmctb3BhY2l0eSkpO1xcbiAgfVxcbn1cXG4ud3JhcHBlciB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiAzMnJlbTtcXG4gIHBhZGRpbmctbGVmdDogMS4yNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDEuMjVyZW07XFxuICBwYWRkaW5nLXRvcDogMnJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAycmVtO1xcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNjQwcHgpIHtcXG5cXG4gIC53cmFwcGVyIHtcXG4gICAgbWF4LXdpZHRoOiAzNnJlbTtcXG4gICAgcGFkZGluZy10b3A6IDNyZW07XFxuICAgIHBhZGRpbmctYm90dG9tOiAzcmVtO1xcbiAgfVxcbn1cXG5AbWVkaWEgKG1pbi13aWR0aDogNzY4cHgpIHtcXG5cXG4gIC53cmFwcGVyIHtcXG4gICAgbWF4LXdpZHRoOiA0OHJlbTtcXG4gIH1cXG59XFxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCkge1xcblxcbiAgLndyYXBwZXIge1xcbiAgICBtYXgtd2lkdGg6IDY0cmVtO1xcbiAgICBwYWRkaW5nLXRvcDogNXJlbTtcXG4gICAgcGFkZGluZy1ib3R0b206IDVyZW07XFxuICB9XFxufVxcbkBtZWRpYSAobWluLXdpZHRoOiAxMjgwcHgpIHtcXG5cXG4gIC53cmFwcGVyIHtcXG4gICAgbWF4LXdpZHRoOiA4MHJlbTtcXG4gIH1cXG59XFxuQGtleWZyYW1lcyBwdWxzZSB7XFxuXFxuICA1MCUge1xcbiAgICBvcGFjaXR5OiAuNTtcXG4gIH1cXG59XFxuLnNrZWxldG9uIHtcXG4gIGFuaW1hdGlvbjogcHVsc2UgMnMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC42LCAxKSBpbmZpbml0ZTtcXG4gIC0tdHctYmctb3BhY2l0eTogMTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYigyMTIgMjEyIDIxMiAvIHZhcigtLXR3LWJnLW9wYWNpdHkpKTtcXG4gIG9wYWNpdHk6IDAuMTtcXG59XFxuLm14LTIge1xcbiAgbWFyZ2luLWxlZnQ6IDAuNXJlbTtcXG4gIG1hcmdpbi1yaWdodDogMC41cmVtO1xcbn1cXG4ubXktMyB7XFxuICBtYXJnaW4tdG9wOiAwLjc1cmVtO1xcbiAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXG59XFxuLi1tbC0xIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMC4yNXJlbTtcXG59XFxuLi1tbC0yIHtcXG4gIG1hcmdpbi1sZWZ0OiAtMC41cmVtO1xcbn1cXG4uLW1yLTEge1xcbiAgbWFyZ2luLXJpZ2h0OiAtMC4yNXJlbTtcXG59XFxuLm1iLTMge1xcbiAgbWFyZ2luLWJvdHRvbTogMC43NXJlbTtcXG59XFxuLm1iLTUge1xcbiAgbWFyZ2luLWJvdHRvbTogMS4yNXJlbTtcXG59XFxuLmZsZXgge1xcbiAgZGlzcGxheTogZmxleDtcXG59XFxuLmgtMTIge1xcbiAgaGVpZ2h0OiAzcmVtO1xcbn1cXG4uaC04IHtcXG4gIGhlaWdodDogMnJlbTtcXG59XFxuLm1pbi1oLXNjcmVlbiB7XFxuICBtaW4taGVpZ2h0OiAxMDB2aDtcXG59XFxuLnctOCB7XFxuICB3aWR0aDogMnJlbTtcXG59XFxuLnctZnVsbCB7XFxuICB3aWR0aDogMTAwJTtcXG59XFxuLm1pbi13LTAge1xcbiAgbWluLXdpZHRoOiAwcHg7XFxufVxcbi5zaHJpbmstMCB7XFxuICBmbGV4LXNocmluazogMDtcXG59XFxuLmdyb3cge1xcbiAgZmxleC1ncm93OiAxO1xcbn1cXG4uY3Vyc29yLWRlZmF1bHQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG4uY3Vyc29yLWdyYWIge1xcbiAgY3Vyc29yOiBncmFiO1xcbn1cXG4udG91Y2gtbm9uZSB7XFxuICB0b3VjaC1hY3Rpb246IG5vbmU7XFxufVxcbi5zZWxlY3Qtbm9uZSB7XFxuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XFxufVxcbi5mbGV4LWNvbCB7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4uaXRlbXMtY2VudGVyIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcbi5qdXN0aWZ5LWNlbnRlciB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLmp1c3RpZnktYmV0d2VlbiB7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxufVxcbi5nYXAtMyB7XFxuICBnYXA6IDAuNzVyZW07XFxufVxcbi5yb3VuZGVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XFxufVxcbi5yb3VuZGVkLWZ1bGwge1xcbiAgYm9yZGVyLXJhZGl1czogOTk5OXB4O1xcbn1cXG4ucm91bmRlZC1tZCB7XFxuICBib3JkZXItcmFkaXVzOiAwLjM3NXJlbTtcXG59XFxuLmJvcmRlciB7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG59XFxuLmJvcmRlci1uZXV0cmFsLTIwMCB7XFxuICAtLXR3LWJvcmRlci1vcGFjaXR5OiAxO1xcbiAgYm9yZGVyLWNvbG9yOiByZ2IoMjI5IDIyOSAyMjkgLyB2YXIoLS10dy1ib3JkZXItb3BhY2l0eSkpO1xcbn1cXG4uYm9yZGVyLW5ldXRyYWwtMzAwIHtcXG4gIC0tdHctYm9yZGVyLW9wYWNpdHk6IDE7XFxuICBib3JkZXItY29sb3I6IHJnYigyMTIgMjEyIDIxMiAvIHZhcigtLXR3LWJvcmRlci1vcGFjaXR5KSk7XFxufVxcbi5iZy1uZXV0cmFsLTEwMCB7XFxuICAtLXR3LWJnLW9wYWNpdHk6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjQ1IDI0NSAyNDUgLyB2YXIoLS10dy1iZy1vcGFjaXR5KSk7XFxufVxcbi5iZy1uZXV0cmFsLTIwMFxcXFwvMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIyOSAyMjkgLyAwKTtcXG59XFxuLmJnLXBpbmstNTAwXFxcXC8yMCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjM2IDcyIDE1MyAvIDAuMik7XFxufVxcbi5weC0xIHtcXG4gIHBhZGRpbmctbGVmdDogMC4yNXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuMjVyZW07XFxufVxcbi5weC0zIHtcXG4gIHBhZGRpbmctbGVmdDogMC43NXJlbTtcXG4gIHBhZGRpbmctcmlnaHQ6IDAuNzVyZW07XFxufVxcbi5weS0xIHtcXG4gIHBhZGRpbmctdG9wOiAwLjI1cmVtO1xcbiAgcGFkZGluZy1ib3R0b206IDAuMjVyZW07XFxufVxcbi5weS0xXFxcXC41IHtcXG4gIHBhZGRpbmctdG9wOiAwLjM3NXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjM3NXJlbTtcXG59XFxuLnB5LTIge1xcbiAgcGFkZGluZy10b3A6IDAuNXJlbTtcXG4gIHBhZGRpbmctYm90dG9tOiAwLjVyZW07XFxufVxcbi50ZXh0LWxlZnQge1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG59XFxuLnRleHQtYmFzZSB7XFxuICBmb250LXNpemU6IDFyZW07XFxuICBsaW5lLWhlaWdodDogMS41cmVtO1xcbn1cXG4udGV4dC1zbSB7XFxuICBmb250LXNpemU6IDAuODc1cmVtO1xcbiAgbGluZS1oZWlnaHQ6IDEuMjVyZW07XFxufVxcbi50ZXh0LXhsIHtcXG4gIGZvbnQtc2l6ZTogMS4yNXJlbTtcXG4gIGxpbmUtaGVpZ2h0OiAxLjc1cmVtO1xcbn1cXG4uZm9udC1tZWRpdW0ge1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG59XFxuLmZvbnQtc2VtaWJvbGQge1xcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXG59XFxuLnRleHQtbmV1dHJhbC01MDAge1xcbiAgLS10dy10ZXh0LW9wYWNpdHk6IDE7XFxuICBjb2xvcjogcmdiKDExNSAxMTUgMTE1IC8gdmFyKC0tdHctdGV4dC1vcGFjaXR5KSk7XFxufVxcbi5saW5lLXRocm91Z2gge1xcbiAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IGxpbmUtdGhyb3VnaDtcXG59XFxuLm9wYWNpdHktNjAge1xcbiAgb3BhY2l0eTogMC42O1xcbn1cXG4uc2hhZG93LW1kIHtcXG4gIC0tdHctc2hhZG93OiAwIDRweCA2cHggLTFweCByZ2IoMCAwIDAgLyAwLjEpLCAwIDJweCA0cHggLTJweCByZ2IoMCAwIDAgLyAwLjEpO1xcbiAgLS10dy1zaGFkb3ctY29sb3JlZDogMCA0cHggNnB4IC0xcHggdmFyKC0tdHctc2hhZG93LWNvbG9yKSwgMCAycHggNHB4IC0ycHggdmFyKC0tdHctc2hhZG93LWNvbG9yKTtcXG4gIGJveC1zaGFkb3c6IHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdywgMCAwICMwMDAwKSwgdmFyKC0tdHctcmluZy1zaGFkb3csIDAgMCAjMDAwMCksIHZhcigtLXR3LXNoYWRvdyk7XFxufVxcbi5yaW5nLTIge1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQpIDAgMCAwIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSB2YXIoLS10dy1yaW5nLW9mZnNldC1jb2xvcik7XFxuICAtLXR3LXJpbmctc2hhZG93OiB2YXIoLS10dy1yaW5nLWluc2V0KSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvcik7XFxuICBib3gtc2hhZG93OiB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdywgMCAwICMwMDAwKTtcXG59XFxuLnJpbmctcGluay01MDBcXFxcLzUwIHtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDIzNiA3MiAxNTMgLyAwLjUpO1xcbn1cXG4ucmluZy1vZmZzZXQtMiB7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAycHg7XFxufVxcbi5yaW5nLW9mZnNldC1uZXV0cmFsLTUwIHtcXG4gIC0tdHctcmluZy1vZmZzZXQtY29sb3I6ICNmYWZhZmE7XFxufVxcbi50cmFuc2l0aW9uLWNvbG9ycyB7XFxuICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZTtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxufVxcbi50cmFuc2l0aW9uLW9wYWNpdHkge1xcbiAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogb3BhY2l0eTtcXG4gIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xcbiAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMTUwbXM7XFxufVxcblxcbmh0bWwsXFxuYm9keSB7XFxuICBwYWRkaW5nOiAwO1xcbiAgbWFyZ2luOiAwO1xcbiAgZm9udC1zaXplOiAxNnB4O1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG5cXG5hIHtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbn1cXG5cXG4qIHtcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcblxcbi5ob3ZlclxcXFw6YmctbmV1dHJhbC0yMDBcXFxcLzEwMDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMjI5IDIyOSAyMjkgLyAxKTtcXG59XFxuXFxuLmdyb3VwOmhvdmVyIC5ncm91cC1ob3ZlclxcXFw6dGV4dC1uZXV0cmFsLTcwMCB7XFxuICAtLXR3LXRleHQtb3BhY2l0eTogMTtcXG4gIGNvbG9yOiByZ2IoNjQgNjQgNjQgLyB2YXIoLS10dy10ZXh0LW9wYWNpdHkpKTtcXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDY0MHB4KSB7XFxuXFxuICAuc21cXFxcOm1iLTUge1xcbiAgICBtYXJnaW4tYm90dG9tOiAxLjI1cmVtO1xcbiAgfVxcblxcbiAgLnNtXFxcXDptYi04IHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMnJlbTtcXG4gIH1cXG5cXG4gIC5zbVxcXFw6dGV4dC0yeGwge1xcbiAgICBmb250LXNpemU6IDEuNXJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IDJyZW07XFxuICB9XFxuXFxuICAuc21cXFxcOnRleHQtbGcge1xcbiAgICBmb250LXNpemU6IDEuMTI1cmVtO1xcbiAgICBsaW5lLWhlaWdodDogMS43NXJlbTtcXG4gIH1cXG59XFxuXFxuQG1lZGlhIChtaW4td2lkdGg6IDEwMjRweCkge1xcblxcbiAgLmxnXFxcXDp0ZXh0LTN4bCB7XFxuICAgIGZvbnQtc2l6ZTogMS44NzVyZW07XFxuICAgIGxpbmUtaGVpZ2h0OiAyLjI1cmVtO1xcbiAgfVxcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vc3R5bGVzL2dsb2JhbHMuY3NzXCIsXCI8bm8gc291cmNlPlwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTs7Q0FBYyxDQUFkOzs7Q0FBYzs7QUFBZDs7O0VBQUEsc0JBQWMsRUFBZCxNQUFjO0VBQWQsZUFBYyxFQUFkLE1BQWM7RUFBZCxtQkFBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Ozs7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYyxFQUFkLE1BQWM7RUFBZCw4QkFBYyxFQUFkLE1BQWM7RUFBZCxnQkFBYyxFQUFkLE1BQWM7RUFBZCxjQUFjO0tBQWQsV0FBYyxFQUFkLE1BQWM7RUFBZCw0TkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCwrQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLG9CQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7RUFBQSxTQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0VBQWQscUJBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx5Q0FBYztVQUFkLGlDQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7OztFQUFBLGtCQUFjO0VBQWQsb0JBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7RUFBZCx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLG1CQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkOzs7O0VBQUEsK0dBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGNBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxjQUFjO0VBQWQsY0FBYztFQUFkLGtCQUFjO0VBQWQsd0JBQWM7QUFBQTs7QUFBZDtFQUFBLGVBQWM7QUFBQTs7QUFBZDtFQUFBLFdBQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkO0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxxQkFBYyxFQUFkLE1BQWM7RUFBZCx5QkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7OztDQUFjOztBQUFkOzs7OztFQUFBLG9CQUFjLEVBQWQsTUFBYztFQUFkLGVBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsb0JBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7RUFBZCxTQUFjLEVBQWQsTUFBYztFQUFkLFVBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsb0JBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7Ozs7RUFBQSwwQkFBYyxFQUFkLE1BQWM7RUFBZCw2QkFBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGFBQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGdCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSx3QkFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLFlBQWM7QUFBQTs7QUFBZDs7O0NBQWM7O0FBQWQ7RUFBQSw2QkFBYyxFQUFkLE1BQWM7RUFBZCxvQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLHdCQUFjO0FBQUE7O0FBQWQ7OztDQUFjOztBQUFkO0VBQUEsMEJBQWMsRUFBZCxNQUFjO0VBQWQsYUFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDtFQUFBLGtCQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7Ozs7Ozs7Ozs7Ozs7RUFBQSxTQUFjO0FBQUE7O0FBQWQ7RUFBQSxTQUFjO0VBQWQsVUFBYztBQUFBOztBQUFkO0VBQUEsVUFBYztBQUFBOztBQUFkOzs7RUFBQSxnQkFBYztFQUFkLFNBQWM7RUFBZCxVQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7RUFBQSxnQkFBYztBQUFBOztBQUFkOzs7Q0FBYzs7QUFBZDtFQUFBLFVBQWMsRUFBZCxNQUFjO0VBQWQsY0FBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7RUFBQSxVQUFjLEVBQWQsTUFBYztFQUFkLGNBQWMsRUFBZCxNQUFjO0FBQUE7O0FBQWQ7O0NBQWM7O0FBQWQ7O0VBQUEsZUFBYztBQUFBOztBQUFkOztDQUFjO0FBQWQ7RUFBQSxlQUFjO0FBQUE7O0FBQWQ7Ozs7Q0FBYzs7QUFBZDs7Ozs7Ozs7RUFBQSxjQUFjLEVBQWQsTUFBYztFQUFkLHNCQUFjLEVBQWQsTUFBYztBQUFBOztBQUFkOztDQUFjOztBQUFkOztFQUFBLGVBQWM7RUFBZCxZQUFjO0FBQUE7O0FBQWQsd0VBQWM7QUFBZDtFQUFBLGFBQWM7QUFBQTtFQUFkO0lBQUEsZUFBYztFQUFBOztFQUFkO0VBQUEsa0JBQWM7RUFBZCx5REFBYztFQUFkLDROQUFjO0VBQWQsZUFBYztFQUFkLG1CQUFjO0VBQWQsZ0JBQWM7RUFBZCxvQkFBYztFQUFkO0FBQWM7O0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFk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QUE7R0NBQTs7RURBQTtJQUFBO0dDQUE7O0VEQUE7SUFBQSxrQkNBQTtJREFBO0dDQUE7O0VEQUE7SUFBQSxvQkNBQTtJREFBO0dDQUE7Q0FBQTs7QURBQTs7RUFBQTtJQUFBLG9CQ0FBO0lEQUE7R0NBQTtDQUFBXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIkB0YWlsd2luZCBiYXNlO1xcbkB0YWlsd2luZCBjb21wb25lbnRzO1xcbkB0YWlsd2luZCB1dGlsaXRpZXM7XFxuXFxuaHRtbCxcXG5ib2R5IHtcXG4gIHBhZGRpbmc6IDA7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICAtd2Via2l0LWZvbnQtc21vb3RoaW5nOiBhbnRpYWxpYXNlZDtcXG4gIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7XFxufVxcblxcbmEge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxufVxcblxcbioge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuXFxuQGxheWVyIGJhc2Uge1xcbiAgaHRtbCB7XFxuICAgIGZvbnQtc2l6ZTogMTZweDtcXG4gIH1cXG5cXG4gIGJvZHkge1xcbiAgICBAYXBwbHkgZm9udC1zYW5zIGZvbnQtbm9ybWFsIHRleHQtYmFzZSB0ZXh0LW5ldXRyYWwtOTAwIGJnLW5ldXRyYWwtNTA7XFxuICB9XFxufVxcblxcbkBsYXllciBjb21wb25lbnRzIHtcXG4gIC5idG4ge1xcbiAgICBAYXBwbHkgYmctcGluay01MDAgdGV4dC1uZXV0cmFsLTUwIGgtOSByb3VuZGVkIHB4LTMgdGV4dC1zbSBmb250LXNlbWlib2xkIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGhvdmVyOmJyaWdodG5lc3MtMTEwIGFjdGl2ZTpzY2FsZS05NSB0cmFuc2l0aW9uLWFsbCBbJj5zdmc6bGFzdC1jaGlsZF06LW1yLTEgWyY+c3ZnOmxhc3QtY2hpbGRdOm1sLTEgWyY+c3ZnOmZpcnN0LWNoaWxkXTotbWwtMSBbJj5zdmc6Zmlyc3QtY2hpbGRdOm1yLTEgZGlzYWJsZWQ6b3BhY2l0eS02MCBkaXNhYmxlZDpwb2ludGVyLWV2ZW50cy1ub25lO1xcbiAgfVxcblxcbiAgLmljb24tYnRuIHtcXG4gICAgQGFwcGx5IHRleHQtbmV1dHJhbC02MDAgaG92ZXI6dGV4dC1uZXV0cmFsLTkwMCBoLTkgdy05IHJvdW5kZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctbmV1dHJhbC00MDAgYmctb3BhY2l0eS0wIGhvdmVyOmJnLW9wYWNpdHktMjAgYWN0aXZlOnNjYWxlLTk1IHRyYW5zaXRpb24tYWxsIGRpc2FibGVkOm9wYWNpdHktNjAgZGlzYWJsZWQ6cG9pbnRlci1ldmVudHMtbm9uZTtcXG4gIH1cXG5cXG4gIC5pbnB1dCB7XFxuICAgIEBhcHBseSBoLTkgcHktMCBweC0zIHRleHQtc20gZm9udC1tZWRpdW0gdGV4dC1uZXV0cmFsLTkwMCByb3VuZGVkIGJvcmRlciBiZy1uZXV0cmFsLTEwMCBib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgcGxhY2Vob2xkZXI6dGV4dC1uZXV0cmFsLTQwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtbmV1dHJhbC01MDAgb3V0bGluZS1ub25lIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgcmluZy1vZmZzZXQtMiByaW5nLW9mZnNldC1uZXV0cmFsLTUwIGRhcms6cmluZy1vZmZzZXQtbmV1dHJhbC05MDAgcmluZy1uZXV0cmFsLTMwMCBkYXJrOnJpbmctbmV1dHJhbC02MDAgZGlzYWJsZWQ6b3BhY2l0eS02MDtcXG4gIH1cXG5cXG4gIC50b2dnbGUge1xcbiAgICBAYXBwbHkgdy0xMSBoLTYgZmxleCBpdGVtcy1jZW50ZXIgZmxleC1zaHJpbmstMCBwLTAuNSBiZy1uZXV0cmFsLTUwMCByb3VuZGVkLWZ1bGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IHBlZXItY2hlY2tlZDpiZy1waW5rLTUwMCBhZnRlcjp3LTUgYWZ0ZXI6aC01IGFmdGVyOmJnLW5ldXRyYWwtNTAgYWZ0ZXI6cm91bmRlZC1mdWxsIGFmdGVyOmR1cmF0aW9uLTMwMCBwZWVyLWNoZWNrZWQ6YWZ0ZXI6dHJhbnNsYXRlLXgtNSBncm91cC1ob3ZlcjphZnRlcjpzY2FsZS0xMDUgcGVlci1kaXNhYmxlZDpvcGFjaXR5LTUwO1xcbiAgfVxcblxcbiAgLmNoZWNrYm94IHtcXG4gICAgQGFwcGx5IHJlbGF0aXZlIGgtNSB3LTUgYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtbWQgYm9yZGVyIGJvcmRlci1uZXV0cmFsLTUwMC82MCBvdXRsaW5lLW5vbmUgdHJhbnNpdGlvbi1jb2xvcnMgY2hlY2tlZDpib3JkZXItcGluay01MDAgY2hlY2tlZDpiZy1waW5rLTUwMCBhZnRlcjp0cmFuc2l0aW9uLXRyYW5zZm9ybSBhZnRlcjpzY2FsZS0wIGNoZWNrZWQ6YWZ0ZXI6c2NhbGUtMTAwIGFmdGVyOmFic29sdXRlIGFmdGVyOnRvcC1bMXB4XSBhZnRlcjpsZWZ0LVs1cHhdIGFmdGVyOmJsb2NrIGFmdGVyOmgtMyBhZnRlcjp3LTIgYWZ0ZXI6cm90YXRlLTQ1IGFmdGVyOmJvcmRlci1yLVsycHhdIGFmdGVyOmJvcmRlci1iLVsycHhdIGFmdGVyOmJvcmRlci1uZXV0cmFsLTUwIGFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXBpbmstNTAwIGRhcms6Y2hlY2tlZDpiZy1waW5rLTUwMDtcXG4gIH1cXG5cXG4gIC53cmFwcGVyIHtcXG4gICAgQGFwcGx5IG14LWF1dG8gcHgtNSBweS04IHNtOnB5LTEyIGxnOnB5LTIwIHctZnVsbCBtYXgtdy1sZyBzbTptYXgtdy14bCBtZDptYXgtdy0zeGwgbGc6bWF4LXctNXhsIHhsOm1heC13LTd4bDtcXG4gIH1cXG5cXG4gIC5za2VsZXRvbiB7XFxuICAgIEBhcHBseSBiZy1uZXV0cmFsLTMwMCBvcGFjaXR5LTEwIGFuaW1hdGUtcHVsc2U7XFxuICB9XFxufVxcblwiLG51bGxdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \****************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxxQkFBcUI7QUFDekU7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcz84NzgyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi8gLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBsaXN0ID0gW10gLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuICAgIDtcbiAgICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcbiAgICAgICAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICB9IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gICAgO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiBmaXggdHlwZVxuICAgIGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgICAgICAgbW9kdWxlcyA9IFtcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZXMsXG4gICAgICAgICAgICAgICAgICAgIFwiXCJcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG4gICAgICAgIGlmIChkZWR1cGUpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspe1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaV0pO1xuICAgICAgICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gbWVkaWFRdWVyeTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtWzJdID0gXCJcIi5jb25jYXQobWVkaWFRdWVyeSwgXCIgYW5kIFwiKS5jb25jYXQoaXRlbVsyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICAgIHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCBcIlwiIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgIDtcbiAgICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gICAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICAgICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8IFwiXCIpLmNvbmNhdChzb3VyY2UsIFwiICovXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgXS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtcbiAgICAgICAgICAgIHNvdXJjZU1hcHBpbmdcbiAgICAgICAgXSkuam9pbihcIlxcblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgY29udGVudFxuICAgIF0uam9pbihcIlxcblwiKTtcbn0gLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!":
/*!***********************************************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app! ***!
  \***********************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1jbGllbnQtcGFnZXMtbG9hZGVyLmpzP2Fic29sdXRlUGFnZVBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCZwYWdlPSUyRl9hcHAhLmpzIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsaURBQXlCO0FBQ2hEO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9mMDFlIl0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvX2FwcFwiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcInByaXZhdGUtbmV4dC1wYWdlcy9fYXBwXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9fYXBwXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!\n"));

/***/ }),

/***/ "./styles/globals.css":
/*!****************************!*\
  !*** ./styles/globals.css ***!
  \****************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\",\n      function () {\n        content = __webpack_require__(/*! !!../../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./globals.css */ \"../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[13].use[2]!./styles/globals.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ2xvYmFscy5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLDhOQUE4RztBQUNoSSwwQkFBMEIsbUJBQU8sQ0FBQywrZkFBNlA7O0FBRS9SOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxJQUFJLElBQVU7QUFDZCx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckIsTUFBTSwrZkFBNlA7QUFDblE7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQywrZkFBNlA7O0FBRXZSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3N0eWxlcy9nbG9iYWxzLmNzcz83MDE2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxM10udXNlWzFdIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxM10udXNlWzJdIS4vZ2xvYmFscy5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzEzXS51c2VbMV0hLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzEzXS51c2VbMl0hLi9nbG9iYWxzLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsxXSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTNdLnVzZVsyXSEuL2dsb2JhbHMuY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/globals.css\n"));

/***/ }),

/***/ "../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i1 = 0; i1 < lastIdentifiers.length; i1++){\n            const identifier = lastIdentifiers[i1];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxLQUF3QyxHQUFHLHNCQUFpQixHQUFHLENBQUk7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUVBQXFFLGdCQUFnQjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/ZGVmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IGlzT2xkSUUgPSBmdW5jdGlvbiBpc09sZElFKCkge1xuICAgIGxldCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgICAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xufSgpO1xuY29uc3QgZ2V0VGFyZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0IG1lbW8gPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUodGFyZ2V0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBsZXQgc3R5bGVUYXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuICAgICAgICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgICAgICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgICB9O1xufSgpO1xuY29uc3Qgc3R5bGVzSW5Eb20gPSBbXTtcbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBsZXQgcmVzdWx0ID0gLTE7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHN0eWxlc0luRG9tLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKHN0eWxlc0luRG9tW2ldLmlkZW50aWZpZXIgPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpZENvdW50TWFwID0ge307XG4gICAgY29uc3QgaWRlbnRpZmllcnMgPSBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBsaXN0W2ldO1xuICAgICAgICBjb25zdCBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgICAgICBjb25zdCBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZCArIFwiIFwiICsgY291bnQudG9TdHJpbmcoKTtcbiAgICAgICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgICAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgICAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG4gICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAgIHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnQgfHwgXCJoZWFkXCIpO1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgICBpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xufVxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovIGNvbnN0IHJlcGxhY2VUZXh0ID0gZnVuY3Rpb24gcmVwbGFjZVRleHQoKSB7XG4gICAgY29uc3QgdGV4dFN0b3JlID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbihcIlxcblwiKTtcbiAgICB9O1xufSgpO1xuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gICAgY29uc3QgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiICsgb2JqLm1lZGlhICsgXCIge1wiICsgb2JqLmNzcyArIFwifVwiIDogb2JqLmNzcztcbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcbiAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgX29wdGlvbnMsIG9iaikge1xuICAgIGxldCBjc3MgPSBvYmouY3NzO1xuICAgIGNvbnN0IG1lZGlhID0gb2JqLm1lZGlhO1xuICAgIGNvbnN0IHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKTtcbiAgICB9XG4gICAgaWYgKHNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG4gICAgfVxuICAgIC8vIEZvciBvbGQgSUVcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB3aGlsZShzdHlsZS5maXJzdENoaWxkKXtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgIH1cbn1cbmxldCBzaW5nbGV0b24gPSBudWxsO1xubGV0IHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gICAgbGV0IHN0eWxlO1xuICAgIGxldCB1cGRhdGU7XG4gICAgbGV0IHJlbW92ZTtcbiAgICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICAgICAgY29uc3Qgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICAgICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuICAgICAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuICAgICAgICByZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZShvYmopO1xuICAgIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICAgICAgaWYgKG5ld09iaikge1xuICAgICAgICAgICAgaWYgKG5ld09iai5jc3MgPT09IG9iai5jc3MgJiYgbmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiYgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gICAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuICAgIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgICB9XG4gICAgbGlzdCA9IGxpc3QgfHwgW107XG4gICAgbGV0IGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICAgICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcbiAgICAgICAgZm9yKGxldCBpMSA9IDA7IGkxIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaTErKyl7XG4gICAgICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2kxXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./pages/_app.tsx":
/*!************************!*\
  !*** ./pages/_app.tsx ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ App; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/styles/globals.css */ \"./styles/globals.css\");\n/* harmony import */ var _styles_globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_globals_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dayjs */ \"../../node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! dayjs/plugin/utc */ \"../../node_modules/dayjs/plugin/utc.js\");\n/* harmony import */ var dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! next/head */ \"../../node_modules/next/head.js\");\n/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _realtime_config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @/realtime.config */ \"./realtime.config.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\ndayjs__WEBPACK_IMPORTED_MODULE_2___default().extend((dayjs_plugin_utc__WEBPACK_IMPORTED_MODULE_3___default()));\nfunction App(param) {\n    let { Component , pageProps  } = param;\n    _s();\n    const startOfHour = (0,react__WEBPACK_IMPORTED_MODULE_6__.useMemo)(()=>dayjs__WEBPACK_IMPORTED_MODULE_2___default()().utc().format(\"YYMMDDHH\").toString(), []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_head__WEBPACK_IMPORTED_MODULE_4___default()), {\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"title\", {\n                    children: \"Realtime Example | Todo\"\n                }, void 0, false, {\n                    fileName: \"/Users/birkir/Code/Slate/realtime-examples/apps/todo/pages/_app.tsx\",\n                    lineNumber: 18,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/birkir/Code/Slate/realtime-examples/apps/todo/pages/_app.tsx\",\n                lineNumber: 17,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_realtime_config__WEBPACK_IMPORTED_MODULE_5__.RealtimeProvider, {\n                documentId: startOfHour,\n                publicAuthKey: \"public_ns02qVgk8WAblZhetmaZyAZPWiaz22l7VQb1CyNSHipHSq7C\",\n                throttle: 20,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                    ...pageProps\n                }, void 0, false, {\n                    fileName: \"/Users/birkir/Code/Slate/realtime-examples/apps/todo/pages/_app.tsx\",\n                    lineNumber: 25,\n                    columnNumber: 9\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/birkir/Code/Slate/realtime-examples/apps/todo/pages/_app.tsx\",\n                lineNumber: 20,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(App, \"pPsDKVi8I7Is7L+Euv5lMyoLr7M=\");\n_c = App;\nvar _c;\n$RefreshReg$(_c, \"App\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZCO0FBRUo7QUFDUztBQUVOO0FBRXdCO0FBQ3JCO0FBRS9CQSxtREFBWSxDQUFDQyx5REFBR0E7QUFFRCxTQUFTSyxJQUFJLEtBQWtDLEVBQUU7UUFBcEMsRUFBRUMsVUFBUyxFQUFFQyxVQUFTLEVBQVksR0FBbEM7O0lBQzFCLE1BQU1DLGNBQWNMLDhDQUFPQSxDQUFDLElBQU1KLDRDQUFLQSxHQUFHQyxHQUFHLEdBQUdTLE1BQU0sQ0FBQyxZQUFZQyxRQUFRLElBQUksRUFBRTtJQUNqRixxQkFDRTs7MEJBQ0UsOERBQUNULGtEQUFJQTswQkFDSCw0RUFBQ1U7OEJBQU07Ozs7Ozs7Ozs7OzBCQUVULDhEQUFDVCw4REFBZ0JBO2dCQUNmVSxZQUFZSjtnQkFDWkssZUFBZUMseURBQWdEO2dCQUMvREcsVUFBVTswQkFFViw0RUFBQ1g7b0JBQVcsR0FBR0MsU0FBUzs7Ozs7Ozs7Ozs7OztBQUloQyxDQUFDO0dBaEJ1QkY7S0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC50c3g/MmZiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ0Avc3R5bGVzL2dsb2JhbHMuY3NzJ1xuXG5pbXBvcnQgZGF5anMgZnJvbSAnZGF5anMnXG5pbXBvcnQgdXRjIGZyb20gJ2RheWpzL3BsdWdpbi91dGMnXG5pbXBvcnQgdHlwZSB7IEFwcFByb3BzIH0gZnJvbSAnbmV4dC9hcHAnXG5pbXBvcnQgSGVhZCBmcm9tICduZXh0L2hlYWQnXG5cbmltcG9ydCB7IFJlYWx0aW1lUHJvdmlkZXIgfSBmcm9tICdAL3JlYWx0aW1lLmNvbmZpZydcbmltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcblxuZGF5anMuZXh0ZW5kKHV0YylcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHMgfTogQXBwUHJvcHMpIHtcbiAgY29uc3Qgc3RhcnRPZkhvdXIgPSB1c2VNZW1vKCgpID0+IGRheWpzKCkudXRjKCkuZm9ybWF0KCdZWU1NRERISCcpLnRvU3RyaW5nKCksIFtdKVxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8SGVhZD5cbiAgICAgICAgPHRpdGxlPlJlYWx0aW1lIEV4YW1wbGUgfCBUb2RvPC90aXRsZT5cbiAgICAgIDwvSGVhZD5cbiAgICAgIDxSZWFsdGltZVByb3ZpZGVyXG4gICAgICAgIGRvY3VtZW50SWQ9e3N0YXJ0T2ZIb3VyfVxuICAgICAgICBwdWJsaWNBdXRoS2V5PXtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SRUFMVElNRV9QVUJMSUNfQVVUSF9LRVl9XG4gICAgICAgIHRocm90dGxlPXsyMH1cbiAgICAgID5cbiAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgPC9SZWFsdGltZVByb3ZpZGVyPlxuICAgIDwvPlxuICApXG59XG4iXSwibmFtZXMiOlsiZGF5anMiLCJ1dGMiLCJIZWFkIiwiUmVhbHRpbWVQcm92aWRlciIsInVzZU1lbW8iLCJleHRlbmQiLCJBcHAiLCJDb21wb25lbnQiLCJwYWdlUHJvcHMiLCJzdGFydE9mSG91ciIsImZvcm1hdCIsInRvU3RyaW5nIiwidGl0bGUiLCJkb2N1bWVudElkIiwicHVibGljQXV0aEtleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19SRUFMVElNRV9QVUJMSUNfQVVUSF9LRVkiLCJ0aHJvdHRsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/_app.tsx\n"));

/***/ }),

/***/ "./realtime.config.ts":
/*!****************************!*\
  !*** ./realtime.config.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RealtimeProvider\": function() { return /* binding */ RealtimeProvider; },\n/* harmony export */   \"useBroadcast\": function() { return /* binding */ useBroadcast; },\n/* harmony export */   \"useBroadcastListener\": function() { return /* binding */ useBroadcastListener; },\n/* harmony export */   \"useCollaborators\": function() { return /* binding */ useCollaborators; },\n/* harmony export */   \"useConnectionStatus\": function() { return /* binding */ useConnectionStatus; },\n/* harmony export */   \"useDocumentStatus\": function() { return /* binding */ useDocumentStatus; },\n/* harmony export */   \"useMe\": function() { return /* binding */ useMe; },\n/* harmony export */   \"usePatch\": function() { return /* binding */ usePatch; },\n/* harmony export */   \"usePatchMe\": function() { return /* binding */ usePatchMe; },\n/* harmony export */   \"usePresenceStatus\": function() { return /* binding */ usePresenceStatus; },\n/* harmony export */   \"useRealtimeContext\": function() { return /* binding */ useRealtimeContext; },\n/* harmony export */   \"useStore\": function() { return /* binding */ useStore; },\n/* harmony export */   \"useSubscribe\": function() { return /* binding */ useSubscribe; },\n/* harmony export */   \"useSubscribeCollaborators\": function() { return /* binding */ useSubscribeCollaborators; },\n/* harmony export */   \"useSubscribeMe\": function() { return /* binding */ useSubscribeMe; }\n/* harmony export */ });\n/* harmony import */ var _inrealtime_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @inrealtime/react */ \"../../node_modules/@inrealtime/react/dist/index.js\");\n/* harmony import */ var _inrealtime_react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_inrealtime_react__WEBPACK_IMPORTED_MODULE_0__);\n\nconst { RealtimeProvider , useRealtimeContext , usePresenceStatus , useConnectionStatus , useDocumentStatus , useStore , usePatch , useSubscribe , useCollaborators , useSubscribeCollaborators , useMe , usePatchMe , useSubscribeMe , useBroadcast , useBroadcastListener  } = (0,_inrealtime_react__WEBPACK_IMPORTED_MODULE_0__.createRealtimeContext)();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZWFsdGltZS5jb25maWcudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBeUQ7QUFrQmxELE1BQU0sRUFDWEMsaUJBQWdCLEVBQ2hCQyxtQkFBa0IsRUFDbEJDLGtCQUFpQixFQUNqQkMsb0JBQW1CLEVBQ25CQyxrQkFBaUIsRUFDakJDLFNBQVEsRUFDUkMsU0FBUSxFQUNSQyxhQUFZLEVBQ1pDLGlCQUFnQixFQUNoQkMsMEJBQXlCLEVBQ3pCQyxNQUFLLEVBQ0xDLFdBQVUsRUFDVkMsZUFBYyxFQUNkQyxhQUFZLEVBQ1pDLHFCQUFvQixFQUNyQixHQUFHZix3RUFBcUJBLEdBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3JlYWx0aW1lLmNvbmZpZy50cz9mNjZhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZVJlYWx0aW1lQ29udGV4dCB9IGZyb20gJ0BpbnJlYWx0aW1lL3JlYWN0J1xuXG5leHBvcnQgaW50ZXJmYWNlIFRvZG9JdGVtIHtcbiAgaWQ6IHN0cmluZ1xuICBsYWJlbDogc3RyaW5nXG4gIGlzQ29tcGxldGVkOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFJlYWx0aW1lRG9jdW1lbnQgPSB7XG4gIHRvZG9zOiBUb2RvSXRlbVtdXG59XG5cbmV4cG9ydCB0eXBlIFByZXNlbmNlRGF0YSA9IHtcbiAgaWQ6IHN0cmluZ1xuICBlbW9qaT86IHN0cmluZ1xuICBjdXJzb3I/OiB7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfVxufVxuXG5leHBvcnQgY29uc3Qge1xuICBSZWFsdGltZVByb3ZpZGVyLFxuICB1c2VSZWFsdGltZUNvbnRleHQsXG4gIHVzZVByZXNlbmNlU3RhdHVzLFxuICB1c2VDb25uZWN0aW9uU3RhdHVzLFxuICB1c2VEb2N1bWVudFN0YXR1cyxcbiAgdXNlU3RvcmUsXG4gIHVzZVBhdGNoLFxuICB1c2VTdWJzY3JpYmUsXG4gIHVzZUNvbGxhYm9yYXRvcnMsXG4gIHVzZVN1YnNjcmliZUNvbGxhYm9yYXRvcnMsXG4gIHVzZU1lLFxuICB1c2VQYXRjaE1lLFxuICB1c2VTdWJzY3JpYmVNZSxcbiAgdXNlQnJvYWRjYXN0LFxuICB1c2VCcm9hZGNhc3RMaXN0ZW5lcixcbn0gPSBjcmVhdGVSZWFsdGltZUNvbnRleHQ8UmVhbHRpbWVEb2N1bWVudCwgUHJlc2VuY2VEYXRhPigpXG4iXSwibmFtZXMiOlsiY3JlYXRlUmVhbHRpbWVDb250ZXh0IiwiUmVhbHRpbWVQcm92aWRlciIsInVzZVJlYWx0aW1lQ29udGV4dCIsInVzZVByZXNlbmNlU3RhdHVzIiwidXNlQ29ubmVjdGlvblN0YXR1cyIsInVzZURvY3VtZW50U3RhdHVzIiwidXNlU3RvcmUiLCJ1c2VQYXRjaCIsInVzZVN1YnNjcmliZSIsInVzZUNvbGxhYm9yYXRvcnMiLCJ1c2VTdWJzY3JpYmVDb2xsYWJvcmF0b3JzIiwidXNlTWUiLCJ1c2VQYXRjaE1lIiwidXNlU3Vic2NyaWJlTWUiLCJ1c2VCcm9hZGNhc3QiLCJ1c2VCcm9hZGNhc3RMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./realtime.config.ts\n"));

/***/ }),

/***/ "../../node_modules/next/head.js":
/*!***************************************!*\
  !*** ../../node_modules/next/head.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/shared/lib/head */ \"../../node_modules/next/dist/shared/lib/head.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvaGVhZC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxSEFBa0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2hlYWQuanM/NmIzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9zaGFyZWQvbGliL2hlYWQnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/head.js\n"));

/***/ }),

/***/ "../../node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE;\n\n{\n  REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n}\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsZ0RBQU87O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFH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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQSxr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R0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz9hZmFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7IC8vIFRyYWNrIHdoaWNoIEZpYmVyKHMpIHNjaGVkdWxlIHJlbmRlciB3b3JrLlxuXG52YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcblxue1xuICBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QubW9kdWxlLnJlZmVyZW5jZScpO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICggIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMnICsgJyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IkMSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcbnZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbnZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbnZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmID09PSAnc3RyaW5nJyAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViQxID0gIGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "../../node_modules/react/jsx-dev-runtime.js":
/*!***************************************************!*\
  !*** ../../node_modules/react/jsx-dev-runtime.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"../../node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsMkpBQXNFO0FBQ3hFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzPzZjODMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js ***!
  \**************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n// dispatch for CommonJS interop named imports.\n\nvar useState = React.useState,\n    useEffect = React.useEffect,\n    useLayoutEffect = React.useLayoutEffect,\n    useDebugValue = React.useDebugValue;\nvar didWarnOld18Alpha = false;\nvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n// because of a very particular set of implementation details and assumptions\n// -- change any one of them and it will break. The most important assumption\n// is that updates are always synchronous, because concurrent rendering is\n// only available in versions of React that also have a built-in\n// useSyncExternalStore API. And we only use this shim when the built-in API\n// does not exist.\n//\n// Do not assume that the clever hacks used by this hook also work in general.\n// The point of this shim is to replace the need for hacks by other libraries.\n\nfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n// React do not expose a way to check if we're hydrating. So users of the shim\n// will need to track that themselves and return the correct value\n// from `getSnapshot`.\ngetServerSnapshot) {\n  {\n    if (!didWarnOld18Alpha) {\n      if (React.startTransition !== undefined) {\n        didWarnOld18Alpha = true;\n\n        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n      }\n    }\n  } // Read the current snapshot from the store on every render. Again, this\n  // breaks the rules of React, and only works here because of specific\n  // implementation details, most importantly that updates are\n  // always synchronous.\n\n\n  var value = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedValue = getSnapshot();\n\n      if (!objectIs(value, cachedValue)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  } // Because updates are synchronous, we don't queue them. Instead we force a\n  // re-render whenever the subscribed state changes by updating an some\n  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n  // the current value.\n  //\n  // Because we don't actually use the state returned by the useState hook, we\n  // can save a bit of memory by storing other stuff in that slot.\n  //\n  // To implement the early bailout, we need to track some things on a mutable\n  // object. Usually, we would put that in a useRef hook, but we can stash it in\n  // our useState hook instead.\n  //\n  // To force a re-render, we call forceUpdate({inst}). That works because the\n  // new object always fails an equality check.\n\n\n  var _useState = useState({\n    inst: {\n      value: value,\n      getSnapshot: getSnapshot\n    }\n  }),\n      inst = _useState[0].inst,\n      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n  // in the layout phase so we can access it during the tearing check that\n  // happens on subscribe.\n\n\n  useLayoutEffect(function () {\n    inst.value = value;\n    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n    // commit phase if there was an interleaved mutation. In concurrent mode\n    // this can happen all the time, but even in synchronous mode, an earlier\n    // effect may have mutated the store.\n\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n  }, [subscribe, value, getSnapshot]);\n  useEffect(function () {\n    // Check for changes right before subscribing. Subsequent changes will be\n    // detected in the subscription handler.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceUpdate({\n        inst: inst\n      });\n    }\n\n    var handleStoreChange = function () {\n      // TODO: Because there is no cross-renderer API for batching updates, it's\n      // up to the consumer of this library to wrap their subscription event\n      // with unstable_batchedUpdates. Should we try to detect when this isn't\n      // the case and print a warning in development?\n      // The store changed. Check if the snapshot changed since the last time we\n      // read from the store.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({\n          inst: inst\n        });\n      }\n    }; // Subscribe to the store and return a clean-up function.\n\n\n    return subscribe(handleStoreChange);\n  }, [subscribe]);\n  useDebugValue(value);\n  return value;\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n  // React do not expose a way to check if we're hydrating. So users of the shim\n  // will need to track that themselves and return the correct value\n  // from `getSnapshot`.\n  return getSnapshot();\n}\n\nvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\nvar isServerEnvironment = !canUseDOM;\n\nvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\nvar useSyncExternalStore$2 = React.useSyncExternalStore !== undefined ? React.useSyncExternalStore : shim;\n\nexports.useSyncExternalStore = useSyncExternalStore$2;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxnREFBTzs7QUFFckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzPzQyNDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cbi8vIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciB1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlLFxuICAgIHVzZUVmZmVjdCA9IFJlYWN0LnVzZUVmZmVjdCxcbiAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdC51c2VMYXlvdXRFZmZlY3QsXG4gICAgdXNlRGVidWdWYWx1ZSA9IFJlYWN0LnVzZURlYnVnVmFsdWU7XG52YXIgZGlkV2Fybk9sZDE4QWxwaGEgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IGZhbHNlOyAvLyBEaXNjbGFpbWVyOiBUaGlzIHNoaW0gYnJlYWtzIG1hbnkgb2YgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3Jrc1xuLy8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcbi8vIC0tIGNoYW5nZSBhbnkgb25lIG9mIHRoZW0gYW5kIGl0IHdpbGwgYnJlYWsuIFRoZSBtb3N0IGltcG9ydGFudCBhc3N1bXB0aW9uXG4vLyBpcyB0aGF0IHVwZGF0ZXMgYXJlIGFsd2F5cyBzeW5jaHJvbm91cywgYmVjYXVzZSBjb25jdXJyZW50IHJlbmRlcmluZyBpc1xuLy8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuLy8gdXNlU3luY0V4dGVybmFsU3RvcmUgQVBJLiBBbmQgd2Ugb25seSB1c2UgdGhpcyBzaGltIHdoZW4gdGhlIGJ1aWx0LWluIEFQSVxuLy8gZG9lcyBub3QgZXhpc3QuXG4vL1xuLy8gRG8gbm90IGFzc3VtZSB0aGF0IHRoZSBjbGV2ZXIgaGFja3MgdXNlZCBieSB0aGlzIGhvb2sgYWxzbyB3b3JrIGluIGdlbmVyYWwuXG4vLyBUaGUgcG9pbnQgb2YgdGhpcyBzaGltIGlzIHRvIHJlcGxhY2UgdGhlIG5lZWQgZm9yIGhhY2tzIGJ5IG90aGVyIGxpYnJhcmllcy5cblxuZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4vLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcbi8vIGZyb20gYGdldFNuYXBzaG90YC5cbmdldFNlcnZlclNuYXBzaG90KSB7XG4gIHtcbiAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG4gICAgICBpZiAoUmVhY3Quc3RhcnRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdZb3UgYXJlIHVzaW5nIGFuIG91dGRhdGVkLCBwcmUtcmVsZWFzZSBhbHBoYSBvZiBSZWFjdCAxOCB0aGF0ICcgKyAnZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlICcgKyAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUgc2hpbSB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseS4gVXBncmFkZSAnICsgJ3RvIGEgbmV3ZXIgcHJlLXJlbGVhc2UuJyk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBBZ2FpbiwgdGhpc1xuICAvLyBicmVha3MgdGhlIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBoZXJlIGJlY2F1c2Ugb2Ygc3BlY2lmaWNcbiAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuXG4gIHZhciB2YWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAge1xuICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIEJlY2F1c2UgdXBkYXRlcyBhcmUgc3luY2hyb25vdXMsIHdlIGRvbid0IHF1ZXVlIHRoZW0uIEluc3RlYWQgd2UgZm9yY2UgYVxuICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG4gIC8vIGFyYml0cmFyeSB1c2VTdGF0ZSBob29rLiBUaGVuLCBkdXJpbmcgcmVuZGVyLCB3ZSBjYWxsIGdldFNuYXBzaG90IHRvIHJlYWRcbiAgLy8gdGhlIGN1cnJlbnQgdmFsdWUuXG4gIC8vXG4gIC8vIEJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgdXNlIHRoZSBzdGF0ZSByZXR1cm5lZCBieSB0aGUgdXNlU3RhdGUgaG9vaywgd2VcbiAgLy8gY2FuIHNhdmUgYSBiaXQgb2YgbWVtb3J5IGJ5IHN0b3Jpbmcgb3RoZXIgc3R1ZmYgaW4gdGhhdCBzbG90LlxuICAvL1xuICAvLyBUbyBpbXBsZW1lbnQgdGhlIGVhcmx5IGJhaWxvdXQsIHdlIG5lZWQgdG8gdHJhY2sgc29tZSB0aGluZ3Mgb24gYSBtdXRhYmxlXG4gIC8vIG9iamVjdC4gVXN1YWxseSwgd2Ugd291bGQgcHV0IHRoYXQgaW4gYSB1c2VSZWYgaG9vaywgYnV0IHdlIGNhbiBzdGFzaCBpdCBpblxuICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuICAvL1xuICAvLyBUbyBmb3JjZSBhIHJlLXJlbmRlciwgd2UgY2FsbCBmb3JjZVVwZGF0ZSh7aW5zdH0pLiBUaGF0IHdvcmtzIGJlY2F1c2UgdGhlXG4gIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKHtcbiAgICBpbnN0OiB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3RcbiAgICB9XG4gIH0pLFxuICAgICAgaW5zdCA9IF91c2VTdGF0ZVswXS5pbnN0LFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlU3RhdGVbMV07IC8vIFRyYWNrIHRoZSBsYXRlc3QgZ2V0U25hcHNob3QgZnVuY3Rpb24gd2l0aCBhIHJlZi4gVGhpcyBuZWVkcyB0byBiZSB1cGRhdGVkXG4gIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuICAvLyBoYXBwZW5zIG9uIHN1YnNjcmliZS5cblxuXG4gIHVzZUxheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuICAgIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuICAgIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbc3Vic2NyaWJlLCB2YWx1ZSwgZ2V0U25hcHNob3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyByaWdodCBiZWZvcmUgc3Vic2NyaWJpbmcuIFN1YnNlcXVlbnQgY2hhbmdlcyB3aWxsIGJlXG4gICAgLy8gZGV0ZWN0ZWQgaW4gdGhlIHN1YnNjcmlwdGlvbiBoYW5kbGVyLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgaW5zdDogaW5zdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVE9ETzogQmVjYXVzZSB0aGVyZSBpcyBubyBjcm9zcy1yZW5kZXJlciBBUEkgZm9yIGJhdGNoaW5nIHVwZGF0ZXMsIGl0J3NcbiAgICAgIC8vIHVwIHRvIHRoZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnkgdG8gd3JhcCB0aGVpciBzdWJzY3JpcHRpb24gZXZlbnRcbiAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuICAgICAgLy8gdGhlIGNhc2UgYW5kIHByaW50IGEgd2FybmluZyBpbiBkZXZlbG9wbWVudD9cbiAgICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgICAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICAgIGZvcmNlVXBkYXRlKHtcbiAgICAgICAgICBpbnN0OiBpbnN0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07IC8vIFN1YnNjcmliZSB0byB0aGUgc3RvcmUgYW5kIHJldHVybiBhIGNsZWFuLXVwIGZ1bmN0aW9uLlxuXG5cbiAgICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbiAgfSwgW3N1YnNjcmliZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQxKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2ZcbiAgLy8gUmVhY3QgZG8gbm90IGV4cG9zZSBhIHdheSB0byBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcuIFNvIHVzZXJzIG9mIHRoZSBzaGltXG4gIC8vIHdpbGwgbmVlZCB0byB0cmFjayB0aGF0IHRoZW1zZWx2ZXMgYW5kIHJldHVybiB0aGUgY29ycmVjdCB2YWx1ZVxuICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG4gIHJldHVybiBnZXRTbmFwc2hvdCgpO1xufVxuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cbnZhciBpc1NlcnZlckVudmlyb25tZW50ID0gIWNhblVzZURPTTtcblxudmFyIHNoaW0gPSBpc1NlcnZlckVudmlyb25tZW50ID8gdXNlU3luY0V4dGVybmFsU3RvcmUkMSA6IHVzZVN5bmNFeHRlcm5hbFN0b3JlO1xudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdC51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdW5kZWZpbmVkID8gUmVhY3QudXNlU3luY0V4dGVybmFsU3RvcmUgOiBzaGltO1xuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gdXNlU3luY0V4dGVybmFsU3RvcmUkMjtcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\n"));

/***/ }),

/***/ "../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js":
/*!****************************************************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js ***!
  \****************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var React = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\nvar shim = __webpack_require__(/*! use-sync-external-store/shim */ \"../../node_modules/use-sync-external-store/shim/index.js\");\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar useSyncExternalStore = shim.useSyncExternalStore;\n\n// for CommonJS interop.\n\nvar useRef = React.useRef,\n    useEffect = React.useEffect,\n    useMemo = React.useMemo,\n    useDebugValue = React.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\nfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n  // Use this to track the rendered snapshot.\n  var instRef = useRef(null);\n  var inst;\n\n  if (instRef.current === null) {\n    inst = {\n      hasValue: false,\n      value: null\n    };\n    instRef.current = inst;\n  } else {\n    inst = instRef.current;\n  }\n\n  var _useMemo = useMemo(function () {\n    // Track the memoized state using closure variables that are local to this\n    // memoized instance of a getSnapshot function. Intentionally not using a\n    // useRef hook, because that state would be shared across all concurrent\n    // copies of the hook/component.\n    var hasMemo = false;\n    var memoizedSnapshot;\n    var memoizedSelection;\n\n    var memoizedSelector = function (nextSnapshot) {\n      if (!hasMemo) {\n        // The first time the hook is called, there is no memoized result.\n        hasMemo = true;\n        memoizedSnapshot = nextSnapshot;\n\n        var _nextSelection = selector(nextSnapshot);\n\n        if (isEqual !== undefined) {\n          // Even if the selector has changed, the currently rendered selection\n          // may be equal to the new selection. We should attempt to reuse the\n          // current value if possible, to preserve downstream memoizations.\n          if (inst.hasValue) {\n            var currentSelection = inst.value;\n\n            if (isEqual(currentSelection, _nextSelection)) {\n              memoizedSelection = currentSelection;\n              return currentSelection;\n            }\n          }\n        }\n\n        memoizedSelection = _nextSelection;\n        return _nextSelection;\n      } // We may be able to reuse the previous invocation's result.\n\n\n      // We may be able to reuse the previous invocation's result.\n      var prevSnapshot = memoizedSnapshot;\n      var prevSelection = memoizedSelection;\n\n      if (objectIs(prevSnapshot, nextSnapshot)) {\n        // The snapshot is the same as last time. Reuse the previous selection.\n        return prevSelection;\n      } // The snapshot has changed, so we need to compute a new selection.\n\n\n      // The snapshot has changed, so we need to compute a new selection.\n      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n\n      // If a custom isEqual function is provided, use that to check if the data\n      // has changed. If it hasn't, return the previous selection. That signals\n      // to React that the selections are conceptually equal, and we can bail\n      // out of rendering.\n      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n        return prevSelection;\n      }\n\n      memoizedSnapshot = nextSnapshot;\n      memoizedSelection = nextSelection;\n      return nextSelection;\n    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n    // Assigning this to a constant so that Flow knows it can't change.\n    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n    var getSnapshotWithSelector = function () {\n      return memoizedSelector(getSnapshot());\n    };\n\n    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n      return memoizedSelector(maybeGetServerSnapshot());\n    };\n    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n      getSelection = _useMemo[0],\n      getServerSelection = _useMemo[1];\n\n  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n  useEffect(function () {\n    inst.hasValue = true;\n    inst.value = value;\n  }, [value]);\n  useDebugValue(value);\n  return value;\n}\n\nexports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IuZGV2ZWxvcG1lbnQuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLGdEQUFPO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyw4RkFBOEI7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcz9hNzQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbmlmIChcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xufVxuICAgICAgICAgIHZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0nKTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxudmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlID0gc2hpbS51c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblxuLy8gZm9yIENvbW1vbkpTIGludGVyb3AuXG5cbnZhciB1c2VSZWYgPSBSZWFjdC51c2VSZWYsXG4gICAgdXNlRWZmZWN0ID0gUmVhY3QudXNlRWZmZWN0LFxuICAgIHVzZU1lbW8gPSBSZWFjdC51c2VNZW1vLFxuICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdC51c2VEZWJ1Z1ZhbHVlOyAvLyBTYW1lIGFzIHVzZVN5bmNFeHRlcm5hbFN0b3JlLCBidXQgc3VwcG9ydHMgc2VsZWN0b3IgYW5kIGlzRXF1YWwgYXJndW1lbnRzLlxuXG5mdW5jdGlvbiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3RvcihzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCwgc2VsZWN0b3IsIGlzRXF1YWwpIHtcbiAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuICB2YXIgaW5zdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGluc3Q7XG5cbiAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGluc3QgPSB7XG4gICAgICBoYXNWYWx1ZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbFxuICAgIH07XG4gICAgaW5zdFJlZi5jdXJyZW50ID0gaW5zdDtcbiAgfSBlbHNlIHtcbiAgICBpbnN0ID0gaW5zdFJlZi5jdXJyZW50O1xuICB9XG5cbiAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gVHJhY2sgdGhlIG1lbW9pemVkIHN0YXRlIHVzaW5nIGNsb3N1cmUgdmFyaWFibGVzIHRoYXQgYXJlIGxvY2FsIHRvIHRoaXNcbiAgICAvLyBtZW1vaXplZCBpbnN0YW5jZSBvZiBhIGdldFNuYXBzaG90IGZ1bmN0aW9uLiBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhXG4gICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG4gICAgLy8gY29waWVzIG9mIHRoZSBob29rL2NvbXBvbmVudC5cbiAgICB2YXIgaGFzTWVtbyA9IGZhbHNlO1xuICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuICAgIHZhciBtZW1vaXplZFNlbGVjdGlvbjtcblxuICAgIHZhciBtZW1vaXplZFNlbGVjdG9yID0gZnVuY3Rpb24gKG5leHRTbmFwc2hvdCkge1xuICAgICAgaWYgKCFoYXNNZW1vKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHRoZSBob29rIGlzIGNhbGxlZCwgdGhlcmUgaXMgbm8gbWVtb2l6ZWQgcmVzdWx0LlxuICAgICAgICBoYXNNZW1vID0gdHJ1ZTtcbiAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuICAgICAgICB2YXIgX25leHRTZWxlY3Rpb24gPSBzZWxlY3RvcihuZXh0U25hcHNob3QpO1xuXG4gICAgICAgIGlmIChpc0VxdWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cbiAgICAgICAgICAvLyBtYXkgYmUgZXF1YWwgdG8gdGhlIG5ldyBzZWxlY3Rpb24uIFdlIHNob3VsZCBhdHRlbXB0IHRvIHJldXNlIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgdmFsdWUgaWYgcG9zc2libGUsIHRvIHByZXNlcnZlIGRvd25zdHJlYW0gbWVtb2l6YXRpb25zLlxuICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGluc3QudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0VxdWFsKGN1cnJlbnRTZWxlY3Rpb24sIF9uZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgIHJldHVybiBjdXJyZW50U2VsZWN0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lbW9pemVkU2VsZWN0aW9uID0gX25leHRTZWxlY3Rpb247XG4gICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcbiAgICAgIH0gLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG5cblxuICAgICAgLy8gV2UgbWF5IGJlIGFibGUgdG8gcmV1c2UgdGhlIHByZXZpb3VzIGludm9jYXRpb24ncyByZXN1bHQuXG4gICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcbiAgICAgIHZhciBwcmV2U2VsZWN0aW9uID0gbWVtb2l6ZWRTZWxlY3Rpb247XG5cbiAgICAgIGlmIChvYmplY3RJcyhwcmV2U25hcHNob3QsIG5leHRTbmFwc2hvdCkpIHtcbiAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG4gICAgICB9IC8vIFRoZSBzbmFwc2hvdCBoYXMgY2hhbmdlZCwgc28gd2UgbmVlZCB0byBjb21wdXRlIGEgbmV3IHNlbGVjdGlvbi5cblxuXG4gICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG4gICAgICB2YXIgbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7IC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG4gICAgICAvLyBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzbid0LCByZXR1cm4gdGhlIHByZXZpb3VzIHNlbGVjdGlvbi4gVGhhdCBzaWduYWxzXG4gICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblxuICAgICAgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcbiAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcbiAgICAgIC8vIHRvIFJlYWN0IHRoYXQgdGhlIHNlbGVjdGlvbnMgYXJlIGNvbmNlcHR1YWxseSBlcXVhbCwgYW5kIHdlIGNhbiBiYWlsXG4gICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybiBwcmV2U2VsZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuICAgICAgbWVtb2l6ZWRTZWxlY3Rpb24gPSBuZXh0U2VsZWN0aW9uO1xuICAgICAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG4gICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cbiAgICAvLyBBc3NpZ25pbmcgdGhpcyB0byBhIGNvbnN0YW50IHNvIHRoYXQgRmxvdyBrbm93cyBpdCBjYW4ndCBjaGFuZ2UuXG4gICAgdmFyIG1heWJlR2V0U2VydmVyU25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdldFNlcnZlclNuYXBzaG90O1xuXG4gICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1lbW9pemVkU2VsZWN0b3IoZ2V0U25hcHNob3QoKSk7XG4gICAgfTtcblxuICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihtYXliZUdldFNlcnZlclNuYXBzaG90KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuICB9LCBbZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90LCBzZWxlY3RvciwgaXNFcXVhbF0pLFxuICAgICAgZ2V0U2VsZWN0aW9uID0gX3VzZU1lbW9bMF0sXG4gICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuICB2YXIgdmFsdWUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNlbGVjdGlvbiwgZ2V0U2VydmVyU2VsZWN0aW9uKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpbnN0LnZhbHVlID0gdmFsdWU7XG4gIH0sIFt2YWx1ZV0pO1xuICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yID0gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3I7XG4gICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuaWYgKFxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xufVxuICAgICAgICBcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\n"));

/***/ }),

/***/ "../../node_modules/use-sync-external-store/shim/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/shim/index.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim.development.js */ \"../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDRMQUE4RTtBQUNoRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanM/YWZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/use-sync-external-store/shim/index.js\n"));

/***/ }),

/***/ "../../node_modules/use-sync-external-store/shim/with-selector.js":
/*!************************************************************************!*\
  !*** ../../node_modules/use-sync-external-store/shim/with-selector.js ***!
  \************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ../cjs/use-sync-external-store-shim/with-selector.development.js */ \"../../node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vd2l0aC1zZWxlY3Rvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsd05BQTRGO0FBQzlGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS93aXRoLXNlbGVjdG9yLmpzP2EwM2EiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2Nqcy91c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltL3dpdGgtc2VsZWN0b3IucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vY2pzL3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0vd2l0aC1zZWxlY3Rvci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/use-sync-external-store/shim/with-selector.js\n"));

/***/ }),

/***/ "../../node_modules/@inrealtime/react/node_modules/zustand/esm/vanilla.mjs":
/*!*********************************************************************************!*\
  !*** ../../node_modules/@inrealtime/react/node_modules/zustand/esm/vanilla.mjs ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createStore\": function() { return /* binding */ createStore; },\n/* harmony export */   \"default\": function() { return /* binding */ vanilla; }\n/* harmony export */ });\nconst createStoreImpl = (createState) => {\n  let state;\n  const listeners = /* @__PURE__ */ new Set();\n  const setState = (partial, replace) => {\n    const nextState = typeof partial === \"function\" ? partial(state) : partial;\n    if (!Object.is(nextState, state)) {\n      const previousState = state;\n      state = (replace != null ? replace : typeof nextState !== \"object\") ? nextState : Object.assign({}, state, nextState);\n      listeners.forEach((listener) => listener(state, previousState));\n    }\n  };\n  const getState = () => state;\n  const subscribe = (listener) => {\n    listeners.add(listener);\n    return () => listeners.delete(listener);\n  };\n  const destroy = () => {\n    if (true) {\n      console.warn(\n        \"[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected.\"\n      );\n    }\n    listeners.clear();\n  };\n  const api = { setState, getState, subscribe, destroy };\n  state = createState(setState, getState, api);\n  return api;\n};\nconst createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;\nvar vanilla = (createState) => {\n  if (true) {\n    console.warn(\n      \"[DEPRECATED] Default export is deprecated. Instead use import { createStore } from 'zustand/vanilla'.\"\n    );\n  }\n  return createStore(createState);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BpbnJlYWx0aW1lL3JlYWN0L25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS92YW5pbGxhLm1qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsSUFBMEQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBEO0FBQ2hFO0FBQ0EsdUVBQXVFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7O0FBRTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvQGlucmVhbHRpbWUvcmVhY3Qvbm9kZV9tb2R1bGVzL3p1c3RhbmQvZXNtL3ZhbmlsbGEubWpzPzI4ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3JlYXRlU3RvcmVJbXBsID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKCFPYmplY3QuaXMobmV4dFN0YXRlLCBzdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gKHJlcGxhY2UgIT0gbnVsbCA/IHJlcGxhY2UgOiB0eXBlb2YgbmV4dFN0YXRlICE9PSBcIm9iamVjdFwiKSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlID0gKGxpc3RlbmVyKSA9PiB7XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9O1xuICBjb25zdCBkZXN0cm95ID0gKCkgPT4ge1xuICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJbREVQUkVDQVRFRF0gVGhlIGBkZXN0cm95YCBtZXRob2Qgd2lsbCBiZSB1bnN1cHBvcnRlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiBJbnN0ZWFkIHVzZSB1bnN1YnNjcmliZSBmdW5jdGlvbiByZXR1cm5lZCBieSBzdWJzY3JpYmUuIEV2ZXJ5dGhpbmcgd2lsbCBiZSBnYXJiYWdlLWNvbGxlY3RlZCBpZiBzdG9yZSBpcyBnYXJiYWdlLWNvbGxlY3RlZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gIH07XG4gIGNvbnN0IGFwaSA9IHsgc2V0U3RhdGUsIGdldFN0YXRlLCBzdWJzY3JpYmUsIGRlc3Ryb3kgfTtcbiAgc3RhdGUgPSBjcmVhdGVTdGF0ZShzZXRTdGF0ZSwgZ2V0U3RhdGUsIGFwaSk7XG4gIHJldHVybiBhcGk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoY3JlYXRlU3RhdGUpID0+IGNyZWF0ZVN0YXRlID8gY3JlYXRlU3RvcmVJbXBsKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0b3JlSW1wbDtcbnZhciB2YW5pbGxhID0gKGNyZWF0ZVN0YXRlKSA9PiB7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ICYmIGltcG9ydC5tZXRhLmVudi5NT0RFKSAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIltERVBSRUNBVEVEXSBEZWZhdWx0IGV4cG9ydCBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkIHVzZSBpbXBvcnQgeyBjcmVhdGVTdG9yZSB9IGZyb20gJ3p1c3RhbmQvdmFuaWxsYScuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjcmVhdGVTdG9yZShjcmVhdGVTdGF0ZSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVTdG9yZSwgdmFuaWxsYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/@inrealtime/react/node_modules/zustand/esm/vanilla.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("../../node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=private-next-pages%2F_app&page=%2F_app!"), __webpack_exec__("../../node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);